
\section{Grove By Example}%
\label{sec:Grove By Example}

This section introduces collaborative structure editing in Grove by example.
\autoref{sub:Program Representation} describes how we use graphs to represent collaborative program sketches. 
\autoref{sub:Single-User Actions} then shows examples of edits being performed by a single user, Alice. 
\autoref{sub:Multi-user Interactions}-\ref{sub:Merge Conflicts} then describes a collaboration between two users, Alice and Bob,
as they edit their own branches of a program and periodically merge in each other's edits, starting with examples without conflicts, then considering the various kinds of conflicts that might arise.

For simplicity and concision, all of the examples in this section will be for a 
language of standard arithmetic operations, 
but our formalism in \autoref{sec:Formalism} and our implementation in \autoref{sec:Implementation} are parameterized by an arbitrary abstract syntax.

\figureSimple


Grove can form the basis for both a conventional version control workflow,
where edits are batched into commits, or real-time collaborative editing, 
where edits are communicated as they occur. This paper makes no assumptions about which batching mode is in use, nor do we consider the well-studied problem of reliably and efficiently communicating patches over a network.
%\autoref{sub:Cursors} discusses representing cursor locations when in real-time mode. 

\subsection{Representing Collaborative Program Sketches as Graphs}%
\label{sub:Program Representation}

The \textit{edit state} of a Grove branch is a directed multi-graph representing a \emph{collaborative program sketch}, meaning an incomplete program, i.e. one that may have \emph{holes} and (as we will return to) conflicts. 
For example, \autoref{fig:Simple:a} gives one such graph and its corresponding \emph{decomposition} into, in this case, a single syntax tree,~\texttt{x * \hole},
whose missing right operand is a hole, denoted $\hole$.

Each vertex represents a term in the specified language, except for a distinguished root vertex, 
and is labeled with a unique identifier (UID) and a \emph{constructor}. 
In \autoref{fig:Simple:a}, the root vertex has UID 0 and constructor~\textbullet. 
Vertices \vSimpleTimes{} and \vSimpleX{} have UIDs 2 and 4 and constructors~\texttt{*} and \texttt{var(}$x$\texttt{)}, respectively.
For clarity, we abbreviate \texttt{var(}$x$\texttt{)} as simply \texttt{x}; here, $x$ is a constructor parameter. We treat identifiers and literals as indivisible, but we discuss character-level editing in \autoref{sec:Discussion and Conclusion}.

An edge indicates that the destination vertex is a child of the origin vertex. 
Each edge is labeled with a UID~(e.g.,~1 and~3 in \autoref{fig:Simple:a})
and a \emph{position} (e.g., \texttt{Root} and \texttt{L} in \autoref{fig:Simple:a}). 
The parent vertex's constructor determines a set of valid {positions}. 
For instance, the~\texttt{*} constructor defines positions
~\texttt{L}~(for the left operand)
and~\texttt{R}~(for the right operand).
The~\texttt{var} constructor is a leaf so it defines no positions.
The root vertex constructor~\textbullet~has a single child position, \texttt{Root}.

%Visually, we indicate the position of an edge by the location of its origin.

Holes arise in the decomposition by the absence of a child at a valid position.
For example, in \autoref{fig:Simple:a} the absence of an \texttt{R} child under \vSimpleTimes{}
corresponds to the hole in the right operand of~\texttt{x * \hole}.

For clarity, we use odd numbers for vertex UIDs and even numbers for edge UIDs. In practice, UIDs would be generated by a mechanism
that effectively ensures that collaborators always generate distinct UIDs, e.g. by generating
universally unique IDs (UUIDs)~\cite{paskin1999toward}.

% \figureMove{}

\subsection{Structure Editing}%
\label{sub:Single-User Actions}
\figureWrapMove

Individual users perform \emph{edits} to evolve the edit state. We consider several standard edits, including insertion, deletion, cut-and-paste (relocation), copy-and-paste, and undo/redo. This paper abstracts over the user interface aspects of structure editors and makes no usability-related claims; these edits could be performed through, for example, drag-and-drop interactions (as in block-based editors like Scratch) or keyboard interactions (as in MPS and Hazel).  % User interface design for structure editors remains an active research area.
% The common thread is that structure editors maintain a program sketch throughout the editing process.

Each edit translates directly to a \emph{graph patch}, which consists of a sequence of \emph{patch commands}. The Grove patch language requires only two patch commands:  \emph{edge insertion} and \emph{edge deletion}. A vertex is inserted when it is included in an edge insertion command.

To illustrate the Grove patch language, let us consider a sequence of standard edits, found across structure editors, performed by a single user, Alice.

\subsubsection{Hole Filling}%
\label{sub:Construction}

First, Alice fills the hole in the right position of \texttt{x * \hole} from \autoref{fig:Simple:a} with the variable~\texttt{y}. The resulting edit state is shown in \autoref{fig:Simple:b}.
The patch corresponding to this hole filling action inserts an edge, labeled \eSimpleY{}, from the vertex corresponding to the parent term, \vSimpleTimes{}, to the newly constructed variable's vertex, \vSimpleY{}. 
The resulting graph decomposes to the term \texttt{x * y}.

\subsubsection{Deletion}%
\label{sub:Deletion}

% \figureMove{}

Next, Alice moves the cursor to~\texttt{x} in \autoref{fig:Simple:b} and deletes it, 
causing the deletion of edge~\eSimpleX{} and  resulting in the decomposition~\texttt{\hole{} * y} as shown in \autoref{fig:Simple:c}.

Once an edge with a particular identifier is deleted, it cannot be re-inserted.
For instance, if Alice performed an ``undo'' on this deletion,
a fresh edge between \vSimpleTimes{} and \vSimpleX{} would be created. (We can allow simple undo only if the patch has not yet been communicated to a collaborator). 

Notice that vertex \vSimpleX{} continues to exist (and if it had any children, they would remain connected to it; see below for the implications in the collaborative setting). In the remaining figures, we omit such orphaned vertices if they are not relevant to the exposition.

% The same state would arise if Alice cut \li{x}: we assume each user has an individually managed clipboard, so until a corresponding {paste} edit is performed the vertex is deleted but it can be restored by edge insertion.

\subsubsection{Wrapping}%
\label{sub:Wrapping}

Next, Alice moves the cursor to the parent term \vSimpleTimes{} in \autoref{fig:Simple:c}
with the intention of wrapping it in a binary addition expression with constructor~\texttt{+}.

Many structure editors define a primitive wrapping edit, choosing a position heuristically (e.g. favoring the left). Others 
require the user to cut the original term, construct the new outer term, then paste
the original term in the intended position. 

In either case, the corresponding sequence of patch commands would produce the edit states shown in \autoref{fig:Wrap}: the edge connecting the root to the original term is deleted (effectively cutting the original term), leaving \vSimpleTimes{} temporarily orphaned, then an edge to the new outer term is inserted, followed by an edge reconnecting the original term (effectively pasting the original term).

\subsubsection{Relocation}%
\label{sub:Repositioning}

Alice changes her mind and decides to relocate the multiplication from the left to the right position of the addition. A structure editor might support this using drag-and-drop or cut-and-paste affordances. In either case, the resulting patch commands will proceed through the two states shown in \autoref{fig:Move}: deleting the original incoming edge and then inserting an edge at the new location. Notice that the sub-graph corresponding to the relocated term itself is never deleted nor re-inserted, in contrast to conventional line-based patch languages.
See below for the implications in the collaborative setting.

\subsubsection{Copying} 
\label{sub:Copy}
A copy-and-paste, or a cut followed by multiple pastes, would of course involve copying the graph structure of the original term but generating fresh UIDs (not shown).


% \figureDifferentParts{}

%\figureCommutativity{}
\subsection{Collaboration}%
\label{sub:Multi-user Interactions}

We now turn our attention to how Grove handles collaboration.
The examples in this section generalize to collaborations between any number of users,
but for simplicity we consider only two: Alice and Bob.
Alice and Bob are each concurrently editing their own branches of the repository (or their own instance of a real-time collaborative editor), 
performing edits that translate to patches as described above. 
They periodically communicate these patches to one another. \autoref{fig:Commutativity} diagrams the Grove collaboration model.



\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \path (-3cm, 0cm) node (a) [align=center]            {Base \\ Branch};
    \path ( 0cm, 1cm) node (b) [align=center,alice node] {Alice's  \\ Branch};
    \path ( 0cm,-1cm) node (c) [align=center,bob node]   {Bob's    \\ Branch};
    \path ( 3cm, 0cm) node (d) [align=center]            {Merged \\ Branch};
    \path [draw,->,alice step] (a) -- node [pos=0.7,align=center,auto]      {Alice's \\ Edits} (b);
    \path [draw,->,bob step]   (a) -- node [pos=0.7,align=center,auto,swap] {Bob's \\ Edits}   (c);
    \path [draw,->,merge step] (b) -- node [pos=0.3,align=center,auto]      {Apply \\Bob's Patch} (d);
    \path [draw,->,merge step] (c) -- node [pos=0.3,align=center,auto,swap] {Apply \\Alice's Patch} (d);
  \end{tikzpicture}
  \caption{Collaboration in Grove is simple due to the commutativity of Grove's patch language.}
  \Description{This figures describes the commutativity of edits}
  \label{fig:Commutativity}
\end{figure}



\subsubsection{Commutativity}%
\figureDifferentPartsNestedParts

\label{sub:Commutativity:informal}
The Grove patch language is commutative, meaning that there is no need for a 
complex three-way merge algorithm (i.e. operational transform). Instead, each 
user can simply apply incoming patches to their own edit state as they arrive, no matter the order in 
which they arrive. If two users have received the same set of patches, their edit state will converge.

The key properties that make the Grove patch language commutative is that 
edge deletion is permanent and vertex insertion is permanent.
We establish commutativity formally in \autoref{sec:Formalism}.
For now, let us consider several example scenarios that demonstrate 
how Grove handles different collaborative editing scenarios, particularly 
the problematic situations outlined in \autoref{sec:Introduction}. 

\subsubsection{Solving the Granularity Problem}%
\label{sub:Editing Different Parts of the Code}

Alice and Bob start where Alice left off in \autoref{fig:Move:b} 
with the term \texttt{\hole{} + \hole{} * y}.
Alice then adds~\vDifferentPartsAlice{} as the left child of \vSimpleTimes{}.
Concurrently, Bob changes \vSimpleY{} to \vDifferentPartsBob{}.
Before sharing their patches,
Alice and Bob have the edit states \autoref{fig:DifferentParts:a} and \autoref{fig:DifferentParts:b}, respectively.
Note that the transition from \autoref{fig:Move:b} to \autoref{fig:DifferentParts:b}
represents multiple graph updates,
i.e., deleting~\eSimpleY{} and adding~\eDifferentPartsBob{} along with its child~\vDifferentPartsBob{}.
We thus mark the transition with a star.
Once Alice and Bob share their patches and apply each other's patch to their own edit state,
both edit states converge to the graph in \autoref{fig:DifferentParts:c}. 
Because Grove's patch language is structural rather than line-based, the fact that these edits happened to be close to one another (i.e. in the same arithmetic expression) does not run afoul of the \textbf{granularity problem} described in \autoref{sec:Introduction}.

% \figureNestedParts{}

\subsubsection{Solving the Relocation Modification Problem}%%
\label{sub:Editing Nested Parts of the Code}

After converging on \texttt{\hole{} + u * y} in \autoref{fig:DifferentParts:c}, 
Alice changes~\vDifferentPartsAlice{} to~\vNestedPartsAlice{},
producing the edit state in \autoref{fig:NestedParts:a}.
Meanwhile, Bob relocates~\vSimpleTimes{} (bringing along its children)
from the~\texttt{R} position of~\vWrapPlus{} to the~\texttt{L} position. As discussed above, this involves deleting~\eMoveTimes{} and adding~\eNestedPartsBob{}.
Bob's resulting edit state is shown in \autoref{fig:NestedParts:b}.

Although Alice has modified a term that Bob has concurrently relocated, the edits commute: Alice's modifications are relocated to the new location chosen by Bob.
This addresses the \textbf{relocation modification problem} described in \autoref{sec:Introduction}.
In a line-based setting, this kind of edit can lead to silent code duplication or spurious conflicts (the threat of which, in the author's experience, can inhibit development teams from performing useful code reorganizations).

% TODO: \todo{TODO}She can restore that code using a restoration action and add a fresh edge to it.

\subsubsection{Warning of Edits under Disconnected Terms}

If instead of relocating the multiplication in \autoref{fig:NestedParts}, Bob had deleted it (i.e. disconnected it from the root), then Alice's edits would still commute, but her edits would be applied under a deleted term. 

This situation could also arise in a real-time collaborative editor, where each individual edit might arrive at any time (rather than in atomic commits). If Alice, say, receives Bob's deletion of~\eMoveTimes{}, then makes her edits 
before receiving Bob's subsequent insertion of~\eNestedPartsBob{} to complete the relocation, 
Alice's edits would then temporarily be under a disconnected term. 

This does not present a formal problem or conflict. A subsequent edit might reconnect a disconnected term, so it is sensible for edits to these terms to be recorded. 
However, heuristically, a system might warn users, perhaps after a period of quiescence in a real-time setting, that Alice's edits were effectively deleted and provide affordances for interacting with disconnected terms.

\subsection{Conflicts}%
\label{sub:Merge Conflicts}

The collaborative edits discussed so far merge cleanly,
but in general, merging patches can lead to graphs that do not map cleanly to a conventional syntax tree. We identify several different motifs that might arise, all of which give rise to different kinds of conflicts in the graph decomposition: \emph{local conflicts}, \emph{relocation conflicts}, and \emph{unicyclic relocation conflicts}. 
As with merge conflicts in version-control systems such as git, these all require user intervention to resolve. 
%As we will return to in \autoref{sec:Type System}\todo{sec}, conflicts need not disable type-based editor services (the \textbf{semantic gap problem}). Instead, the system can type check around these conflict (and in some cases, infer a type for the conflict itself).

\subsubsection{Local Conflicts}%
\label{sub:Multi-child conflicts}

\figureMultiChild

Suppose Alice and Bob both start with the edit state \texttt{w * v + \hole} from \autoref{fig:NestedParts:c}.
Alice moves the cursor to the hole and constructs~\vMultiChildAlice{} as the~\texttt{R} child of~\vWrapPlus{}.
At the same time, Bob constructs~\vMultiChildBob{} at the same location.
Now Alice and Bob have the graphs in \autoref{fig:MultiChild:a} and \autoref{fig:MultiChild:b}, respectively.

When these patches are merged in \autoref{fig:MultiChild:c}, \emph{both} \eMultiChildAlice{} and \eMultiChildBob{}
appear in the merged graph. 
When decomposing this graph to a syntax tree, 
we resolve this conflict in the~\texttt{R} position of~\vWrapPlus~by decomposing to a \emph{local conflict}, {\binaryConflictHole{x}{y}}.

% TODO: "delete both"

Local conflicts can be resolved simply by deleting or relocating all but one of the conflicting terms (and editing the remaining term into the correctly merged value, if needed), which would remove the corresponding edge.
For example, Alice could resolve the problem by wrapping \li{x} and \li{y} with a multiplication, effectively moving them to non-conflicting locations.
No special edit actions are needed for conflict resolution.

% To ensure users can continue editing while in a conflicted state,
% all conflicts must be resolved before a program can be run.\footnote{It
%   may be possible to develop evaluation models that allow these sorts of conflicts,
%   but that is beyond the scope of this paper.})
% % TODO: need example of fully-automatic resolution and semi-automatic resolution.
% Note that as a convenience to the user, certain simple conflicts might be automatically resolved,
% but we consider this a higher-level, user-interface consideration.

It is worth noting one special situation: if Alice and Bob independently filled the hole with structurally identical terms, e.g. \li{x}, Grove would \emph{still} formally identify a conflict, because the terms have distinct UIDs. In this situation, it would be reasonable for the system to resolve the conflict without further coordination by deterministically choosing one of the two terms, e.g. the smallest.

When the conflicted terms are similar up to UID differences but not identical, it might be helpful  to give the developer the option to ``push down'' the conflicts as deeply as possible, using a tree differencing algorithm. However, this would increase the number of conflicts overall, so it may not always be preferable. Tree differencing is not fundamental to the collaboration model of Grove.


\subsubsection{Relocation Conflicts}%
\label{sub:Multi-parent conflicts}

\figureMultiParent

Grove's support for repositioning creates the possibility for \emph{relocation conflicts}. These occur when a merge causes a vertex to have multiple incoming edges, indicating that it does not have a uniquely determined location (as opposed to local conflicts, which occur when there are multiple outgoing edges at a specified location). 

For example, \autoref{fig:MultiParent} shows an example where Alice and Bob relocate a term, \li{w}, to two different locations (the two holes in \autoref{fig:MultiParent:a}). In both cases, the edits are modeled as one edge deletion followed by one edge addition.
Alice deletes~\eNestedPartsAlice{} and adds~\eMultiParentAlice{} in \autoref{fig:MultiParent:b}.
At the same time, Bob deletes~\eNestedPartsAlice{} and adds~\eMultiParentBob{} in \autoref{fig:MultiParent:c}.
Edge deletions is idempotent,
so the fact that Alice and Bob both deleted~\eNestedPartsAlice{} will not lead to a conflict. 
However, both~\eMultiParentAlice{} (added by Alice) and~\eMultiParentBob{} (added by Bob)
point to the same vertex.
Once these patches are merged, the resulting edit state is given in \autoref{fig:MultiParent:d}.
Notice~\vNestedPartsAlice{} has two edges pointing to it. 
When decomposing the graph, we leave a \emph{relocation conflict reference}, $\multiVertex{18}$, at each conflicting location. The conflicted term is separately tracked in the result of decomposition, which, due to conflicts like these, is formally a set of terms with references like these between them. We call this set a \emph{grove}. 
This approach partially addresses the \textbf{relocation conflict problem} from \autoref{sec:Introduction} (we also need to handle unicycles, see below, to fully address the problem).

To resolve relocation conflicts, a user can simply delete all but one of the relocation conflict references. This will cause the corresponding edges to be deleted,
and when only one edge remains, there will no longer be a conflict. An editor might provide a more convenient way of deleting all but a selected relocation conflict reference, and provide affordances for displaying these terms, e.g. by transcluding them inline at each location or showing them in a separate sidebar.

% \subsubsection{Single-User Cycles}
% \label{sub:Cycles}

% TODO: cut this section

% \figureSingleUserCycles{}

% Another case we must consider is when cycles appear in the graph.
% We categorize these into cycles caused by the action of a single user
% and cycles caused by the interaction of the actions of multiple users.

% In a single user context,
% normal insertion and deletion of code by the user cannot create cycles.
% However, it is possible with certain kinds of copy and paste.
% For example, suppose Alice is editing the code in \autoref{fig:Single-User Cycles:a}
% and uses copy and paste to copy \Vertex{TODO} to the right child of \Vertex{TODO}.
% There are two ways to interpret the paste action.
% The first interpretation is to create a deep copy of \Vertex{TODO}.
% This results in \autoref{fig:Single-User Cycles:b} and
% does not cause a cycle.
% The second interpretation is to simply add an edge to \Vertex{TODO}.
% This results in \autoref{fig:Single-User Cycles:b}
% and causes a cycle.

% Note that not all pastes should be deep copies.
% For example, Alice may have accomplished code move in \autoref{sub:Editing Nested Parts of the Code}
% by a cutting from the old position and pasting to the new position.
% Preserving Bob's nested edits requires that the paste be by reference instead of by copy.
% Distinguishing when a paste should be by reference versus by copy
% is ultimately a user interface question.
% Cycles caused by the local user's edits can be detected as soon as a user enters them
% by noting either that the graph would contain a cycle or the vertex
% already has a parent somewhere in the graph.

% Thus, as a user interface consideration, it might be best to either
% disallow such edits to at least warn users when their
% edits would create a cycle.

\subsubsection{Cycles}%
\label{sub:Multi-User Cycles}

\figureCycle
\figureDisconnect

Relocation in a collaborative setting can also lead to cycles in the graph. 
For example, consider the situation in \autoref{fig:Cycle}.
Starting in \autoref{fig:Cycle:a}, 
Alice relocates~\vMultiCycleTimes{} to the \texttt{R} child of~\vWrapPlus{}
and then~\vMultiCyclePlus{} underneath that in \autoref{fig:Cycle:b}.
Bob does the opposite, putting~\vMultiCycleTimes{} under~\vMultiCyclePlus{} in \autoref{fig:Cycle:c}. On their own, neither of these edits creates a cycle.
However, merging the two patches results in the graph
in \autoref{fig:Cycle:d}, which has a cycle
between~\vMultiCycleTimes{} and~\vMultiCyclePlus{}.

The main difficulty with cycles has to do with decomposition back to a term, i.e. a syntax tree. We do not want decomposition to traverse endlessly attempting to create an infinite tree, so we need to break the cycle somewhere.

If the cycle is connected to a larger term, then there will necessarily be at least one vertex along the cycle that has multiple incoming edges. In \autoref{fig:Cycle}, both \vMultiCycleTimes{} and \vMultiCyclePlus{} have multiple incoming edges. As described above, decomposition will leave relocation conflict references in these positions, thereby breaking the cycle. In this example, these references appear within a local conflict as well, because both vertices were relocated under a common parent vertex. As before, this cycle can be broken by deleting or otherwise modifying the terms until there are no longer any such conflicts.

It is also possible to merge patches such that a \emph{disconnected unicycle} emerges in the graph, even when neither patch disconnects any vertex from the root. \autoref{fig:Disconnection} shows a simple example of when this could occur: Alice relocates~\vMultiCycleTimes{} under~\vSimpleTimes{},
while Bob relocates~\vSimpleTimes{} under~\vMultiCycleTimes{}. 
This results in \autoref{fig:Disconnect:b} and \autoref{fig:Disconnect:c}, respectively.
Merging these causes both vertices to become disconnected, because they were both relocated. The inserted edges form a \emph{unicycle}, meaning a cycle where every vertex has in-degree $1$. In this case, we cannot rely on relocation references to break the cycle. Instead, we break the cycle by arbitrarily but deterministically choosing an edge along the unicycle, e.g. the edge with the smallest UID, and leaving a \emph{unicycle conflict reference} at that location, as shown in \autoref{fig:Disconnect:d}. A user can be notified of this situation when merging and resolve these conflicts again by relocating or deleting terms until the cycle no longer exists in the graph.

Relocation conflict references and unicycle conflict references together fully address the \textbf{relocation conflict problem} from \autoref{sec:Introduction}.


% TODO: technically a cycle

% TODO: in general detect when there are or were edits to something now deleted

% \todo{UI would show orphans only once edits orphans occur}

% \subsection{Cursors}%
% \label{sub:Cursors}

% \paragraph{Representation}

% For most editing a cursor is represented by a position within a vertex.
% For example, in TODO, Bob's cursor might be at the TODO position of the TODO:vertex.
% Representing it this way means that if Bob or some other user deletes TODO:vertex
% and replaces it with a different vertex, Bob's cursor is still valid.
% We specify a position within a vertex instead of a vertex because TODO.

% However, there is one case where we need a more precise cursor.
% That is when a vertex has a multi-child conflict (e.g. TODO in FIG:TODO).
% We want users to be able to put their cursor on either the conflict as a whole
% (e.g., TODO: \texttt{\{ x | y \}})
% or on an individual element (e.g., \texttt{x} or \texttt{y}).
% In the former case, a pair of a vertex and a child position suffices.
% For the latter case, we represent cursors by an edge identifier (e.g., TODO in TODO:FIG).

% \paragraph{Communication}

% In our system all edits use edge and vertex identifiers, and user
% cursors do not affect the interpretation of graph edits.
% Thus, cursors need not be communicated to other users.
% However, in a collaborative setting, seeing the cursors of other users
% can be useful.
% For this purpose, editors can announce their cursor position to other editors.
% At any point in time, the announcement
% with the most recent timestamp
% for a particular user
% is used.

% Note that this cursor position may refer to edges or verticies that
% do not yet exist on the receivers machine.
% In these cases, we can either not display the other user's cursor (and perhaps
% have a visual display flagging this fact), or we can display the most recent
% cursor that represents a valid position in the local graph (perhaps
% shown in a fadded color to show that this cursor is known to not be up to date).
% (Or perhaps, all cursors always fade/decay over time like on radar blips.)
