\section{Formalism}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Syntax}

\figureTermSyntaxContent

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a function from edges to edge states,
  where $\E = \U \times \V \times \P \times \V$,
  unique IDs are drawn from some suitable set $\U$ equipped with a total ordering $\leq$,
  vertices are drawn from $\V$,
  positions are drawn from $\P$,
  and edge states are drawn from $\Sigma$.
\end{definition}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\figureArityContent

\begin{definition}
  Let $\e = (u, (u_1, k_1), p, (u_2, k_2))$.
  A graph $G$ is well sorted if $(p, \sort(k_2)) \in \arity(k_1)$
  for all $\e$ such that $G(\e) \in \{\Plus, \Minus\}$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}
E
\begin{theorem}
  Let $G$ be a well sorted graph.
  There exists a grove $\Grove$ such that $\decomp{G} = \Grove$.
\end{theorem}

Proof: provide a witness that demonstrates the conclusion.

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\decomp{G} = \Grove$ then $\vertexes{G} = \vertexes{\Grove}$.
% \end{theorem}

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\recomp{\Grove} = G$ then $\vertexes{\Grove} = \vertexes{G}$.
% \end{theorem}

\begin{theorem}
  Let $G$ be a well sorted graph.
  if $\decomp{G} = \Grove$ then $\recomp{\Grove} = G$.
\end{theorem}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}

\begin{align*}
  \children(v, p) &= \SetOf{v' \SuchThat{\exists \e = (u, v, p, v'), G(\e) = \Plus}} \\
  \parents(v) &= \SetOf{v' \SuchThat{\exists \e = (u, v', p, v), G(\e) = \Plus}} \\
  \ancestors(v) &= \mathopen{}\left( \lfp(\ancestors') \right)\mathclose{}(v) \\
  \ancestors'(v) &= \parents(v) \cup \ancestors'(\parents(v)) \\
  \min\mathopen{}\left(\SetOf{(u_1, k_1), \ldots, (u_n, k_n)}\right)\mathclose{} &= (u_j, k_j) \text{ s.t. } 1 \leq j \leq n \land u_j \le u_i \forall i = 1, \ldots, n
\end{align*}

\noindent $\boxed{\decomp{G} = \Grove}$
%
\begin{align*}
  \decomp{G} &= (NP, MP, U, D) \\
  NP &= \SetOf{\edecomp{v} \SuchThat{|\parents(v)| = 0}} \\
  MP &= \SetOf{\edecomp{v} \SuchThat{|\parents(v)| > 1}} \\
  U &= \SetOf{\edecomp{v} \SuchThat{|\parents(v)| = 1 \land v = \min(\ancestors(v))}} \\
  D &= \SetOf{\e \SuchThat{G(\e) = \Minus}}
\end{align*}

\noindent $\boxed{\edecomp{v} = e}$
%
\begin{align*}
  \edecomp{v=(u, Root)} &= \edecompPrime{v}{Root} \\
  \edecomp{v=(u, \ExpVar(x))} &= x^{\id{u}} \\
  \edecomp{v=(u, \ExpLam)} &= \lambda^{\id{u}} \pdecompPrime{v}{\LamParam} : \tdecompPrime{v}{\LamType} . \edecompPrime{v}{\LamBody} \\
  \edecomp{v=(u, \ExpApp)} &= (\edecompPrime{v}{\AppFun}~\edecompPrime{v}{\AppArg})^{\id{u}} \\
  \edecomp{v=(u, \ExpNum(n))} &= n^{\id{u}} \\
  \edecomp{v=(u, \ExpPlus)} &= \edecompPrime{v}{\PlusLeft}~\texttt{+}^{\id{u}}~\edecompPrime{v}{\PlusRight} \\
  \edecomp{v=(u, \ExpTimes)} &= \edecompPrime{v}{\TimesLeft}~\texttt{*}^{\id{u}}~\edecompPrime{v}{\TimesRight}
\end{align*}

\noindent $\boxed{\pdecomp{v} = q}$
%
\begin{align*}
  \pdecomp{v=(u, \PatVar(x))} &= x^{\id{u}}
\end{align*}

\noindent $\boxed{\tdecomp{v} = \tau}$
%
\begin{align*}
  \tdecomp{\tau=(u, \TypArrow)} &= \tdecompPrime{\tau}{\ArrowArg} \rightarrow^{\id{u}} \tdecompPrime{\tau}{\ArrowResult} \\
  \tdecomp{\tau=(u, \TypNum)} &= Num^{\id{u}}
\end{align*}

\noindent $\boxed{\edecompPrime{v}{p} = e}$
%
\begin{align*}
  \edecompPrime{v}{p} = \begin{cases}
    \hole & \children(v,p) = \varnothing \\
    \conflictHole{\edecomp{v_1}, \ldots, \edecomp{v_n}} & \children(v,p) = \SetOf{v_1, \ldots, v_n} \\
    \multiVertex{u} & \children(v,p) = \SetOf{v'} \land |\parents(v')| > 1 \\
    \cycleVertex{u} & \children(v,p) = \SetOf{v' = (u,k)} \land |\parents(v')| = 1 \\
        & \phantom{\children(v,p)} \land v' = \min(\ancestors(v')) \\
    \edecomp{v'} & \text{otherwise} \\
  \end{cases}
\end{align*}

\noindent $\boxed{\pdecomp{v}{p} = q}$
%
\begin{align*}
  \pdecompPrime{v}{p} = \begin{cases}
    \hole & \children(v,p) = \varnothing \\
    \conflictHole{\pdecomp{v_1},\ldots,\pdecomp{v_n}} & \children(v,p) = \SetOf{v_1, \ldots, v_n} \\
    \multiVertex{u} & \children(v,p) = \SetOf{v'} \land |\parents(v')| > 1 \\
    \cycleVertex{u} & \children(v,p) = \SetOf{v'=(u,k)} \land |\parents(v')| = 1 \\
        & \phantom{\children(v,p)} \land v' = \min(\ancestors(v')) \\
    \pdecomp{v'} & \text{otherwise} \\
  \end{cases}
\end{align*}

\noindent $\boxed{\tdecompPrime{v}{p} = \tau}$
%
\begin{align*}
  \tdecompPrime{v}{p} = \begin{cases}
    \hole & \children(v,p) = \varnothing \\
    \conflictHole{\tdecomp{v_1},\ldots,\tdecomp{v_n}} & \children(v,p) = \SetOf{v_1, \ldots, v_n} \\
    \multiVertex{u} & \children(v,p) = \SetOf{v'} \land |\parents(v')| > 1 \\
    \cycleVertex{u} & \children(v,p) = \SetOf{v' = (u,k)} \land |\parents(v')| = 1 \\
        & \phantom{\children(v,p)} \land v' = \min(\ancestors(v')) \\
    \tdecomp{v'} & \text{otherwise} \\
  \end{cases}
\end{align*}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}

\noindent $\boxed{\recomp{\Grove} = G}$
%
\begin{align*}
  \recomp{(MP, NP, U, D)} &= \recompPlus{MP, NP, U} \cup \SetOf{\e \mapsto \Minus \SuchThat{\e \in D}}
\end{align*}

\noindent $\boxed{\recompPlus{MP, NP, U} = G}$
%
\begin{align*}
  \recompPlus{MP, NP, U} &= \SetOf{\e \mapsto \Plus \SuchThat{\e \in \bigcup_{e \in MP \cup NP \cup U} \erecomp{e}}}
\end{align*}

\noindent $\boxed{\erecomp{e} = \E}$
%
\begin{align*}
  \erecomp{\varExp{x}{u}} &= \SetOf{}
  \\
  \erecomp{\numExp{n}{u}} &= \SetOf{}
  \\
  \erecomp{\appExp{e_\AppFun}{e_\AppArg}{u}}
  &= \erecomp{e_\AppFun}
  \cup \erecomp{e_\AppArg} \\
  &\cup \erecompPrime{v}{\AppFun}{e_\AppFun}
  \cup \erecompPrime{v}{\AppArg}{e_\AppArg} \\
  &\quad\text{where } v = (u, \ExpApp)
  \\
  \erecomp{\plusExp{e_\PlusLeft}{u}{e_\PlusRight}}
  &= \erecomp{e_\PlusLeft}
  \cup \erecomp{e_\PlusRight} \\
  &\cup \erecompPrime{v}{\PlusLeft}{e_\PlusLeft}
  \cup \erecompPrime{v}{\PlusRight}{e_\PlusRight} \\
  &\quad\text{where } v = (u, \ExpPlus)
  \\
  \erecomp{\lamExp{u}{q_\LamParam}{\tau_\LamType}{e_\LamBody}}
  &= \precomp{q_\LamParam}
  \cup \trecomp{\tau_\LamType}
  \cup \erecomp{e_\LamBody} \\
  &\cup \precompPrime{v}{\LamParam}{q_\LamParam}
  \cup \trecompPrime{v}{\LamType}{\tau_\LamType} \\
  &\cup \erecompPrime{v}{\LamBody}{e_\LamBody} \\
  &\quad\text{where } v = (u, \ExpLam)
  \\
  \erecomp{\hole} &= \SetOf{}
  \\
  \erecomp{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{k=1}^n \erecomp{e_k}
  \\
  \erecomp{\multiVertex{v}} &= \SetOf{}
  \\
  \erecomp{\cycleVertex{v}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\erecompPrime{v}{p}{e} = \E}$
%
\begin{align*}
  \erecompPrime{v}{p}{\varExp{x}{u}}
  &= \SetOf{(u', v, p, (u, \ExpVar(x)))}
  \\
  \erecompPrime{v}{p}{\numExp{n}{u}}
  &= \SetOf{(u', v, p, (u, \ExpNum(n)))}
  \\
  \erecompPrime{v}{p}{\appExp{e_\AppFun}{e_\AppArg}{u}}
  &= \SetOf{(u', v, p, (u, \ExpApp))}
  \\
  \erecompPrime{v}{p}{\plusExp{e_\PlusLeft}{u} {e_\PlusRight}}
  &= \SetOf{(u', v, p, (u, \ExpPlus))}
  \\
  \erecompPrime{v}{p}{\lamExp{u}{q_\LamParam}{\tau_\LamType}{e_\LamBody}}
  &= \SetOf{(u', v, p, (u, \ExpLam))}
  \\
  \erecompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \erecompPrime{v}{p}{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \erecompPrime{v}{p}{e_i}
  \\
  \erecompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \erecompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\precomp{q} = \E}$
%
\begin{align*}
  \precomp{\varPat{x}{u}} &= \SetOf{}
  \\
  \precomp{\hole} &= \SetOf{}
  \\
  \precomp{\conflictHole{q_1, \cdots, q_n}}
  &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{v}} &= \SetOf{}
  \\
  \precomp{\cycleVertex{v}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\precompPrime{v}{p}{q} = \E}$
%
\begin{align*}
  \precompPrime{v}{p}{\varPat{x}{u}}
  &= \SetOf{(u', v, p, (u, \PatVar(x)))}
  \\
  \precompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \precompPrime{v}{p}{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \precompPrime{v}{p}{e_i}
  \\
  \precompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \precompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\trecomp{\tau} = \E}$
%
\begin{align*}
  \trecomp{\arrowTyp{\tau_\ArrowArg}{u}{\tau_\ArrowResult}}
  &= \trecomp{\tau_\ArrowArg}
  \cup \trecomp{\tau_\ArrowResult} \\
  &\cup \trecompPrime{v}{\ArrowArg}{\tau_\ArrowArg}
  \cup \trecompPrime{v}{\ArrowResult}{\tau_\ArrowResult} \\
  &\quad\text{where } v = (u, \TypArrow)
  \\
  \trecomp{\numTyp{u}} &= \SetOf{}
  \\
  \trecomp{\hole} &= \SetOf{}
  \\
  \trecomp{\conflictHole{\tau_1, \cdots, \tau_n}}
  &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{u}} &= \SetOf{}
  \\
  \trecomp{\cycleVertex{u}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\trecompPrime{v}{p}{\tau} = \E}$
%
\begin{align*}
  \trecompPrime{v}{p}{\arrowTyp{\tau_\ArrowArg}{u}{\tau_\ArrowResult}}
  &= \SetOf{(u', v, p, (u, \TypArrow)))}
  \\
  \trecompPrime{v}{p}{\numTyp{u}}
  &= \SetOf{(u', v, p, (u, \TypNum)))}
  \\
  \trecompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \trecompPrime{v}{p}{\conflictHole{\tau_1, \cdots, \tau_n}}
  &= \bigcup_{i=1}^n \trecompPrime{v}{p}{\tau_i}
  \\
  \trecompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \trecompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} & \Create{k} \mid \Delete \mid \Restore{v} \\
    %  \mid \Drop{\e}
  \end{array}
\]

\begin{align*}
  \Wrap{k, q} &= \Delete; v=\Create{k}; \Restore{v, q} \\
  \Reposition{v, q} &= \Delete; \Restore{v, q} \\
\end{align*}
%
where $v$ is the destination vertex implied by the cursor, when it exists.
When no such vertex exists, $\Restore{v}$ is a no-op.