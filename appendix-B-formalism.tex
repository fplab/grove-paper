\section{Formalism}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Syntax}

\figureTermSyntaxContent

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a function from edges to edge states,
  where $\E = \U \times \V \times \P \times \V$,
  unique IDs are drawn from some suitable set $\U$ equipped with a total ordering $\leq$,
  vertices are drawn from $\V$,
  positions are drawn from $\P$,
  and edge states are drawn from $\Sigma$.
\end{definition}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\figureArityContent

\begin{definition}
  A graph $G$ is well sorted if $\e$ is well sorted
  for all edges $\e$ such that $G(\e) \in \{\Plus, \Minus\}$.
\end{definition}

\begin{definition}
  An edge $\e = (u, (u_1, k_1), p, (u_2, k_2))$ is well sorted
  if $(p, \sort(k_2)) \in \arity(k_1)$.
\end{definition}

\begin{definition}
  A grove $\Grove = (NP, MP, U)$ is well sorted if all of the following hold:
  \begin{enumerate}
    \item $NP$, $MP$, and $U$ contain only well sorted terms.
    \item The root vertex is in $NP$.
    \item The terms in $NP$ have no parents.
    \item The terms in $MP$ have multiple parents.
    \item The terms in $U$ are unicycles.
  \end{enumerate}
\end{definition}

\begin{definition}
  A term is well sorted if
  \begin{enumerate}
    \item there's at least one edge in the incoming edge set
    \item term constructor matches target vertex constructor
    \item target vertex id is the same for all incoming edges
    \item all incoming edges are well sorted
    \item all multiparented references refer to a multiparent root (TODO: do we need this? be careful with wording)
    \item all unicycle references refer to a unicycle root (TODO: do we need this? be careful with wording. Could try to reconstruct the path from root (referenced) to ref (referencer).)
    \end{enumerate}
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

\begin{theorem}
  Let $G$ be a well sorted graph with deleted edges $D \subset \E$.
  There exists a grove $\Grove$ such that $\decomp{G} = (\Grove, D)$.
\end{theorem}

Proof: provide a witness that demonstrates the conclusion.

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\decomp{G} = \Grove$ then $\vertexes{G} = \vertexes{\Grove}$.
% \end{theorem}

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\recomp{\Grove} = G$ then $\vertexes{\Grove} = \vertexes{G}$.
% \end{theorem}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Helpers}

\figureDecompositionDefHelpersContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}\hspace*{\fill} \\

\noindent $\boxed{\decomp{G} = (\Grove, \E)}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\edecomp{\e} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\pdecomp{\e} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\tdecomp{\e} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\edecompPrime{\e}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecompPrime{\e}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecompPrime{\e}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  Let $G$ be a well sorted graph with deleted edges $D \subset \E$
  such that $\decomp{G} = (\Grove, D)$. Then $\recomp{\Grove}{D} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove}{\E} = G}$
%
\begin{align*}
  \recomp{(NP, MP, U)}{D} &= \recompPlus{NP, MP, U} \cup \SetOf{\e \mapsto \Minus \SuchThat{\e \in D}}
\end{align*}

\noindent $\boxed{\recompPlus{NP, MP, U} = G}$
%
\begin{align*}
  \recompPlus{NP, MP, U} &= \SetOf{\e \mapsto \Plus \SuchThat{\e \in \bigcup_{e \in NP \cup MP \cup U} \erecomp{e}}}
\end{align*}

\noindent $\boxed{\erecomp{e} = \E}$
%
\begin{align*}
  \erecomp{\eVar{\backrefs}{u}{x}} &= \SetOf{(u', v', p', (u, \ExpVar(x))) \SuchThat{(u', v', p') \in \backrefs}}
  \\
  \erecomp{\eApp{\backrefs}{u}{e_\AppFun}{e_\AppArg}}
  &= \erecomp{e_\AppFun}
  \cup \erecomp{e_\AppArg} \\
  &\cup \erecompPrime{v}{\AppFun}{e_\AppFun}
  \cup \erecompPrime{v}{\AppArg}{e_\AppArg} \\
  &\quad\text{where } v = (u, \ExpApp)
  \\
  \erecomp{\eNum{\backrefs}{u}{n}} &= \backrefs
  \\
  \erecomp{\plusExp{e_\PlusLeft}{u}{e_\PlusRight}}
  &= \erecomp{e_\PlusLeft}
  \cup \erecomp{e_\PlusRight} \\
  &\cup \erecompPrime{v}{\PlusLeft}{e_\PlusLeft}
  \cup \erecompPrime{v}{\PlusRight}{e_\PlusRight} \\
  &\quad\text{where } v = (u, \ExpPlus)
  \\
  \erecomp{\lamExp{u}{q_\LamParam}{\tau_\LamType}{e_\LamBody}}
  &= \precomp{q_\LamParam}
  \cup \trecomp{\tau_\LamType}
  \cup \erecomp{e_\LamBody} \\
  &\cup \precompPrime{v}{\LamParam}{q_\LamParam}
  \cup \trecompPrime{v}{\LamType}{\tau_\LamType} \\
  &\cup \erecompPrime{v}{\LamBody}{e_\LamBody} \\
  &\quad\text{where } v = (u, \ExpLam)
  \\
  \erecomp{\hole} &= \SetOf{}
  \\
  \erecomp{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{k=1}^n \erecomp{e_k}
  \\
  \erecomp{\multiVertex{v}} &= \SetOf{}
  \\
  \erecomp{\cycleVertex{v}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\erecompPrime{v}{p}{e} = \E}$
%
\begin{align*}
  \erecompPrime{v}{p}{\varExp{x}{u}}
  &= \SetOf{(u', v, p, (u, \ExpVar(x)))}
  \\
  \erecompPrime{v}{p}{\numExp{n}{u}}
  &= \SetOf{(u', v, p, (u, \ExpNum(n)))}
  \\
  \erecompPrime{v}{p}{\appExp{e_\AppFun}{e_\AppArg}{u}}
  &= \SetOf{(u', v, p, (u, \ExpApp))}
  \\
  \erecompPrime{v}{p}{\plusExp{e_\PlusLeft}{u} {e_\PlusRight}}
  &= \SetOf{(u', v, p, (u, \ExpPlus))}
  \\
  \erecompPrime{v}{p}{\lamExp{u}{q_\LamParam}{\tau_\LamType}{e_\LamBody}}
  &= \SetOf{(u', v, p, (u, \ExpLam))}
  \\
  \erecompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \erecompPrime{v}{p}{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \erecompPrime{v}{p}{e_i}
  \\
  \erecompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \erecompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\precomp{q} = \E}$
%
\begin{align*}
  \precomp{\varPat{x}{u}} &= \SetOf{}
  \\
  \precomp{\hole} &= \SetOf{}
  \\
  \precomp{\conflictHole{q_1, \cdots, q_n}}
  &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{v}} &= \SetOf{}
  \\
  \precomp{\cycleVertex{v}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\precompPrime{v}{p}{q} = \E}$
%
\begin{align*}
  \precompPrime{v}{p}{\varPat{x}{u}}
  &= \SetOf{(u', v, p, (u, \PatVar(x)))}
  \\
  \precompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \precompPrime{v}{p}{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \precompPrime{v}{p}{e_i}
  \\
  \precompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \precompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\trecomp{\tau} = \E}$
%
\begin{align*}
  \trecomp{\arrowTyp{\tau_\ArrowArg}{u}{\tau_\ArrowResult}}
  &= \trecomp{\tau_\ArrowArg}
  \cup \trecomp{\tau_\ArrowResult} \\
  &\cup \trecompPrime{v}{\ArrowArg}{\tau_\ArrowArg}
  \cup \trecompPrime{v}{\ArrowResult}{\tau_\ArrowResult} \\
  &\quad\text{where } v = (u, \TypArrow)
  \\
  \trecomp{\numTyp{u}} &= \SetOf{}
  \\
  \trecomp{\hole} &= \SetOf{}
  \\
  \trecomp{\conflictHole{\tau_1, \cdots, \tau_n}}
  &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{u}} &= \SetOf{}
  \\
  \trecomp{\cycleVertex{u}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\trecompPrime{v}{p}{\tau} = \E}$
%
\begin{align*}
  \trecompPrime{v}{p}{\arrowTyp{\tau_\ArrowArg}{u}{\tau_\ArrowResult}}
  &= \SetOf{(u', v, p, (u, \TypArrow)))}
  \\
  \trecompPrime{v}{p}{\numTyp{u}}
  &= \SetOf{(u', v, p, (u, \TypNum)))}
  \\
  \trecompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \trecompPrime{v}{p}{\conflictHole{\tau_1, \cdots, \tau_n}}
  &= \bigcup_{i=1}^n \trecompPrime{v}{p}{\tau_i}
  \\
  \trecompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \trecompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} & \Create{k} \mid \Delete \mid \Restore{v} \\
    %  \mid \Drop{\e}
  \end{array}
\]

\begin{align*}
  \Wrap{k, q} &= \Delete; v=\Create{k}; \Restore{v, q} \\
  \Reposition{v, q} &= \Delete; \Restore{v, q} \\
\end{align*}
%
where $v$ is the destination vertex implied by the cursor, when it exists.
When no such vertex exists, $\Restore{v}$ is a no-op.