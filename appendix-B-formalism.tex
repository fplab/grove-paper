\section{Formalism}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

\figureTermSyntaxContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Term Constructors}

\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\sortOp : \K \to \SetOf{Exp, Pat, Typ}} \\
    \hline
    \sort{\Root}={} & Exp \\
    \sort{\ExpVar(x)}={} & Exp \\
    \sort{\ExpLam}={} & Exp \\
    \sort{\ExpApp}={} & Exp \\
    \sort{\ExpPlus}={} & Exp \\
    \sort{\ExpTimes}={} & Exp \\
    \sort{\ExpNum(n)}={} & Exp \\
    \sort{\PatVar(x)}={} & Pat \\
    \sort{\TypArrow}={} & Typ \\
    \sort{\TypNum}={} & Typ \\
  \end{array}
\]
%
\figureArityContent

\noindent $\boxed{\constructor{t} = k}$
%
\begin{align*}
  \constructor{e} &= \econstructor{e} \\
  \constructor{p} &= \pconstructor{p} \\
  \constructor{\tau} &= \tconstructor{\tau}
\end{align*}

\noindent $\boxed{\econstructor{e} = k}$
%
\begin{align*}
  \econstructor{\eVar{G}{x}} &= \ExpVar(x) \\
  \econstructor{\eFun{G}{q}{\tau}{e}} &= \ExpLam \\
  \econstructor{\eApp{G}{e_1}{e_2}} &= \ExpApp \\
  \econstructor{\eNum{G}{n}} &= \ExpNum(n) \\
  \econstructor{\ePlus{G}{e_1}{e_2}} &= \ExpPlus \\
  \econstructor{\eTimes{G}{e_1}{e_2}} &= \ExpTimes
\end{align*}

\noindent $\boxed{\pconstructor{q} = k}$
%
\begin{align*}
  \pconstructor{\pVar{G}{x}} &= \PatVar(x)
\end{align*}

\noindent $\boxed{\tconstructor{\tau} = k}$
%
\begin{align*}
  \tconstructor{\tArrow{G}{\tau_1}{\tau_2}} &= \TypArrow \\
  \tconstructor{\tNum{G}} &= \TypNum
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

Let $t$ denote a term and $\Set$ a set of terms.

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a function from edges to edge states,
  where $\E = \U \times \V \times \P \times \V$,
  unique IDs are drawn from some suitable set $\U$ equipped with a total ordering $\leq$,
  vertices are drawn from $\V$,
  positions are drawn from $\P$,
  and edge states are drawn from $\Sigma$.
\end{definition}

Let $G_t$, called the \emph{in-graph} of term $t$,
denote the outermost graph produced by $\ingraphOp$ in the construction of term $t$,
when such a graph exists.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\begin{definition}
  A graph $G$ is well sorted if all edges $\e$ such that $G(\e) \in \{\Plus, \Minus\}$ are well sorted.
\end{definition}

\begin{definition}
  An edge $(u, (u_1, k_1), p, (u_2, k_2))$ is well sorted if $(p, \sort{k_2}) \in \arity{k_1}$.
\end{definition}

\begin{definition}
  A grove $(\Set[NP], \Set[MP], \Set[U])$ is well sorted if all of the following hold:
  \begin{enumerate}
    \item The terms of $\Set[NP], \Set[MP],$ and $\Set[U]$ are well sorted.
      % $\Set[NP]$, $\Set[MP]$, and $\Set[U]$ contain only well sorted terms.
    \item For all $t \in \Set[NP]$,
      $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} = 0$.
      % The terms in $\Set[NP]$ correspond to edges with target vertices that have no parents.
    \item For all $t \in \Set[MP]$,
      $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} > 1$.
      % The terms in $\Set[MP]$ correspond to edges with target vertices that have multiple parents.
    \item For all $t \in \Set[U]$, all of the following hold:
      \begin{enumerate}
        \item $\SizeOf{\SetOf{\e{=}(u, v, p, v') \SuchThat{G_t(\e) = \Plus}}} = 1$.
        \item $v' = \min{\ancestors{v'}}$.
      \end{enumerate}
      % The terms in $\Set[U]$ correspond to edges with target vertices that are unicycle roots.
    \item For all $t \in \Set[MP] \cup \Set[U]$,
      $\SizeOf{\SetOf{\e{=}(\rootVertex, \Root, v) \SuchThat{G_t(\e) \in \SetOf{\Plus, \Minus}}}} = 0$.
      % Any terms corresponding to edges originating from $\rootVertex$ are in $\Set[NP]$.
  \end{enumerate}
\end{definition}

\begin{definition}
  A term $t$ is well sorted if one of the following holds:
  \begin{itemize}
    \item $t = \hole$.
      % An empty hole is trivially well sorted.
    \item $t = \conflictHole{t_1, \ldots, t_n}$ and all of the following hold:
      \begin{enumerate}
        \item $t_1, \ldots, t_n$ are well sorted.
          % The conflicting terms are well sorted ...
        \item $\sort{t_1} = \cdots = \sort{t_n}$.
          % ... and of the same sort.
      \end{enumerate}
    \item $t = \multiVertex{\e}$ and all of the following hold:
      \begin{enumerate}
        \item $\e$ is well sorted.
          % The corresponding edge is well sorted ...
        \item $\SizeOf{\SetOf{\e' \SuchThat{G_t(\e') = \Plus}}} > 1$.
          % ... and its target vertex has multiple parents.
          % (TODO: do we need this? be careful with wording)
      \end{enumerate}
    \item $t = \cycleVertex{(u, v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        \item $(u, v, p, v')$ is well sorted.
          % The corresponding edge is well sorted ...
        \item $v' = \min{\ancestors{v'}}$
          % ... and its target vertex is the root ...
        \item For all $\e{=}(u_{\e}, v_{\e}, p_{\e}, v_{\e}')$
          such that $v_{\e}' \in \ancestors{v'}$,
          $\SizeOf{\parents{v_{\e}'}} = 1$.
          % ... of a unicycle.
          % (TODO: do we need this? be careful with wording.
          % Could try to reconstruct the path from root (referenced) to ref (referencer).)
      \end{enumerate}
    \item Otherwise, $G_t$ exists and all of the following hold:
      \begin{enumerate}
        \item $G_t$ is well sorted.
          % all incoming edges are well sorted
        \item $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) \in \SetOf{\Plus, \Minus}}}} \geq 1$.
          % The in-graph of t is not empty.
        \item For all $\e{=}(v, p, v')$ such that $G_t(\e) \in \SetOf{\Plus, \Minus}$,
          $v' = (u, \constructor{t})$ fixed.
          % All term constructors match their corresponding target vertex constructors.
          % The ids of the target vertices of all incoming edges are the same.
      \end{enumerate}
  \end{itemize}
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

\begin{theorem}
  For any well sorted graph $G$,
  there exists a (well sorted) grove $\Grove$
  such that $\decomp{G} = \Grove$.
\end{theorem}

Proof: provide a witness that demonstrates the conclusion.

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\decomp{G} = \Grove$ then $\vertexes{G} = \vertexes{\Grove}$.
% \end{theorem}

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\recomp{\Grove} = G$ then $\vertexes{\Grove} = \vertexes{G}$.
% \end{theorem}

\figureDecompositionDefHelpersContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}\hspace*{\fill} \\

\noindent $\boxed{\decomp{G} = \Grove}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\decomp{\e} = t}$
%
\figureDecompositionDefDecompTerm

\noindent $\boxed{\edecomp{\e} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\pdecomp{\e} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\tdecomp{\e} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\edecompPrime{\e}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecompPrime{\e}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecompPrime{\e}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  If $G$ is a well sorted graph such that $\decomp{G} = \Grove$,
  then $\recomp{\Grove} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove} = G}$
%
\begin{align*}
  \recomp{(\Set[NP], \Set[MP], \Set[U])} &= \bigcup_{t \in \Set[NP] \cup \Set[MP] \cup \Set[U]} \recomp{t}
\end{align*}

\noindent $\boxed{\recomp{t} = G}$
%
\begin{align*}
  \recomp{e} &= \erecomp{e} \\
  \recomp{q} &= \precomp{q} \\
  \recomp{\tau} &= \trecomp{\tau}
\end{align*}

\noindent $\boxed{\erecomp{e} = G}$
%
\begin{align*}
  \erecomp{\eVar{G}{x}} &= G
  \\
  \erecomp{\eFun{G}{q}{\tau}{e}}
    &= G \cup \precomp{q} \cup \trecomp{\tau} \cup \erecomp{e}
  \\
  \erecomp{\eApp{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eNum{G}{n}} &= G
  \\
  \erecomp{\ePlus{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eTimes{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \erecomp{e_i}
  \\
  \erecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\hole} &= \SetOf{}
\end{align*}

\noindent $\boxed{\precomp{q} = G}$
%
\begin{align*}
  \precomp{\pVar{G}{x}} &= G
  \\
  \precomp{\conflictHole{q_1, \cdots, q_n}} &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\hole} &= \SetOf{}
\end{align*}

\noindent $\boxed{\trecomp{\tau} = G}$
%
\begin{align*}
  \trecomp{\tArrow{G}{\tau_1}{\tau_2}}
    &= G \cup \trecomp{\tau_1} \cup \trecomp{\tau_2}
  \\
  \trecomp{\tNum{G}} &= G
  \\
  \trecomp{\conflictHole{\tau_1, \cdots, \tau_n}} &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\hole} &= \SetOf{}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Cursors}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Terms}

\[
  \arraycolsep=0pt
  \begin{array}{lrlll}
    \Z{e} & {}\in ZExp & {}::={} &
      \cursor{e}
      \mid \eFun{G}{\Z{q}}{\tau}{e}
      \mid \eFun{G}{q}{\Z{\tau}}{e}
      \mid \eFun{G}{q}{\tau}{\Z{e}}
      \mid \eApp{G}{\Z{e}}{e}
      \mid \eApp{G}{e}{\Z{e}}
      \mid \ePlus{G}{\Z{e}}{e}
      \mid \ePlus{G}{e}{\Z{e}}
      \mid \eTimes{G}{\Z{e}}{e}
      \mid \eTimes{G}{e}{\Z{e}} \\
    &&&
      \mid \conflictHole{\Z{e}, e, \ldots, e}
    \\
    \Z{q} & {}\in ZPat & {}::={} &
      \cursor{q}
      \mid \conflictHole{\Z{q}, q, \ldots, q}
    \\
    \Z{\tau} & {}\in ZTyp & {}::={} &
      \cursor{\tau}
      \mid \tArrow{G}{\Z{\tau}}{\tau}
      \mid \tArrow{G}{\tau}{\Z{\tau}}
      \mid \conflictHole{\Z{\tau}, \tau, \ldots, \tau}
    \\
  \end{array}
\]

Let $\Z{t}$ denote a zippered term
and $\Z{\Set} = (\Z{t}, \Set)$ a set of terms paired with a zippered term.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Groves}

\begin{gather*}
  \arraycolsep=0pt
  \begin{array}{lll}
    \Z{\gamma} & {}::={} &
      (\Z{\Set}_{NP}, \Set[MP], \Set[U])
      \mid (\Set[NP], \Z{\Set}_{MP}, \Set[U])
      \mid (\Set[NP], \Set[MP], \Z{\Set}_U)
  \end{array}
\end{gather*}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Cursor Erasure}\hspace*{\fill} \\

\noindent $\boxed{\erase{\Z{\gamma}} = \gamma}$
%
\begin{align*}
  \erase{(\Z{\Set}_{NP}, \Set[MP], \Set[U])} &= (\erase{\Z{\Set}_{NP}}, \Set[MP], \Set[U]) \\
  \erase{(\Set[NP], \Z{\Set}_{MP}, \Set[U])} &= (\Set[NP], \erase{\Z{\Set}_{MP}}, \Set[U]) \\
  \erase{(\Set[NP], \Set[MP], \Z{\Set}_U)} &= (\Set[NP], \Set[MP], \erase{\Z{\Set}_U})
\end{align*}

\noindent $\boxed{\erase{\Z{\Set}} = \Set}$
%
\begin{align*}
  \erase{(\Z{t}, \Set)} &= \Set \cup \SetOf{t}
\end{align*}

\noindent $\boxed{\erase{\Z{e}} = e}$
%
\begin{align*}
  \erase{\cursor{e}} &= e \\
  \erase{\left(\eFun{G}{\Z{q}}{\tau}{e}\right)} &= \eFun{G}{\erase{\Z{q}}}{\tau}{e} \\
  \erase{\left(\eFun{G}{q}{\Z{\tau}}{e}\right)} &= \eFun{G}{q}{\erase{\Z{\tau}}}{e} \\
  \erase{\left(\eFun{G}{q}{\tau}{\Z{e}}\right)} &= \eFun{G}{q}{\tau}{\erase{\Z{e}}} \\
  \erase{\eApp{G}{\Z{e_1}}{e_2}} &= \eApp{G}{\erase{\Z{e_1}}}{e_2} \\
  \erase{\eApp{G}{e_1}{\Z{e_2}}} &= \eApp{G}{e_1}{\erase{\Z{e_2}}} \\
  \erase{\ePlus{G}{\Z{e_1}}{e_2}} &= \ePlus{G}{\erase{\Z{e_1}}}{e_2} \\
  \erase{\ePlus{G}{e_1}{\Z{e_2}}} &= \ePlus{G}{e_1}{\erase{\Z{e_2}}} \\
  \erase{\eTimes{G}{\Z{e_1}}{e_2}} &= \eTimes{G}{\erase{\Z{e_1}}}{e_2} \\
  \erase{\eTimes{G}{e_1}{\Z{e_2}}} &= \eTimes{G}{e_1}{\erase{\Z{e_2}}} \\
  \erase{\conflictHole{\Z{e}, e_1, \ldots, e_n}} &= \conflictHole{e, e_1, \ldots, e_n}
\end{align*}

\noindent $\boxed{\erase{\Z{q}} = q}$
%
\begin{align*}
  \erase{\cursor{q}} &= q \\
  \erase{\conflictHole{\Z{q}, q_1, \ldots, q_n}} &= \conflictHole{q, q_1, \ldots, q_n}
\end{align*}

\noindent $\boxed{\erase{\Z{\tau}} = \tau}$
%
\begin{align*}
  \erase{\cursor{\tau}} &= \tau \\
  \erase{\left(\tArrow{G}{\Z{\tau_1}}{\tau_2}\right)} &= \tArrow{G}{\erase{\Z{\tau_1}}}{\tau_2} \\
  \erase{\left(\tArrow{G}{\tau_1}{\Z{\tau_2}}\right)} &= \tArrow{G}{\tau_1}{\erase{\Z{\tau_2}}} \\
  \erase{\conflictHole{\Z{\tau}, \tau_1, \ldots, \tau_n}} &= \conflictHole{\tau, \tau_1, \ldots, \tau_n}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} &
      \Construct{k}
      \mid \Delete
      \mid \Reposition{v, p}
    \\
  \end{array}
\]

% \noindent $\boxed{\Z{e} \aArrow{\alpha} \Z{e}}}$
% %
% \begin{align*}
%   \
% \end{align*}

% Cases:
% \begin{itemize}
%   \item construct @ hole (create current edge)
%   \item construct @ conflict (create new edge into conflict ??)
%   \item construct @ non-hole (wrap current edge)
%   \item delete @ hole (no-op)
%   \item delete @ conflict (destroy all edges ??)
%   \item delete @ non-hole (destroy current edge)
%   \item reposition @ hole (no-op)
%   \item reposition @ conflict (???)
%   \item reposition @ non-hole (destroy current edge and create new edge with same destination vertex)
% \end{itemize}
