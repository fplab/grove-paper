\section{Formalism}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

\figureTermSyntaxContent

For conflict hole forms $\conflictHole[i \leq n]{t_i}$,
it must be the case that $n \geq 2$.
We identify conflict holes up to reordering.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Term Constructors}

\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\sortOp : \K \to \SetOf{Exp, Pat, Typ}} \\
    \hline
    \sort{\Root}={} & Exp \\
    \sort{\ExpVar(x)}={} & Exp \\
    \sort{\ExpLam}={} & Exp \\
    \sort{\ExpApp}={} & Exp \\
    \sort{\ExpPlus}={} & Exp \\
    \sort{\ExpTimes}={} & Exp \\
    \sort{\ExpNum(n)}={} & Exp \\
    \sort{\PatVar(x)}={} & Pat \\
    \sort{\TypArrow}={} & Typ \\
    \sort{\TypNum}={} & Typ \\
  \end{array}
\]
%
\figureArityContent
%
\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\defaultposOp : \K \to \P \times \P} \\
    \hline
    \defaultpos{\Root}={} & (\Root, \Root) \\
    \defaultpos{\ExpLam}={} & (\LamBody, \LamBody) \\
    \defaultpos{\ExpApp}={} & (\AppFun, \AppArg) \\
    \defaultpos{\ExpPlus}={} & (\PlusLeft, \PlusRight) \\
    \defaultpos{\ExpTimes}={} & (\TimesLeft, \TimesRight) \\
    \defaultpos{\TypArrow}={} & (\ArrowArg, \ArrowResult) \\
  \end{array}
\]
%
% We write $\defaultpos{k}$ undefined when there does not exist a $p$ such that $\defaultpos{k} = p$.

\noindent $\boxed{\constructor{t} = k}$
%
\begin{align*}
  \constructor{e} &= \econstructor{e} \\
  \constructor{p} &= \pconstructor{p} \\
  \constructor{\tau} &= \tconstructor{\tau}
\end{align*}

\noindent $\boxed{\econstructor{e} = k}$
%
\begin{align*}
  \econstructor{\eVar{G}{x}} &= \ExpVar(x) \\
  \econstructor{\eFun{G}{q}{\tau}{e}} &= \ExpLam \\
  \econstructor{\eApp{G}{e_1}{e_2}} &= \ExpApp \\
  \econstructor{\eNum{G}{n}} &= \ExpNum(n) \\
  \econstructor{\ePlus{G}{e_1}{e_2}} &= \ExpPlus \\
  \econstructor{\eTimes{G}{e_1}{e_2}} &= \ExpTimes
\end{align*}

\noindent $\boxed{\pconstructor{q} = k}$
%
\begin{align*}
  \pconstructor{\pVar{G}{x}} &= \PatVar(x)
\end{align*}

\noindent $\boxed{\tconstructor{\tau} = k}$
%
\begin{align*}
  \tconstructor{\tArrow{G}{\tau_1}{\tau_2}} &= \TypArrow \\
  \tconstructor{\tNum{G}} &= \TypNum
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

Let $t$ denote a term and $\Set$ a set of terms.

\begin{definition}
  A \emph{constructor} $k \in \K$ is the abstract representation of an atomic unit of structure, e.g., a form of AST node.
\end{definition}

\begin{definition}
  A \emph{unique identifier} $u \in \U$ is an object that can be distinguished from, and compared with, other unique identifiers.
\end{definition}

\begin{definition}
  A \emph{vertex} $v{=}(u, k) \in \V = \U \times \K$ is a concrete instance of a constructor, e.g., an AST node.
\end{definition}

\begin{definition}
  A \emph{position} $p \in \P$ is a constructor-relative location.
\end{definition}

\begin{definition}
  The \emph{default position} $(\pWrap, \pPost) \in \P \times \P$ of a constructor $k$
  that supports wrapping is a pair of positions relative to $k$:
  the position where wrapping occurs ($\pWrap$),
  and the position of the cursor after wrapping ($\pPost$).
\end{definition}

\begin{definition}
  A \emph{source} $(v, p) \in \V \times \P$ is a vertex paired with a position.
\end{definition}

\begin{definition}
  A \emph{valid source} is a source $(v{=}(u, k), p) \in \V \times \P$
  for which there exists a sort $S$ such that $(p, S) \in \arity{k}$.
\end{definition}

\begin{definition}
  An \emph{edge} $\e{=}(u, v, p, v^\prime) \in \E = \U \times \V \times P \times V$ in a graph $G$
  is a directed multi-edge in $G$ from \emph{source vertex} $v$ and position $p$ to \emph{target vertex} $v'$.
  We call $(v, p)$ the \emph{source of edge} $\e$.
\end{definition}

\begin{definition}
  An \emph{edge state} $s \in \Sigma{=}\SetOf{\Plus, \Minus}$
  is an object that a graph $G$ can map an edge $\e$ to in order to determine if $\e$
  is a \emph{live edge} $\left(G(\e) = \Plus\right)$
  or a \emph{deleted edge} $\left(G(\e) = \Minus\right)$.
\end{definition}

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a partial function from edges to edge states.
  We write $G(\e) = \bot$ to mean that $G(\e)$ is undefined.
  We write $\live{G}$ to denote the edges graph $G$ maps to $\Plus$.
  \[
    \live{G} = \SetOf{\e \in \E \SuchThat{G(e) = \Plus}}
  \]
\end{definition}

\begin{definition}
  The \emph{inedges} of a graph $G$ are the edges that $G$ is defined on.
  We write $\inedges{G}$ to denote the inedges of graph $G$.
  \[
    \inedges{G} = \SetOf{\e \in \E \SuchThat{G(\e) \in \Sigma}}
  \]
\end{definition}

\begin{definition}
  The \emph{ingraph of a vertex} $v \in V$ in a graph $G$
  is the subgraph of $G$ containing all edges targeting $v$.
  We write $G_v$ to denote the ingraph of vertex $v$ in graph $G$.
  \[
    G_v(\e) = s \iff G(\e) = s \land \e = (u, v', p, v) \land u \in \U \land v' \in \V \land p \in \P
  \]
\end{definition}

\begin{definition}
  The \emph{invertexes} of a graph $G$ are the target vertices of the inedges of $G$.
  We write $\invertexes{G}$ to denote the invertexes of graph $G$.
  \[
    \invertexes{G} = \SetOf{v' \in V \SuchThat{(u, v, p, v') \in \inedges{G} \land u \in \U \land v \in \V \land p \in \P}}
  \]
\end{definition}

\begin{definition}
  The \emph{inconstructors} of a graph $G$ are the constructors of its invertexes.
  We write $\inconstructors{G}$ to denote the inconstructors of graph $G$.
  \[
    \inconstructors{G} = \SetOf{k \in \K \SuchThat{(u, k) \in \invertexes{G} \land u \in \U}}
  \]
\end{definition}

\begin{definition}
  The \emph{vertex corresponding to a term} $t \in Term$,
  when $t$ is not an empty hole or a conflict hole,
  is the unique vertex $v$ for which there exists an edge $\e{=}(u, v', p, v)$ such that $\decomp{\e} = t$.
  We write $v_t$ to denote the vertex corresponding to term $t$.
\end{definition}

\begin{definition}
  The \emph{ingraph of a term} $t \in Term$
  is union of ingraphs of conflicting terms if $t$ is a conflict hole,
  the empty graph if $t$ is an empty hole,
  and the ingraph of the vertex corresponding to $t$ otherwise.
  \[
    G_t =
    \begin{cases}
      \bigcup_{t_i} G_{t_i} & t = \conflictHole[i \leq n]{t_i} \\
      \varnothing & t = \emptyHole{v}{p} \\
      G_{v_t} & \text{otherwise} \\
    \end{cases}
  \]
\end{definition}

\begin{definition}
  The \emph{sources} of a graph $G$ are the sources of the live edges of $G$.
  We write $\sources{G}$ to denote the sources of graph $G$.
  \[
    \sources{G} = \SetOf{(v, p) \in \V \times \P \SuchThat{(u, v, p, v') \in \live{G} \land u \in \U \land v' \in \V}}
  \]
\end{definition}

\begin{definition}
  The \emph{targets} of a graph $G$ are the targets of the live edges of $G$.
  We write $\targets{G}$ to denote the targets of graph $G$.
  \[
    \targets{G} = \SetOf{v' \in \V \SuchThat{(u, v, p, v') \in \live{G} \land u \in \U \land v \in \V \land p \in \P}}.
  \]
\end{definition}

\begin{definition}
  The \emph{children} of a source $(v, p) \in \V \times \P$ in a graph $G$
  are the live edges of $G$ with source $(v, p)$.
  We write $\children{v}{p}$ to denote the children of source $(v, p)$.
  \[
    \children{v}{p} = \SetOf{(u, v, p, v') \in \live{G} \SuchThat{u \in \U \land v' \in \V }}
  \]
\end{definition}

\begin{definition}
  The \emph{parents} of a vertex $v \in \V$ in a graph $G$ are the live edges of $G$ targeting $v$.
  We write $\parents{v}$ to denote the parents of vertex $v$.
  \[
    \parents{v} = \SetOf{v' \in \V \SuchThat{(u, v', p, v) \in \live{G} \land u \in \U \land p \in \P}}
  \]
\end{definition}

\begin{definition}
  The \emph{ancestors} of a vertex $v \in \V$ in a graph $G$ are defined recursively
  as the parents of $v$ and their ancestors in $G$.
  We write $\ancestors{v}$ to denote the ancestors of vertex $v$.
  \begin{align*}
    \ancestors{v} &= \mathopen{}\left( \lfp{\ancestorsPrimeOp} \right)\mathclose{}(v) \\
    \ancestorsPrime{v} &= \parents{v} \cup \ancestorsPrime{\parents{v}}
  \end{align*}
\end{definition}

\begin{definition}
  The \emph{least ancestor} of a vertex $v \in \V$ in a graph $V$ is the ancestor of $v$ with the least unique identifier according to the $\leq$ partial ordering.
  We write $\min{\ancestors{v}}$ to denote the least ancestor of vertex $v$.
  \[
    \min{\ancestors{v}} = \argmin{(u_i, k_i) \in \ancestors{v}}{u_i}
  \]
\end{definition}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\begin{definition}
  A \emph{well sorted graph} is a graph that is defined only on well sorted edges.
\end{definition}

\begin{definition}
  A \emph{well sorted edge} is an edge with a well sorted source $((u, k), p) \in \V \times \P$
  and a target $(u', k') \in \V$ of a sort consistent with the source.
  \[
    \left( p, \sort{k'} \right) \in \arity{k}
  \]
\end{definition}

\begin{definition}
  A \emph{well sorted source} is a source $(v{=}(u, k), p) \in \V \times \P$ such that $p$ is consistent with $v$,
  i.e., there exists a sort $S \in \SetOf{Exp, Pat, Var}$ such that $(p, S) \in \arity{k}$.
\end{definition}

\begin{definition}
  A \emph{well sorted grove} is a grove $(\Set[NP], \Set[MP], \Set[U])$ for which all of the following hold:
  \begin{enumerate}
    % All terms are well sorted.
    \item For each term $t \in \Set[NP] \cup \Set[MP] \cup \Set[U]$, we have $t$ is a well sorted term.
    % Any terms corresponding to edges originating from $\rootVertex$ are in $\Set[NP]$.
    \item For each term $t \in \Set[MP] \cup \Set[U]$, we have $(\rootVertex, \Root) \notin \sources{G_t}$.
    % The terms in $\Set[NP]$ correspond to edges with target vertices that have no parents.
    \item For each term $t \in \Set[NP]$, we have $\SizeOf{\live{G_t}} = 0$.
    % The terms in $\Set[MP]$ correspond to edges with target vertices that have multiple parents.
    \item For each term $t \in \Set[MP]$, we have $\SizeOf{\live{G_t}} > 1$.
    % The terms in $\Set[U]$ correspond to edges with target vertices that are unicycle roots.
    \item For each term $t \in \Set[U]$, we have $\live{G_t} = \SetOf{(u, v, p, v')} \land v' = \min{\ancestors{v'}}$.
  \end{enumerate}
\end{definition}

\begin{definition}
  A \emph{well sorted term} is a term $t$ such that one of the following holds:
  \begin{itemize}

    % An empty hole is well sorted if its source vertex can have children at the source position.
    \item $t = \emptyHole{v}{p}$ and $(v, p)$ is a well sorted source.

    \item $t = \conflictHole[i \leq n]{t_i}$ and all of the following hold:
      \begin{enumerate}
        % The terms are well sorted.
        \item For each term $t_i$, we have $t_i$ is a well sorted term.
        % The inedges of the terms have the same source.
        \item $\SizeOf{\sources{G_t}} = 1$.
      \end{enumerate}

    \item $t = \multiVertex{\e{=}(u, v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        % The corresponding edge is well sorted ...
        \item $\e$ is a well sorted edge.
        % ... and its target vertex has multiple parents.
        \item $\SizeOf{\parents{v'}} > 1$.
      \end{enumerate}

    \item $t = \cycleVertex{\e{=}(u, v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        % The corresponding edge is well sorted ...
        \item $\e$ is a well sorted edge.
        % ... and its target vertex is the root ...
        \item $v' = \min{\ancestors{v'}}$
        % ... of a unicycle.
        \item For each vertex $v'' \in \ancestors{v'}$, we have $\SizeOf{\parents{v''}} = 1$.
      \end{enumerate}

    \item Otherwise, $t$ is not a reference, a conflict hole, or an empty hole, and all of the following hold:
      \begin{enumerate}
        % All incoming edges are well sorted ...
        \item $G_t$ is a well sorted graph.
        % ... and target the vertex corresponding to t
        \item For each edge $(u, v, p, v') \in \inedges{G_t}$, we have $v' = v_t$.
        % The in-graph of t is not empty.
        \item $\SizeOf{\inedges{G_t}} \geq 1$.
        % The destination vertices of all incoming edges have the same id and constructor.
        % The constructor matches the term.
        \item There exists a unique identifier $u_0 \in \U$ such that,
          for each edge $(u, v, p, v') \in \inedges{G_t}$,
          we have $v' = v_t = (u_0, \constructor{t})$.
      \end{enumerate}
  \end{itemize}
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}

\begin{theorem}
  For any well sorted graph $G$
  there exists a well sorted grove $\Grove$
  such that \[\decomp{G} = \Grove.\]
\end{theorem}

% Proof: provide a witness that demonstrates the conclusion.

\noindent $\boxed{\decomp{G} = \Grove}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\decomp{\e} = t}$
%
\figureDecompositionDefDecompTerm

\noindent $\boxed{\edecomp{\e} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\edecompPrime{\e}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecomp{\e} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\pdecompPrime{\e}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecomp{\e} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\tdecompPrime{\e}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  For any well sorted graph $G$,
  if $\decomp{G} = \Grove$ then $\recomp{\Grove} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove} = G}$
%
\begin{align*}
  \recomp{(\Set[NP], \Set[MP], \Set[U])} &= \bigcup_{t \in \Set[NP] \cup \Set[MP] \cup \Set[U]} \recomp{t}
\end{align*}

\noindent $\boxed{\recomp{t} = G}$
%
\begin{align*}
  \recomp{e} &= \erecomp{e} \\
  \recomp{q} &= \precomp{q} \\
  \recomp{\tau} &= \trecomp{\tau}
\end{align*}

\noindent $\boxed{\erecomp{e} = G}$
%
\begin{align*}
  \erecomp{\eVar{G}{x}} &= G
  \\
  \erecomp{\eFun{G}{q}{\tau}{e}}
    &= G \cup \precomp{q} \cup \trecomp{\tau} \cup \erecomp{e}
  \\
  \erecomp{\eApp{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eNum{G}{n}} &= G
  \\
  \erecomp{\ePlus{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eTimes{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\conflictHole[i \leq n]{e_i}}
  &= \bigcup_{i=1}^n \erecomp{e_i}
  \\
  \erecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

\noindent $\boxed{\precomp{q} = G}$
%
\begin{align*}
  \precomp{\pVar{G}{x}} &= G
  \\
  \precomp{\conflictHole[i \leq n]{q_i}} &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

\noindent $\boxed{\trecomp{\tau} = G}$
%
\begin{align*}
  \trecomp{\tArrow{G}{\tau_1}{\tau_2}}
    &= G \cup \trecomp{\tau_1} \cup \trecomp{\tau_2}
  \\
  \trecomp{\tNum{G}} &= G
  \\
  \trecomp{\conflictHole[i \leq n]{\tau_i}} &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Cursors}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Terms}

\[
  \arraycolsep=0pt
  \begin{array}{lcllll}
    \Z{t} & {}\in{} & ZTerm & {}::={} &
      \Z{e}
      \mid \Z{q}
      \mid \Z{\tau}
    \\
    \Z{e} & {}\in{} & ZExp & {}::={} &
      \cursor{e}
      \mid \eFun{G}{\Z{q}}{\tau}{e}
      \mid \eFun{G}{q}{\Z{\tau}}{e}
      \mid \eFun{G}{q}{\tau}{\Z{e}}
      \mid \eApp{G}{\Z{e}}{e}
      \mid \eApp{G}{e}{\Z{e}}
      \mid \ePlus{G}{\Z{e}}{e}
      \mid \ePlus{G}{e}{\Z{e}}
      \mid \eTimes{G}{\Z{e}}{e}
      \\
    &&&&
      \mid \eTimes{G}{e}{\Z{e}}
      \mid \conflictHole{\Z{e}, \SetOf{e_i}_{i \leq n}}
    \\
    \Z{q} & {}\in{} & ZPat & {}::={} &
      \cursor{q}
      \mid \conflictHole{\Z{q}, \SetOf{q_i}_{i \leq n}}
    \\
    \Z{\tau} & {}\in{} & ZTyp & {}::={} &
      \cursor{\tau}
      \mid \tArrow{G}{\Z{\tau}}{\tau}
      \mid \tArrow{G}{\tau}{\Z{\tau}}
      \mid \conflictHole{\Z{\tau}, \SetOf{\tau_i}_{i \leq n}}
    \\
  \end{array}
\]

Let $\Z{\Set} = (\Set, \Z{t})$ denote a set of terms paired with a zippered term.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Groves}

\begin{gather*}
  \arraycolsep=0pt
  \begin{array}{lll}
    \Z{\gamma} & {}::={} &
      (\Z{\Set}_{NP}, \Set[MP], \Set[U])
      \mid (\Set[NP], \Z{\Set}_{MP}, \Set[U])
      \mid (\Set[NP], \Set[MP], \Z{\Set}_U)
  \end{array}
\end{gather*}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Cursor Erasure}\hspace*{\fill} \\

\noindent $\boxed{\erase{\Z{\gamma}} = \gamma}$
%
\begin{align*}
  \erase{(\Z{\Set}_{NP}, \Set[MP], \Set[U])} &= (\erase{\Z{\Set}_{NP}}, \Set[MP], \Set[U]) \\
  \erase{(\Set[NP], \Z{\Set}_{MP}, \Set[U])} &= (\Set[NP], \erase{\Z{\Set}_{MP}}, \Set[U]) \\
  \erase{(\Set[NP], \Set[MP], \Z{\Set}_U)} &= (\Set[NP], \Set[MP], \erase{\Z{\Set}_U})
\end{align*}

\noindent $\boxed{\erase{\Z{\Set}} = \Set}$
%
\begin{align*}
  \erase{(\Set, \Z{t})} &= \Set \cup \SetOf{t}
\end{align*}

\noindent $\boxed{\erase{\Z{e}} = e}$
%
\begin{align*}
  \erase{\cursor{e}} &= e \\
  \erase{\left(\eFun{G}{\Z{q}}{\tau}{e}\right)} &= \eFun{G}{\erase{\Z{q}}}{\tau}{e} \\
  \erase{\left(\eFun{G}{q}{\Z{\tau}}{e}\right)} &= \eFun{G}{q}{\erase{\Z{\tau}}}{e} \\
  \erase{\left(\eFun{G}{q}{\tau}{\Z{e}}\right)} &= \eFun{G}{q}{\tau}{\erase{\Z{e}}} \\
  \erase{\eApp{G}{\Z{e}_1}{e_2}} &= \eApp{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eApp{G}{e_1}{\Z{e}_2}} &= \eApp{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\ePlus{G}{\Z{e}_1}{e_2}} &= \ePlus{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\ePlus{G}{e_1}{\Z{e}_2}} &= \ePlus{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\eTimes{G}{\Z{e}_1}{e_2}} &= \eTimes{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eTimes{G}{e_1}{\Z{e}_2}} &= \eTimes{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\conflictHole{\Z{e}, \SetOf{e_i}_{i \leq n}}} &= \conflictHole{\erase{\Z{e}}, \SetOf{e_i}_{i \leq n}}
\end{align*}

\noindent $\boxed{\erase{\Z{q}} = q}$
%
\begin{align*}
  \erase{\cursor{q}} &= q \\
  \erase{\conflictHole{\Z{q}, \SetOf{q_i}_{i \leq n}}} &= \conflictHole{\erase{\Z{q}}, \SetOf{q_i}_{i \leq n}}
\end{align*}

\noindent $\boxed{\erase{\Z{\tau}} = \tau}$
%
\begin{align*}
  \erase{\cursor{\tau}} &= \tau \\
  \erase{\left(\tArrow{G}{\Z{\tau}_1}{\tau_2}\right)} &= \tArrow{G}{\erase{\Z{\tau}_1}}{\tau_2} \\
  \erase{\left(\tArrow{G}{\tau_1}{\Z{\tau}_2}\right)} &= \tArrow{G}{\tau_1}{\erase{\Z{\tau}_2}} \\
  \erase{\conflictHole{\Z{\tau}, \SetOf{\tau_i}_{i \leq n}}} &= \conflictHole{\erase{\Z{\tau}}, \SetOf{\tau_i}_{i \leq n}}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} &
      \Construct{k}
      \mid \Delete
      \mid \Reposition{v}{p}
    \\
    c & {}::={} &
      \CVertex{v}
      \mid \CEdge{\e}
      \mid \CSource{v}{p}
    \\
  \end{array}
\]

\begin{theorem}[Sensibility]
  For any zippered grove $\Z{\Grove}$
  such that $\erase{\Z{\Grove}}$ is well sorted
    and $\recomp{\erase{\Z{\Grove}}} = G$,
  and any user action $\alpha$,
  if
  \[
    \applyAction{\Z{\Grove}}{\alpha}{\Q{a}}{c},
  \]
  then $G \action{\Q{a}} G'$ and $G'$ is well sorted.
\end{theorem}

\noindent $\boxed{\applyAction{ \Z{\Grove} }{ \alpha }{ \Q{a} }{ c }}$
%
\begin{mathpar}
  \inferrule{
    \applyAction{ \Z{\Set}_{NP} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\Z{\Set}_{NP}, \Set[MP], \Set[U]) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\Set}_{MP} }{ \alpha }{ \Q{a} }{ v' }{ p' }
  }{
    \applyAction{ (\Set[NP], \Z{\Set}_{MP}, \Set[U]) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\Set}_U }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\Set[NP], \Set[MP], \Z{\Set}_U) }{ \alpha }{ \Q{a} }{ c }
  }
\end{mathpar}

\noindent $\boxed{\applyAction{ \Z{\Set} }{ \alpha }{ \Q{a} }{ c }}$
%
\begin{mathpar}
  \inferrule{
    \applyAction{ \Z{t} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\Set, \Z{t}) }{ \alpha }{ \Q{a} }{ c }
  }
\end{mathpar}
\noindent $\boxed{\applyAction{ \Z{t} }{ \alpha }{ \Q{a} }{ c }}$
%
\begin{mathpar}
  \inferrule{
    \applyAction{ \Z{q} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eFun{G}{\Z{q}}{\tau}{e}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\tau} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eFun{G}{q}{\Z{\tau}}{e}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eFun{G}{q}{\tau}{\Z{e}}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ \eApp{G}{\Z{e}_1}{e_2} }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ \eApp{G}{e_1}{\Z{e}_2} }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\ePlus{G}{\Z{e}_1}{e_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\ePlus{G}{e_1}{\Z{e}_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eTimes{G}{\Z{e}_1}{e_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eTimes{G}{e_1}{\Z{e}_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\tau}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\tArrow{G}{\Z{\tau}_1}{\tau_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\tau}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\tArrow{G}{\tau_1}{\Z{\tau}_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{t} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ \conflictHole{\Z{t}, \SetOf{t_i}_{i \leq n}} }{ \alpha }{
      \Q{a}
    }{ c }
  }
\end{mathpar}

Let $\fresh{u}$ denote a fresh unique identifier.

\begin{mathpar}
  \inferrule[Construct]{
    % If:
    % 
    % 1. The source position (p_s) and new constructor (k) sort are valid w.r.t. the parent constructor (k_s)
    (p_s, \sort{k}) \in \arity{k_s} \\
    \defaultpos{k} \text{ undefined} \\
    % 
    % 2. The term under the cursor is a hole
    % 
    % And we let:
    % 
    % v_k = a new vertex with the new constructor
    v_k = (\fresh{u}_k, k)
  }{
    % Then the user action Construct(k) produces the following set of graph actions:
    \applyAction{ \cursor{\emptyHole{v_s{=}(u_s, k_s)}{p_s}} }{ \Construct{k} }{
      % 
      % attach the new vertex to the cursor source
      \SetOf{\graphAction{\Plus}{(\fresh{u}, v_s, p_s, v_k)}}
    }{ \CVertex{v_k} }
  }

  \inferrule[ConstructWrap]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    %   (==> t is a basic term or reference, or, equivalently, t is not a conflict or a hole)
    \sources{G_t} = \SetOf{(v_{s_i}, p_{s_i})}_{i \leq n} \\
    % 
    % 2. The new constructor (k) has default positions (p_wrap, p_post)
    \defaultpos{k} = (\pWrap, \pPost) \\
    % 
    % 3. The new (default) position and old sort are in the arity of the new constructor
    (\pWrap, \sort{k}) \in \arity{k} \\\\
    % 
    % And we let:
    % 
    % v_k = a new vertex with the new constructor
    v_k = (\fresh{u}_k, k) \\
    % 
    % e_i = a new edge from source i to the new vertex
    \SetOf{\e_{v_i}}_{v_i \in \Q{v}_{G_t}} = \SetOf{(\fresh{u}_i, v_{s_i}, p_{s_i}, v_k)}_{i \leq n} \\
    % 
    % e' = a new edge from the new vertex and default position to the old invertex(es)
    \SetOf{\e_i'} = \SetOf{(\fresh{u}, v_k, \pWrap, v_i)}_{v_i \in \Q{v}_{G_t}}
  }{
    % Then the user action Construct(k) produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Construct{k} }{
      % 
      % delete the old ingraph
      \SetOf{\graphAction{\Minus}{\e}}_{\e \in \live{G_t}} \cup
      % 
      % construct an equivalent ingraph on the new vertex
      \SetOf{\graphAction{\Plus}{\e_{v_i}}}_{v_i \in \Q{v}_{G_t}} \cup
      % 
      % reattach the old invertex to the default position of the new vertex
      \SetOf{\graphAction{\Plus}{\e_i'}}_{i \leq n}
    }{ \CSource{v_k}{\pPost} }
  }

  \inferrule[Delete]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    \live{G_t} = \SetOf{\e_i}_{i \leq n} \\
    % 
    % 2. There is a unique source ==> not a deleted root or a multiparent root
    \sources{G_t} = \SetOf{(v, p)}
  }{
    % Then the user action Delete produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Delete }{
      % 
      % delete the ingraph
      \SetOf{\graphAction{\Minus}{\e_i}}_{i \leq n}
    }{ \CSource{v}{p} }
  }

  \inferrule[DeleteMultiparent]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    \live{G_t} = \SetOf{\e_i}_{i \leq n} \\
    \SizeOf{\sources{G_t}} > 1
  }{
    % Then the user action Delete produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Delete }{
      % 
      % delete the ingraph
      \SetOf{\graphAction{\Minus}{\e_i}}_{i \leq n}
    }{ \CVertex{v_{G_t}} }
  }

  \inferrule[Reposition]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    \live{G_t} = \SetOf{\e_i}_{i \leq n} \\
    % 
    % 2. The new source has no children
    \SizeOf{\children{v}{p}} = 0 \\
    % 
    % 3. The inconstructor (k_Gt) and new source position are in the arity of the new source constructor (k)
    \SetOf{(p, \sort{k_i}) \in \arity{k}}_{k_i \in \Q{k}_{G_t}}
  }{
    % Then the user action Reposition(v=(u,k), p) produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Reposition{v{=}(u, k)}{p} }{
      % 
      % delete the old ingraph
      \SetOf{\graphAction{\Minus}{\e_i}}_{i \leq n} \cup
      % 
      % attach the old invertex(es) to the new parent
      \SetOf{\graphAction{\Plus}{(\fresh{u}, v, p, v_i)}}_{v_i \in \Q{v}_{G_t}}
    }{ \CSource{v}{p} }
  }
\end{mathpar}

% TODO: Lemma: if t is well sorted, then G_t is well sorted
% TODO: clean up language around ingraph derivatives, and model formally
% TODO: point out in the narrative that leaving out |children|=0 on Reposition allows locally produced conflicts
% TODO: define valid and almost-valid cursors
