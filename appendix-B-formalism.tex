\section{Formalism}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

\figureTermSyntaxContent

For conflict hole forms $\conflictHole[i \leq n]{t_i}{v}{p}$,
it must be the case that $n \geq 2$.
We identify conflict holes up to reordering.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Term Constructors}

\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\sortOp : \K \to \SetOf{Exp, Pat, Typ}} \\
    \hline
    \sort{\Root}={} & Exp \\
    \sort{\ExpVar(x)}={} & Exp \\
    \sort{\ExpLam}={} & Exp \\
    \sort{\ExpApp}={} & Exp \\
    \sort{\ExpPlus}={} & Exp \\
    \sort{\ExpTimes}={} & Exp \\
    \sort{\ExpNum(n)}={} & Exp \\
    \sort{\PatVar(x)}={} & Pat \\
    \sort{\TypArrow}={} & Typ \\
    \sort{\TypNum}={} & Typ \\
  \end{array}
\]
%
\figureArityContent
%
\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\defaultposOp : \K \to \P \times \P} \\
    \hline
    \defaultpos{\Root}={} & (\Root, \Root) \\
    \defaultpos{\ExpLam}={} & (\LamBody, \LamBody) \\
    \defaultpos{\ExpApp}={} & (\AppFun, \AppArg) \\
    \defaultpos{\ExpPlus}={} & (\PlusLeft, \PlusRight) \\
    \defaultpos{\ExpTimes}={} & (\TimesLeft, \TimesRight) \\
    \defaultpos{\TypArrow}={} & (\ArrowArg, \ArrowResult) \\
  \end{array}
\]
%
% We write $\defaultpos{k}$ undefined when there does not exist a $p$ such that $\defaultpos{k} = p$.

\noindent $\boxed{\constructor{t} = k}$
%
\begin{align*}
  \constructor{e} &= \econstructor{e} \\
  \constructor{p} &= \pconstructor{p} \\
  \constructor{\tau} &= \tconstructor{\tau}
\end{align*}

\noindent $\boxed{\econstructor{e} = k}$
%
\begin{align*}
  \econstructor{\eVar{G}{x}} &= \ExpVar(x) \\
  \econstructor{\eFun{G}{q}{\tau}{e}} &= \ExpLam \\
  \econstructor{\eApp{G}{e_1}{e_2}} &= \ExpApp \\
  \econstructor{\eNum{G}{n}} &= \ExpNum(n) \\
  \econstructor{\ePlus{G}{e_1}{e_2}} &= \ExpPlus \\
  \econstructor{\eTimes{G}{e_1}{e_2}} &= \ExpTimes
\end{align*}

\noindent $\boxed{\pconstructor{q} = k}$
%
\begin{align*}
  \pconstructor{\pVar{G}{x}} &= \PatVar(x)
\end{align*}

\noindent $\boxed{\tconstructor{\tau} = k}$
%
\begin{align*}
  \tconstructor{\tArrow{G}{\tau_1}{\tau_2}} &= \TypArrow \\
  \tconstructor{\tNum{G}} &= \TypNum
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

Let $t$ denote a term and $\Set$ a set of terms.

\begin{definition}
  A \emph{constructor} $k \in \K$ is a form of AST node.
\end{definition}

\begin{definition}
  A \emph{unique identifier} $u \in \U$ is an object that can be distinguished from other unique identifiers.
\end{definition}

\begin{definition}
  A \emph{vertex} $v{=}(u, k) \in \V$ is a uniquely identifiable instance of a constructor.
\end{definition}

\begin{definition}
  A \emph{position} $p \in \P$ is a constructor-specific location from which edges may originate.
\end{definition}

\begin{definition}
  A \emph{source} $(v{=}(u, k), p) \in \V \times \P$ is a vertex paired with a position.
  A \emph{valid source} is a source for which there exists a sort $S$ such that $(p, S) \in \arity{k}$.
\end{definition}

\begin{definition}
  An \emph{edge} $\e{=}(u, v, p, v^\prime) \in \E$ is a uniquely identifiable instance of a directed link from one vertex to another.
  We call $(v, p)$ the \emph{source} of edge $\e$.
\end{definition}

\begin{definition}
  An \emph{edge state} $s \in \Sigma{=}\SetOf{\Plus, \Minus}$
  can be associated with an edge to determine if the edge
  is \emph{live} $\left(\Plus\right)$
  or \emph{deleted} $\left(\Minus\right)$
  in a graph.
\end{definition}

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a partial function from edges to edge states.
  We write $G(\e) = \bot$ to mean that $G(\e)$ is undefined.
\end{definition}

\begin{definition}
  The \emph{ingraph of a vertex} is the subgraph of all edges targeting the vertex.
  The target vertex is called the \emph{invertex} of the ingraph.
  The constructor of the invertex is called the \emph{inconstructor} of the ingraph.
  The \emph{ingraph of a term} is the ingraph of its corresponding vertex if the term is not a conflict,
  and the union of ingraphs of conflicting terms otherwise.
  The \emph{invertex of a term} is the invertex(es) of its ingraph.
  The \emph{inconstructor of a term} is the inconstructor(s) of its ingraph.
  For a term $t$, we denote the
    ingraph, invertex, invertex set, inconstructor, and inconstructor set
  as
    $G_t, v_{G_t}, \Q{v}_{G_t,} k_{G_t}, \Q{k}_{G_t}$,
  respectively.
\end{definition}

\begin{definition}
  The \emph{inedges of a graph} are the edges it maps to $\Plus$ or $\Minus$.
  The \emph{inedges of a term} are the inedges of its ingraph.
\end{definition}

\begin{definition}
  The \emph{sources of a graph} are the sources of its inedges.
  The \emph{sources of a term} are the sources of its ingraph.
\end{definition}

\begin{definition}
  The \emph{children} of a source are the live edges originating from it.
\end{definition}

\begin{definition}
  The \emph{parents of a vertex} are the live edges targeting it.
  The \emph{parents of a term} are the parents of its corresponding vertex.
\end{definition}

\begin{definition}
  The \emph{ancestors of a vertex} are defined recursively as the parents of the vertex and their ancestors.
  The \emph{ancestors of a term} are the ancestors of its corresponding vertex.
\end{definition}

Let $\fresh{u}$ denote a fresh unique identifier.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\begin{definition}
  A \emph{well sorted graph} is a graph defined on only well sorted edges.
\end{definition}

\begin{definition}
  A \emph{well sorted edge} is an edge $\e{=}(u_0, (u, k), p, (u', k'))$
  with a well sorted source that can have children of the sort of its target,
  i.e., $(p, \sort{k'}) \in \arity{k}$.
\end{definition}

\begin{definition}
  A \emph{well sorted source} is a source $(v{=}(u, k), p)$
  with a vertex that can have children at its position,
  i.e., there exists a sort $S \in \SetOf{Exp, Pat, Var}$ such that $(p, S) \in \arity{k}$.
\end{definition}

\begin{definition}
  A \emph{well sorted grove} is a grove $(\Set[NP], \Set[MP], \Set[U])$ such that all of the following hold:
  \begin{enumerate}
    \item $\Set[NP], \Set[MP],$ and $\Set[U]$ contain only well sorted terms.
    % The terms in $\Set[NP]$ correspond to edges with target vertices that have no parents.
    \item For each $t \in \Set[NP]$, $\SizeOf{\live{G_t}} = 0$.
    % The terms in $\Set[MP]$ correspond to edges with target vertices that have multiple parents.
    \item For each $t \in \Set[MP]$, $\SizeOf{\live{G_t}} > 1$.
    % The terms in $\Set[U]$ correspond to edges with target vertices that are unicycle roots.
    \item For each $t \in \Set[U]$, $\live{G_t} = \SetOf{(u, v, p, v')} \land v' = \min{\ancestors{v'}}$.
    % Any terms corresponding to edges originating from $\rootVertex$ are in $\Set[NP]$.
    \item For each $t \in \Set[MP] \cup \Set[U]$, $(\rootVertex, \Root) \notin \sources{G_t}$.
  \end{enumerate}
\end{definition}

\begin{definition}
  A \emph{well sorted term} is a term $t$ such that one of the following holds:
  \begin{itemize}

    % An empty hole is well sorted if its source vertex can have children at the source position.
    \item $t = \emptyHole{v}{p}$ and $(v, p)$ is a well sorted source.

    \item $t = \conflictHole[i \leq n]{t_i}{v}{p}$ and all of the following hold:
      \begin{enumerate}
        % The terms are well sorted.
        \item Each $t_i$ is a well sorted term.
        % The inedges of the terms have the same source.
        \item $\sources{G_t} = \SetOf{(v, p)}$.
      \end{enumerate}

    \item $t = \multiVertex{\e{=}(u, v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        % The corresponding edge is well sorted ...
        \item $\e$ is a well sorted edge.
        % ... and its target vertex has multiple parents.
        \item $\SizeOf{\parents{v'}} > 1$.
      \end{enumerate}

    \item $t = \cycleVertex{\e{=}(u, v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        % The corresponding edge is well sorted ...
        \item $\e$ is a well sorted edge.
        % ... and its target vertex is the root ...
        \item $v' = \min{\ancestors{v'}}$
        % ... of a unicycle.
        \item For each $v'' \in \ancestors{v'}$, $\SizeOf{\parents{v''}} = 1$.
      \end{enumerate}

    \item Otherwise, $t$ is an AST node and all of the following hold:
      \begin{enumerate}
        % All incoming edges are well sorted ...
        \item $G_t$ is a well sorted graph.
        % ... all incoming edges have the same destination vertex (and we call it the in-vertex of t).
        \item For each $\e{=}(u, v, p, v') \in \inedges{G_t}$, we have $v' = v_{G_t}$.
        % The in-graph of t is not empty.
        \item $\SizeOf{\inedges{G_t}} \geq 1$.
        % The destination vertices of all incoming edges have the same id and constructor.
        % The constructor matches the term.
        \item There exists $u_0 \in \U$ such that,
          for all $\e{=}(u, v, p, v') \in \inedges{G_t}$,
          we have $v' = v_{G_t} = (u_0, \constructor{t})$.
      \end{enumerate}
  \end{itemize}
\end{definition}

% TODO: update confliceHole usage
% TODO: rename multiVertex / cycleVertex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

\figureDecompositionDefHelpersContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}

\begin{theorem}
  For any well sorted graph $G$
  there exists a well sorted grove $\Grove$
  such that \[\decomp{G} = \Grove.\]
\end{theorem}

% Proof: provide a witness that demonstrates the conclusion.

\noindent $\boxed{\decomp{G} = \Grove}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\decomp{\e} = t}$
%
\figureDecompositionDefDecompTerm

\noindent $\boxed{\edecomp{\e} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\edecompPrime{\e}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecomp{\e} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\pdecompPrime{\e}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecomp{\e} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\tdecompPrime{\e}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  For any well sorted graph $G$,
  if $\decomp{G} = \Grove$ then $\recomp{\Grove} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove} = G}$
%
\begin{align*}
  \recomp{(\Set[NP], \Set[MP], \Set[U])} &= \bigcup_{t \in \Set[NP] \cup \Set[MP] \cup \Set[U]} \recomp{t}
\end{align*}

\noindent $\boxed{\recomp{t} = G}$
%
\begin{align*}
  \recomp{e} &= \erecomp{e} \\
  \recomp{q} &= \precomp{q} \\
  \recomp{\tau} &= \trecomp{\tau}
\end{align*}

\noindent $\boxed{\erecomp{e} = G}$
%
\begin{align*}
  \erecomp{\eVar{G}{x}} &= G
  \\
  \erecomp{\eFun{G}{q}{\tau}{e}}
    &= G \cup \precomp{q} \cup \trecomp{\tau} \cup \erecomp{e}
  \\
  \erecomp{\eApp{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eNum{G}{n}} &= G
  \\
  \erecomp{\ePlus{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eTimes{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\conflictHole[i \leq n]{e_i}{v}{p}}
  &= \bigcup_{i=1}^n \erecomp{e_i}
  \\
  \erecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

\noindent $\boxed{\precomp{q} = G}$
%
\begin{align*}
  \precomp{\pVar{G}{x}} &= G
  \\
  \precomp{\conflictHole[i \leq n]{q_i}{v}{p}} &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

\noindent $\boxed{\trecomp{\tau} = G}$
%
\begin{align*}
  \trecomp{\tArrow{G}{\tau_1}{\tau_2}}
    &= G \cup \trecomp{\tau_1} \cup \trecomp{\tau_2}
  \\
  \trecomp{\tNum{G}} &= G
  \\
  \trecomp{\conflictHole[i \leq n]{\tau_i}{v}{p}} &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Cursors}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Terms}

\[
  \arraycolsep=0pt
  \begin{array}{lcllll}
    \Z{t} & {}\in{} & ZTerm & {}::={} &
      \Z{e}
      \mid \Z{q}
      \mid \Z{\tau}
    \\
    \Z{e} & {}\in{} & ZExp & {}::={} &
      \cursor{e}
      \mid \eFun{G}{\Z{q}}{\tau}{e}
      \mid \eFun{G}{q}{\Z{\tau}}{e}
      \mid \eFun{G}{q}{\tau}{\Z{e}}
      \mid \eApp{G}{\Z{e}}{e}
      \mid \eApp{G}{e}{\Z{e}}
      \mid \ePlus{G}{\Z{e}}{e}
      \mid \ePlus{G}{e}{\Z{e}}
      \mid \eTimes{G}{\Z{e}}{e}
      \\
    &&&&
      \mid \eTimes{G}{e}{\Z{e}}
      \mid \conflictHole{\Z{e}, \SetOf{e_i}_{i \leq n}}{v}{p}
    \\
    \Z{q} & {}\in{} & ZPat & {}::={} &
      \cursor{q}
      \mid \conflictHole{\Z{q}, \SetOf{q_i}_{i \leq n}}{v}{p}
    \\
    \Z{\tau} & {}\in{} & ZTyp & {}::={} &
      \cursor{\tau}
      \mid \tArrow{G}{\Z{\tau}}{\tau}
      \mid \tArrow{G}{\tau}{\Z{\tau}}
      \mid \conflictHole{\Z{\tau}, \SetOf{\tau_i}_{i \leq n}}{v}{p}
    \\
  \end{array}
\]

Let $\Z{\Set} = (\Set, \Z{t})$ denote a set of terms paired with a zippered term.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Groves}

\begin{gather*}
  \arraycolsep=0pt
  \begin{array}{lll}
    \Z{\gamma} & {}::={} &
      (\Z{\Set}_{NP}, \Set[MP], \Set[U])
      \mid (\Set[NP], \Z{\Set}_{MP}, \Set[U])
      \mid (\Set[NP], \Set[MP], \Z{\Set}_U)
  \end{array}
\end{gather*}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Cursor Erasure}\hspace*{\fill} \\

\noindent $\boxed{\erase{\Z{\gamma}} = \gamma}$
%
\begin{align*}
  \erase{(\Z{\Set}_{NP}, \Set[MP], \Set[U])} &= (\erase{\Z{\Set}_{NP}}, \Set[MP], \Set[U]) \\
  \erase{(\Set[NP], \Z{\Set}_{MP}, \Set[U])} &= (\Set[NP], \erase{\Z{\Set}_{MP}}, \Set[U]) \\
  \erase{(\Set[NP], \Set[MP], \Z{\Set}_U)} &= (\Set[NP], \Set[MP], \erase{\Z{\Set}_U})
\end{align*}

\noindent $\boxed{\erase{\Z{\Set}} = \Set}$
%
\begin{align*}
  \erase{(\Set, \Z{t})} &= \Set \cup \SetOf{t}
\end{align*}

\noindent $\boxed{\erase{\Z{e}} = e}$
%
\begin{align*}
  \erase{\cursor{e}} &= e \\
  \erase{\left(\eFun{G}{\Z{q}}{\tau}{e}\right)} &= \eFun{G}{\erase{\Z{q}}}{\tau}{e} \\
  \erase{\left(\eFun{G}{q}{\Z{\tau}}{e}\right)} &= \eFun{G}{q}{\erase{\Z{\tau}}}{e} \\
  \erase{\left(\eFun{G}{q}{\tau}{\Z{e}}\right)} &= \eFun{G}{q}{\tau}{\erase{\Z{e}}} \\
  \erase{\eApp{G}{\Z{e}_1}{e_2}} &= \eApp{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eApp{G}{e_1}{\Z{e}_2}} &= \eApp{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\ePlus{G}{\Z{e}_1}{e_2}} &= \ePlus{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\ePlus{G}{e_1}{\Z{e}_2}} &= \ePlus{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\eTimes{G}{\Z{e}_1}{e_2}} &= \eTimes{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eTimes{G}{e_1}{\Z{e}_2}} &= \eTimes{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\conflictHole{\Z{e}, \SetOf{e_i}_{i \leq n}}{v}{p}} &= \conflictHole{\erase{\Z{e}}, \SetOf{e_i}_{i \leq n}}{v}{p}
\end{align*}

\noindent $\boxed{\erase{\Z{q}} = q}$
%
\begin{align*}
  \erase{\cursor{q}} &= q \\
  \erase{\conflictHole{\Z{q}, \SetOf{q_i}_{i \leq n}}{v}{p}} &= \conflictHole{\erase{\Z{q}}, \SetOf{q_i}_{i \leq n}}{v}{p}
\end{align*}

\noindent $\boxed{\erase{\Z{\tau}} = \tau}$
%
\begin{align*}
  \erase{\cursor{\tau}} &= \tau \\
  \erase{\left(\tArrow{G}{\Z{\tau}_1}{\tau_2}\right)} &= \tArrow{G}{\erase{\Z{\tau}_1}}{\tau_2} \\
  \erase{\left(\tArrow{G}{\tau_1}{\Z{\tau}_2}\right)} &= \tArrow{G}{\tau_1}{\erase{\Z{\tau}_2}} \\
  \erase{\conflictHole{\Z{\tau}, \SetOf{\tau_i}_{i \leq n}}{v}{p}} &= \conflictHole{\erase{\Z{\tau}}, \SetOf{\tau_i}_{i \leq n}}{v}{p}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} &
      \Construct{k}
      \mid \Delete
      \mid \Reposition{v}{p}
    \\
    c & {}::={} &
      \CVertex{v}
      \mid \CEdge{\e}
      \mid \CSource{v}{p}
    \\
  \end{array}
\]

\begin{theorem}[Sensibility]
  For any zippered grove $\Z{\Grove}$
  such that $\erase{\Z{\Grove}}$ is well sorted
    and $\recomp{\erase{\Z{\Grove}}} = G$,
  and any user action $\alpha$,
  if
  \[
    \applyAction{\Z{\Grove}}{\alpha}{\Q{a}}{c},
  \]
  then $G \action{\Q{a}} G'$ and $G'$ is well sorted.
\end{theorem}

\noindent $\boxed{\applyAction{ \Z{\Grove} }{ \alpha }{ \Q{a} }{ c }}$
%
\begin{mathpar}
  \inferrule{
    \applyAction{ \Z{\Set}_{NP} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\Z{\Set}_{NP}, \Set[MP], \Set[U]) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\Set}_{MP} }{ \alpha }{ \Q{a} }{ v' }{ p' }
  }{
    \applyAction{ (\Set[NP], \Z{\Set}_{MP}, \Set[U]) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\Set}_U }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\Set[NP], \Set[MP], \Z{\Set}_U) }{ \alpha }{ \Q{a} }{ c }
  }
\end{mathpar}

\noindent $\boxed{\applyAction{ \Z{\Set} }{ \alpha }{ \Q{a} }{ c }}$
%
\begin{mathpar}
  \inferrule{
    \applyAction{ \Z{t} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\Set, \Z{t}) }{ \alpha }{ \Q{a} }{ c }
  }
\end{mathpar}
\noindent $\boxed{\applyAction{ \Z{t} }{ \alpha }{ \Q{a} }{ c }}$
%
\begin{mathpar}
  \inferrule{
    \applyAction{ \Z{q} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eFun{G}{\Z{q}}{\tau}{e}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\tau} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eFun{G}{q}{\Z{\tau}}{e}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eFun{G}{q}{\tau}{\Z{e}}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ \eApp{G}{\Z{e}_1}{e_2} }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ \eApp{G}{e_1}{\Z{e}_2} }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\ePlus{G}{\Z{e}_1}{e_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\ePlus{G}{e_1}{\Z{e}_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eTimes{G}{\Z{e}_1}{e_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{e}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\eTimes{G}{e_1}{\Z{e}_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\tau}_1 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\tArrow{G}{\Z{\tau}_1}{\tau_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{\tau}_2 }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ (\tArrow{G}{\tau_1}{\Z{\tau}_2}) }{ \alpha }{ \Q{a} }{ c }
  }

  \inferrule{
    \applyAction{ \Z{t} }{ \alpha }{ \Q{a} }{ c }
  }{
    \applyAction{ \conflictHole{\Z{t}, \SetOf{t_i}_{i \leq n}}{v}{p} }{ \alpha }{
      \Q{a}
    }{ c }
  }
\end{mathpar}
%
\begin{mathpar}
  \inferrule[Construct]{
    % If:
    % 
    % 1. The source position (p_s) and new constructor (k) sort are valid w.r.t. the parent constructor (k_s)
    (p_s, \sort{k}) \in \arity{k_s} \\
    % 
    % 2. The term under the cursor is a hole
    % 
    % And we let:
    % 
    % v_k = a new vertex with the new constructor
    v_k = (\fresh{u}_k, k)
  }{
    % Then the user action Construct(k) produces the following set of graph actions:
    \applyAction{ \cursor{\emptyHole{v_s{=}(u_s, k_s)}{p_s}} }{ \Construct{k} }{
      % 
      % attach the new vertex to the cursor source
      \SetOf{\graphAction{\Plus}{(\fresh{u}, v_s, p_s, v_k)}}
    }{ \CVertex{v_k} }
  }

  \inferrule[ConstructWrap]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    %   (==> t is a basic term or reference, or, equivalently, t is not a conflict or a hole)
    \livesources{G_t} = \SetOf{(v_{s_i}, p_{s_i})}_{i \leq n} \\
    % 
    % 2. The new constructor (k) has default positions (p_wrap, p_post)
    \defaultpos{k} = (\pWrap, \pPost) \\
    % 
    % 3. The new constructor and the inconstructor(s) of t (k_Gt) have the same sort
    \SetOf{\sort{k} = \sort{k_i}}_{k_i \in \Q{k}_{G_t}} \\
    % 
    % 4. The new (default) position and old sort are in the arity of the new constructor
    (\pWrap, \sort{k}) \in \arity{k} \\\\
    % 
    % And we let:
    % 
    % v_k = a new vertex with the new constructor
    v_k = (\fresh{u}_k, k) \\
    % 
    % e_i = a new edge from source i to the new vertex
    \SetOf{\e_i}_{i \leq n} = \SetOf{(\fresh{u}_i, v_{s_i}, p_{s_i}, v_k)}_{i \leq n} \\
    % 
    % e' = a new edge from the new vertex and default position to the old invertex(es)
    \SetOf{\e_i'} = \SetOf{(\fresh{u}, v_k, \pWrap, v_i)}_{v_i \in \Q{v}_{G_t}}
  }{
    % Then the user action Construct(k) produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Construct{k} }{
      % 
      % delete the old ingraph
      \SetOf{\graphAction{\Minus}{\e}}_{\e \in \live{G_t}} \cup
      % 
      % construct an equivalent ingraph on the new vertex
      \SetOf{\graphAction{\Plus}{\e_i}}_{i \leq n} \cup
      % 
      % reattach the old invertex to the default position of the new vertex
      \SetOf{\graphAction{\Plus}{\e_i'}}_{i \leq n}
    }{ \CSource{v_k}{\pPost} }
  }

  \inferrule[Delete]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    \live{G_t} = \SetOf{\e_i}_{i \leq n} \\
    % 
    % 2. There is a unique source ==> not a deleted root or a multiparent root
    \livesources{G_t} = \SetOf{(v, p)}
  }{
    % Then the user action Delete produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Delete }{
      % 
      % delete the ingraph
      \SetOf{\graphAction{\Minus}{\e_i}}_{i \leq n}
    }{ \CSource{v}{p} }
  }

  \inferrule[DeleteRoot]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    \live{G_t} = \SetOf{\e_i}_{i \leq n}
  }{
    % Then the user action Delete produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Delete }{
      % 
      % delete the ingraph
      \SetOf{\graphAction{\Minus}{\e_i}}_{i \leq n}
    }{ \CVertex{v_{G_t}} }
  }

  \inferrule[Reposition]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    \live{G_t} = \SetOf{\e_i}_{i \leq n} \\
    % 
    % 2. The new source has no children
    \SizeOf{\children{v}{p}} = 0 \\
    % 
    % 3. The inconstructor (k_Gt) and new source position are in the arity of the new source constructor (k)
    \SetOf{(p, \sort{k_i}) \in \arity{k}}_{k_i \in \Q{k}_{G_t}}
  }{
    % Then the user action Reposition(v=(u,k), p) produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Reposition{v{=}(u, k)}{p} }{
      % 
      % delete the old ingraph
      \SetOf{\graphAction{\Minus}{\e_i}}_{i \leq n} \cup
      % 
      % attach the old invertex(es) to the new parent
      \SetOf{\graphAction{\Plus}{(\fresh{u}, v_s, p_s, v_i)}}_{v_i \in \Q{v}_{G_t}}
    }{ \CSource{v}{p} }
  }

  \inferrule[RepositionWrap]{
    % If:
    % 
    % 1. The term under the cursor (t) has an ingraph (Gt)
    \live{G_t} = \SetOf{\e_i}_{i \leq n} \\
    % 
    % 2. The new parent vertex (v) has at least one child
    \children{v}{p} = \SetOf{\e_j{=}(u_j, v, p, v_j)}_{j \leq m} \\
    % 
    % 3. The new source constructor (k) has a default position (p_k)
    \defaultpos{k} = (\pWrap, \pPost) \\
    % 
    % 4. The new source constructor and the old inconstructor (k_Gt) have the same sort
    \SetOf{\sort{k} = \sort{k_i}}_{k_i \in \Q{k}_{G_t}} \\
    % 
    % 5. The (default) position and old sort are in the arity of the new source constructor
    (\pWrap, \sort{k}) \in \arity{k} \\\\
    % 
    % And we let:
    % 
    %  e_j' = a new edge from the old invertex and default position to the children of the new parent
    \SetOf{\e_j'}_{j \leq m} = \SetOf{(\fresh{u'}_j, v_{G_t}, p_k, v_j)}_{j \leq m} \\
    % 
    % e' = a new edge from the new parent vertex and position to the old invertex (v_Gt)
    \e' = (\fresh{u}, v, p, v_{G_t})
  }{
    % Then the user action Reposition(v=(u,k), p) produces the following set of graph actions:
    \applyAction{ \cursor{t} }{ \Reposition{v{=}(u, k)}{p} }{
      % 
      % delete the ingraph of the term under the cursor
      \SetOf{\graphAction{\Minus}{\e_i}}_{i \leq n} \cup
      % 
      % delete the children of the new parent verrtex
      \SetOf{\graphAction{\Minus}{\e_j}}_{j \leq m} \cup
      % 
      % reattach the children to the default position of the old invertex
      \SetOf{\graphAction{\Plus}{\e_j'}}_{j \leq m} \cup
      % 
      % attach the old invertex to the new parent
      \SetOf{\graphAction{\Plus}{\e'}}
    }{ c }
  }

  % \inferrule[Conflict]{
  %   \SetOf{\applyAction{ \cursor{t_i} }{ v }{ p }{ \alpha }{ \Q{a}_i }{ v' }{ p' }}_{i \leq n}
  % }{
  %   \applyAction{ \cursor{\conflictHole{t_i}_{i \leq n}}{v_c}{p_c} }{ v }{ p }{\alpha}{
  %     \bigcup_{i \leq n} \Q{a}_i
  %   }{ v' }{ p' }
  % }
\end{mathpar}

% TODO: how to handle deleting a multiparent root?
% In general:
% - if you have a unique source, go to it.
% - otherwise, stay where you are.

% TODO: modify the rules to merge Conflict behaviors

% TODO: redo the rules to map between graph cursors instead of source pairs

% TODO: how to work with valid vs almost valid cursors?

% new judgment form: gamma^ --> a-; c