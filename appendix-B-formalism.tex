\section{Formalism}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

\figureTermSyntaxContent

For conflict hole forms $\conflictHoleForm{t_i}{i \leq n}$, it must be the case that $n \geq 2$.
We identify conflict holes up to reordering.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Term Constructors}

\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\sortOp : \K \to \SetOf{Exp, Pat, Typ}} \\
    \hline
    \sort{\Root}={} & Exp \\
    \sort{\ExpVar(x)}={} & Exp \\
    \sort{\ExpLam}={} & Exp \\
    \sort{\ExpApp}={} & Exp \\
    \sort{\ExpPlus}={} & Exp \\
    \sort{\ExpTimes}={} & Exp \\
    \sort{\ExpNum(n)}={} & Exp \\
    \sort{\PatVar(x)}={} & Pat \\
    \sort{\TypArrow}={} & Typ \\
    \sort{\TypNum}={} & Typ \\
  \end{array}
\]
%
\figureArityContent
%
\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\defaultposOp : \K \to \P} \\
    \hline
    \defaultpos{\Root}={} & \Root \\
    \defaultpos{\ExpLam}={} & \LamBody \\
    \defaultpos{\ExpPlus}={} & \PlusLeft \\
    \defaultpos{\ExpTimes}={} & \TimesLeft \\
    \defaultpos{\TypArrow}={} & \ArrowArg \\
  \end{array}
\]

\noindent $\boxed{\constructor{t} = k}$
%
\begin{align*}
  \constructor{e} &= \econstructor{e} \\
  \constructor{p} &= \pconstructor{p} \\
  \constructor{\tau} &= \tconstructor{\tau}
\end{align*}

\noindent $\boxed{\econstructor{e} = k}$
%
\begin{align*}
  \econstructor{\eVar{G}{x}} &= \ExpVar(x) \\
  \econstructor{\eFun{G}{q}{\tau}{e}} &= \ExpLam \\
  \econstructor{\eApp{G}{e_1}{e_2}} &= \ExpApp \\
  \econstructor{\eNum{G}{n}} &= \ExpNum(n) \\
  \econstructor{\ePlus{G}{e_1}{e_2}} &= \ExpPlus \\
  \econstructor{\eTimes{G}{e_1}{e_2}} &= \ExpTimes
\end{align*}

\noindent $\boxed{\pconstructor{q} = k}$
%
\begin{align*}
  \pconstructor{\pVar{G}{x}} &= \PatVar(x)
\end{align*}

\noindent $\boxed{\tconstructor{\tau} = k}$
%
\begin{align*}
  \tconstructor{\tArrow{G}{\tau_1}{\tau_2}} &= \TypArrow \\
  \tconstructor{\tNum{G}} &= \TypNum
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

Let $t$ denote a term and $\Set$ a set of terms.

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a function from edges to edge states,
  where $\E = \U \times \V \times \P \times \V$,
  unique IDs are drawn from some suitable set $\U$ equipped with a total ordering $\leq$,
  vertices are drawn from $\V$,
  positions are drawn from $\P$,
  and edge states are drawn from $\Sigma$.
\end{definition}

Let $G_t$, called the \emph{in-graph} of term $t$,
denote the graph associated with term $t$, when such a graph exists.
For example, when $t$ is of the form $\eFun{G}{q}{\tau}{e}$, $G_t = G$.

Let $v_t$, called the \emph{in-vertex} of term $t$,
denote the destination vertex of the edges of $G_t$,
provided that $t$ is well sorted.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\begin{definition}
  A graph $G$ is well sorted if all edges $\e$ such that $G(\e) \in \{\Plus, \Minus\}$ are well sorted.
\end{definition}

\begin{definition}
  An edge $(u, (u_1, k_1), p, (u_2, k_2))$ is well sorted if $(p, \sort{k_2}) \in \arity{k_1}$.
\end{definition}

\begin{definition}
  A grove $(\Set[NP], \Set[MP], \Set[U])$ is well sorted if all of the following hold:
  \begin{enumerate}
    \item The terms of $\Set[NP], \Set[MP],$ and $\Set[U]$ are well sorted.
      % $\Set[NP]$, $\Set[MP]$, and $\Set[U]$ contain only well sorted terms.
    \item For all $t \in \Set[NP]$,
      we have $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} = 0$.
      % The terms in $\Set[NP]$ correspond to edges with target vertices that have no parents.
    \item For all $t \in \Set[MP]$,
      we have $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} > 1$.
      % The terms in $\Set[MP]$ correspond to edges with target vertices that have multiple parents.
    \item For all $t \in \Set[U]$, all of the following hold:
      \begin{enumerate}
        \item $\SizeOf{\SetOf{\e{=}(u, v, p, v') \SuchThat{G_t(\e) = \Plus}}} = 1$.
        \item $v' = \min{\ancestors{v'}}$.
      \end{enumerate}
      % The terms in $\Set[U]$ correspond to edges with target vertices that are unicycle roots.
    \item For all $t \in \Set[MP] \cup \Set[U]$,
      we have $\SizeOf{\SetOf{\e{=}(u, \rootVertex, \Root, v) \SuchThat{G_t(\e) \in \SetOf{\Plus, \Minus}}}} = 0$.
      % Any terms corresponding to edges originating from $\rootVertex$ are in $\Set[NP]$.
  \end{enumerate}
\end{definition}

\begin{definition}
  A term $t$ is well sorted if one of the following holds:
  \begin{itemize}
    \item $t = \hole$.
      % An empty hole is trivially well sorted.
    \item $t = \conflictHoleForm{t_i}{i \leq n}$ and all of the following hold:
      \begin{enumerate}
        \item For all $i = 1, \ldots, n$, we have $t_i$ is well sorted.
          % The conflicting terms are well sorted ...
        % \item $\sort{t_1} = \cdots = \sort{t_n}$.
        %   % ... and of the same sort ...
        \item
          There exist $v_0 \in \V, p_0 \in \P$ such that,
          for all $i = 1, \ldots, n$,
          and all $\e{=}(u, v, p, v')$ such that $G_{t_i}(\e) = \Plus$,
          we have $v = v_0$ and $p = p_0$.
          % ... and all of their incoming edges have the same source vertex and position.
      \end{enumerate}
    \item $t = \multiVertex{\e}$ and all of the following hold:
      \begin{enumerate}
        \item $\e$ is well sorted.
          % The corresponding edge is well sorted ...
        \item $\SizeOf{\SetOf{\e' \SuchThat{G_t(\e') = \Plus}}} > 1$.
          % ... and its target vertex has multiple parents.
      \end{enumerate}
    \item $t = \cycleVertex{(u, v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        \item $(u, v, p, v')$ is well sorted.
          % The corresponding edge is well sorted ...
        \item $v' = \min{\ancestors{v'}}$
          % ... and its target vertex is the root ...
        \item For all $\e{=}(u_{\e}, v_{\e}, p_{\e}, v_{\e}')$
          such that $v_{\e}' \in \ancestors{v'}$,
          we have $\SizeOf{\parents{v_{\e}'}} = 1$.
          % ... of a unicycle.
      \end{enumerate}
    \item Otherwise, $G_t$ exists and all of the following hold:
      \begin{enumerate}
        \item $G_t$ is well sorted.
          % All incoming edges are well sorted ...
        \item For all $\e{=}(u, v, p, v')$ such that $G_t(\e) \in \SetOf{\Plus, \Minus}$,
          we have $v' = v_t$.
          % ... all incoming edges have the same destination vertex (and we call it the in-vertex of t).
        \item $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) \in \SetOf{\Plus, \Minus}}}} \geq 1$.
          % The in-graph of t is not empty.
        \item There exists $u_0 \in \U$ such that,
          for all $\e{=}(u, v, p, v')$ such that $G_t(\e) \in \SetOf{\Plus, \Minus}$,
          we have $v' = v_t = (u_0, \constructor{t})$.
          % The destination vertices of all incoming edges have the same id and constructor.
          % The constructor matches the term.
      \end{enumerate}
  \end{itemize}
\end{definition}

% TODO: update confliceHole usage
% TODO: rename multiVertex / cycleVertex
% TODO: check for "we have" after "such that"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

\begin{theorem}
  For any well sorted graph $G$,
  there exists a (well sorted) grove $\Grove$
  such that $\decomp{G} = \Grove$.
\end{theorem}

Proof: provide a witness that demonstrates the conclusion.

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\decomp{G} = \Grove$ then $\vertexes{G} = \vertexes{\Grove}$.
% \end{theorem}

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\recomp{\Grove} = G$ then $\vertexes{\Grove} = \vertexes{G}$.
% \end{theorem}

\figureDecompositionDefHelpersContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}\hspace*{\fill} \\

\noindent $\boxed{\decomp{G} = \Grove}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\decomp{\e} = t}$
%
\figureDecompositionDefDecompTerm

\noindent $\boxed{\edecomp{\e} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\pdecomp{\e} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\tdecomp{\e} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\edecompPrime{\e}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecompPrime{\e}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecompPrime{\e}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  If $G$ is a well sorted graph such that $\decomp{G} = \Grove$,
  then $\recomp{\Grove} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove} = G}$
%
\begin{align*}
  \recomp{(\Set[NP], \Set[MP], \Set[U])} &= \bigcup_{t \in \Set[NP] \cup \Set[MP] \cup \Set[U]} \recomp{t}
\end{align*}

\noindent $\boxed{\recomp{t} = G}$
%
\begin{align*}
  \recomp{e} &= \erecomp{e} \\
  \recomp{q} &= \precomp{q} \\
  \recomp{\tau} &= \trecomp{\tau}
\end{align*}

\noindent $\boxed{\erecomp{e} = G}$
%
\begin{align*}
  \erecomp{\eVar{G}{x}} &= G
  \\
  \erecomp{\eFun{G}{q}{\tau}{e}}
    &= G \cup \precomp{q} \cup \trecomp{\tau} \cup \erecomp{e}
  \\
  \erecomp{\eApp{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eNum{G}{n}} &= G
  \\
  \erecomp{\ePlus{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eTimes{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\conflictHoleForm{e_i}{i \leq n}}
  &= \bigcup_{i=1}^n \erecomp{e_i}
  \\
  \erecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\hole} &= \SetOf{}
\end{align*}

\noindent $\boxed{\precomp{q} = G}$
%
\begin{align*}
  \precomp{\pVar{G}{x}} &= G
  \\
  \precomp{\conflictHoleForm{q_i}{i \leq n}} &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\hole} &= \SetOf{}
\end{align*}

\noindent $\boxed{\trecomp{\tau} = G}$
%
\begin{align*}
  \trecomp{\tArrow{G}{\tau_1}{\tau_2}}
    &= G \cup \trecomp{\tau_1} \cup \trecomp{\tau_2}
  \\
  \trecomp{\tNum{G}} &= G
  \\
  \trecomp{\conflictHole{\tau_i}{i \leq n}} &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\hole} &= \SetOf{}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Cursors}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Terms}

\[
  \arraycolsep=0pt
  \begin{array}{lcllll}
    \Z{t} & {}\in{} & ZTerm & {}::={} &
      \Z{e}
      \mid \Z{q}
      \mid \Z{\tau}
    \\
    \Z{e} & {}\in{} & ZExp & {}::={} &
      \cursor{e}
      \mid \eFun{G}{\Z{q}}{\tau}{e}
      \mid \eFun{G}{q}{\Z{\tau}}{e}
      \mid \eFun{G}{q}{\tau}{\Z{e}}
      \mid \eApp{G}{\Z{e}}{e}
      \mid \eApp{G}{e}{\Z{e}}
      \mid \ePlus{G}{\Z{e}}{e}
      \mid \ePlus{G}{e}{\Z{e}}
      \mid \eTimes{G}{\Z{e}}{e}
      \\
    &&&&
    \mid \eTimes{G}{e}{\Z{e}}
      \mid \conflictHoleForm{\Z{e}; e_i}{i \leq n}
    \\
    \Z{q} & {}\in{} & ZPat & {}::={} &
      \cursor{q}
      \mid \conflictHoleForm{\Z{q}; q_i}{i \leq n}
    \\
    \Z{\tau} & {}\in{} & ZTyp & {}::={} &
      \cursor{\tau}
      \mid \tArrow{G}{\Z{\tau}}{\tau}
      \mid \tArrow{G}{\tau}{\Z{\tau}}
      \mid \conflictHoleForm{\Z{\tau}; \tau_i}{i \leq n}
    \\
  \end{array}
\]

Let $\Z{\Set} = (\Set, \Z{t})$ denote a set of terms paired with a zippered term.
Let $\conflictHoleForm{\Z{t}; t_i}{i \leq n}$ denote a conflict hole paired with a zippered term.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Groves}

\begin{gather*}
  \arraycolsep=0pt
  \begin{array}{lll}
    \Z{\gamma} & {}::={} &
      (\Z{\Set}_{NP}, \Set[MP], \Set[U])
      \mid (\Set[NP], \Z{\Set}_{MP}, \Set[U])
      \mid (\Set[NP], \Set[MP], \Z{\Set}_U)
  \end{array}
\end{gather*}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Cursor Erasure}\hspace*{\fill} \\

\noindent $\boxed{\erase{\Z{\gamma}} = \gamma}$
%
\begin{align*}
  \erase{(\Z{\Set}_{NP}, \Set[MP], \Set[U])} &= (\erase{\Z{\Set}_{NP}}, \Set[MP], \Set[U]) \\
  \erase{(\Set[NP], \Z{\Set}_{MP}, \Set[U])} &= (\Set[NP], \erase{\Z{\Set}_{MP}}, \Set[U]) \\
  \erase{(\Set[NP], \Set[MP], \Z{\Set}_U)} &= (\Set[NP], \Set[MP], \erase{\Z{\Set}_U})
\end{align*}

\noindent $\boxed{\erase{\Z{\Set}} = \Set}$
%
\begin{align*}
  \erase{(\Set, \Z{t})} &= \Set \cup \SetOf{t}
\end{align*}

\noindent $\boxed{\erase{\Z{e}} = e}$
%
\begin{align*}
  \erase{\cursor{e}} &= e \\
  \erase{\left(\eFun{G}{\Z{q}}{\tau}{e}\right)} &= \eFun{G}{\erase{\Z{q}}}{\tau}{e} \\
  \erase{\left(\eFun{G}{q}{\Z{\tau}}{e}\right)} &= \eFun{G}{q}{\erase{\Z{\tau}}}{e} \\
  \erase{\left(\eFun{G}{q}{\tau}{\Z{e}}\right)} &= \eFun{G}{q}{\tau}{\erase{\Z{e}}} \\
  \erase{\eApp{G}{\Z{e}_1}{e_2}} &= \eApp{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eApp{G}{e_1}{\Z{e}_2}} &= \eApp{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\ePlus{G}{\Z{e}_1}{e_2}} &= \ePlus{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\ePlus{G}{e_1}{\Z{e}_2}} &= \ePlus{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\eTimes{G}{\Z{e}_1}{e_2}} &= \eTimes{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eTimes{G}{e_1}{\Z{e}_2}} &= \eTimes{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\conflictHoleForm{\Z{e}; e_i}{i \leq n}} &= \conflictHole{\erase{\Z{e}}, e_1, \ldots, e_n}
\end{align*}

\noindent $\boxed{\erase{\Z{q}} = q}$
%
\begin{align*}
  \erase{\cursor{q}} &= q \\
  \erase{\conflictHoleForm{\Z{q}; q_i}{i \leq n}} &= \conflictHole{\erase{\Z{q}}, q_1, \ldots, q_n}
\end{align*}

\noindent $\boxed{\erase{\Z{\tau}} = \tau}$
%
\begin{align*}
  \erase{\cursor{\tau}} &= \tau \\
  \erase{\left(\tArrow{G}{\Z{\tau}_1}{\tau_2}\right)} &= \tArrow{G}{\erase{\Z{\tau}_1}}{\tau_2} \\
  \erase{\left(\tArrow{G}{\tau_1}{\Z{\tau}_2}\right)} &= \tArrow{G}{\tau_1}{\erase{\Z{\tau}_2}} \\
  \erase{\conflictHoleForm{\Z{\tau}; \tau_i}{i \leq n}} &= \conflictHole{\erase{\Z{\tau}}, \tau_1, \ldots, \tau_n}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

% TODO: We write defaultpos(k_) undefined to mean there does not exist a p such that defaultpos(k) = p
% TODO: fix subscripts on v_...
% TODO: move (v, p) from cursor syntax to judgment
% TODO: fix position of hat over t's
% TODO: consider the user action cases with multiple incoming edges
% TODO: thm: user action semantics always produce well sorted graphs

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} &
      \Construct{k}
      \mid \Delete
      \mid \Reposition{v}{p}
    \\
  \end{array}
\]

\noindent $\boxed{\Z{\Grove} \action{\alpha} a^{*}}$
%
\begin{mathpar}
  \inferrule{
    \Z{\Set}_{NP} \action{\alpha} a^{*}
  }{
    (\Z{\Set}_{NP}, \Set[MP], \Set[U]) \action{\alpha} a^{*}
  }

  \inferrule{
    \Z{\Set}_{MP} \action{\alpha} a^{*}
  }{
    (\Set[NP], \Z{\Set}_{MP}, \Set[U]) \action{\alpha} a^{*}
  }

  \inferrule{
    \Z{\Set}_U \action{\alpha} a^{*}
  }{
    (\Set[NP], \Set[MP], \Z{\Set}_U) \action{\alpha} a^{*}
  }
\end{mathpar}

\noindent $\boxed{\Z{\Set} \action{\alpha} a^{*}}$
%
\begin{mathpar}
  \inferrule{
    \Z{t} \action{\alpha} a^{*}
  }{
    (\Set, \Z{t}) \action{\alpha} a^{*}
  }
\end{mathpar}

\noindent $\boxed{v, t; \Z{t} \action{\alpha} a^{*}}$
%
\begin{mathpar}
  \inferrule{
    v_{(\eFun{G}{\Z{q}}{\tau}{e})}, \LamParam; \Z{q} \action{\alpha} a^{*}
  }{
    v, p; (\eFun{G}{\Z{q}}{\tau}{e})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\eFun{G}{q}{\Z{\tau}}{e})}, \LamType; \Z{\tau} \action{\alpha} a^{*}
  }{
    v, p; (\eFun{G}{q}{\Z{\tau}}{e})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\eFun{G}{q}{\tau}{\Z{e}})}, \LamBody; \Z{e} \action{\alpha} a^{*}
  }{
    v, p; (\eFun{G}{q}{\tau}{\Z{e}})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{\eApp{G}{\Z{e}_1}{e_2}}, \AppFun; \Z{e}_1 \action{\alpha} a^{*}
  }{
    v, p; \eApp{G}{\Z{e}_1}{e_2}
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{\eApp{G}{e_1}{\Z{e}_2}}, \AppArg; \Z{e}_2 \action{\alpha} a^{*}
  }{
    v, p; \eApp{G}{e_1}{\Z{e}_2}
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\ePlus{G}{\Z{e}_1}{e_2})}, \PlusLeft; \Z{e}_1 \action{\alpha} a^{*}
  }{
    v, p; (\ePlus{G}{\Z{e}_1}{e_2})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\ePlus{G}{e_1}{\Z{e}_2})}, \PlusRight; \Z{e}_2 \action{\alpha} a^{*}
  }{
    v, p; (\ePlus{G}{e_1}{\Z{e}_2})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\eTimes{G}{\Z{e}_1}{e_2})}, \TimesLeft; \Z{e}_1 \action{\alpha} a^{*}
  }{
    v, p; (\eTimes{G}{\Z{e}_1}{e_2})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\eTimes{G}{e_1}{\Z{e}_2})}, \TimesRight; \Z{e}_2 \action{\alpha} a^{*}
  }{
    v, p; (\eTimes{G}{e_1}{\Z{e}_2})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\tArrow{G}{\Z{\tau}_1}{\tau_2})}, \ArrowArg; \Z{\tau}_1 \action{\alpha} a^{*}
  }{
    v, p; (\tArrow{G}{\Z{\tau}_1}{\tau_2})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v_{(\tArrow{G}{\tau_1}{\Z{\tau}_2})}, \ArrowResult; \Z{\tau}_2 \action{\alpha} a^{*}
  }{
    v, p; (\tArrow{G}{\tau_1}{\Z{\tau}_2})
    \action{\alpha}
    a^{*}
  }

  \inferrule{
    v, p; \Z{t} \action{\alpha} a^{*}
  }{
    v, p; \conflictHoleForm{\Z{t}; t_i}{i \leq n}
    \action{\alpha}
    a^{*}
  }
\end{mathpar}
%
\begin{mathpar}
  \inferrule{
    G_t((u, v, p, v_t)) = \Plus \\
    \defaultpos{k} \text{ undefined}
  }{
    v, p; \cursor{t}
    \action{\Construct{k}}
    \big(\Plus, (u', v, p, (u'', k))\big)
  }

  \inferrule{
    G_t(\e{=}(u, v, p, v_t)) = \Plus \\
    \defaultpos{k} = p_k
  }{
    v, p; \cursor{t}
    \action{\Construct{k}}
    \big(\Minus, \e\big);
    \big(\Plus, (u', v, p, (u'', k))\big);
    \big(\Plus, (u''', (u'', k), p_k, v_t)\big)
  }

  \inferrule{
    \defaultpos{k} \text{ undefined}
  }{
    v, p; \cursor{\conflictHoleForm{t_i}{i \leq n}}
    \action{\Construct{k}}
    \big(\Plus, (u, v, p, (u', k))\big)
  }

  \inferrule{
    \defaultpos{k} = p_k
  }{
    v, p; \cursor{\conflictHoleForm{t_i}{i \leq n}}
    \action{\Construct{k}}
    \big(\Minus, (u_1, v, p, v_{t_1}')\big);
    \ldots;
    \big(\Minus, (u_n, v, p, v_{t_n}')\big);
    \big(\Plus, (u, v, p, (u', k))\big); \\
    \big(\Plus, (u_1', (u', k), p_k, v_{t_1}')\big);
    \ldots;
    \big(\Plus, (u_n', (u', k), p_k, v_{t_n}')\big)
  }

  \inferrule{
    \defaultpos{k} \text{ undefined}
  }{
    v, p; \cursor{\multiVertex{(u, v, p, v')}}
    \action{\Construct{k}}
    \big(\Plus, (u', v, p, (u'', k))\big)
  }

  \inferrule{
    \defaultpos{k} = p_k
  }{
    v, p; \cursor{\multiVertex{\e{=}(u, v, p, v')}}
    \action{\Construct{k}}
    \big(\Minus, \e\big);
    \big(\Plus, (u', v, p, (u'', k))\big);
    \big(\Plus, (u''', (u'', k), p_k, v')\big)
  }

  \inferrule{
    \defaultpos{k} \text{ undefined}
  }{
    v, p; \cursor{\cycleVertex{(u, v, p, v')}}
    \action{\Construct{k}}
    \big(\Plus, (u', v, p, (u'', k))\big)
  }

  \inferrule{
    \defaultpos{k} = p_k
  }{
    v, p; \cursor{\cycleVertex{\e{=}(u, v, p, v')}}
    \action{\Construct{k}}
    \big(\Minus, \e\big);
    \big(\Plus, (u', v, p, (u'', k))\big);
    \big(\Plus, (u''', (u'', k), p_k, v')\big)
  }

  \inferrule{}{
    v, p; \cursor{\hole}
    \action{\Construct{k}}
    \big(\Plus, (u, v, p, (u', k))\big)
  }

  \inferrule{
    G_t(\e{=}(u, v, p, v_t)) = \Plus
  }{
    v, p; \cursor{t}
    \action{Delete}
    \big(\Minus, \e)\big)
  }

  \inferrule{
    G_t(\e{=}(u, v, p, v_t)) = \Plus
  }{
    v, p; \cursor{t}
    \action{\Reposition{v_\alpha}{p_\alpha}}
    \big(\Minus, \e\big);
    \big(\Plus, (u', v_\alpha, p_\alpha, v_t)\big)
  }
\end{mathpar}

% \noindent $\boxed{\Z{e} \action{\alpha} \Z{e}}$
% %
% \begin{align*}
%   \cursor{v}{p}{\hole}   \action{\Construct{k}}   \cursor{v}{p}{\decomp{(u, v, p, (u', k)}} \\
%   \cursor{v}{p}{}
% \end{align*}

% Cases:
% \begin{itemize}
%   \item construct @ hole (create current edge)
%   \item construct @ conflict (create new edge into conflict ??)
%   \item construct @ non-hole (wrap current edge)
%   \item delete @ hole (no-op)
%   \item delete @ conflict (destroy all edges ??)
%   \item delete @ non-hole (destroy current edge)
%   \item reposition @ hole (no-op)
%   \item reposition @ conflict (???)
%   \item reposition @ non-hole (destroy current edge and create new edge with same destination vertex)
% \end{itemize}
