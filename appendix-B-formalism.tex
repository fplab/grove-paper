\section{Formalism}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

\figureTermSyntaxContent

For conflict hole forms $\conflictHole{t_i}_{i \leq n}$, it must be the case that $n \geq 2$.
We identify conflict holes up to reordering.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Term Constructors}

\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\sortOp : \K \to \SetOf{Exp, Pat, Typ}} \\
    \hline
    \sort{\Root}={} & Exp \\
    \sort{\ExpVar(x)}={} & Exp \\
    \sort{\ExpLam}={} & Exp \\
    \sort{\ExpApp}={} & Exp \\
    \sort{\ExpPlus}={} & Exp \\
    \sort{\ExpTimes}={} & Exp \\
    \sort{\ExpNum(n)}={} & Exp \\
    \sort{\PatVar(x)}={} & Pat \\
    \sort{\TypArrow}={} & Typ \\
    \sort{\TypNum}={} & Typ \\
  \end{array}
\]
%
\figureArityContent
%
\[
  \arraycolsep=0pt
  \begin{array}{ll}
    \multicolumn{2}{l}{\defaultposOp : \K \to \P} \\
    \hline
    \defaultpos{\Root}={} & \Root \\
    \defaultpos{\ExpLam}={} & \LamParam \\
    \defaultpos{\ExpApp}={} & \AppFun \\
    \defaultpos{\ExpPlus}={} & \PlusLeft \\
    \defaultpos{\ExpTimes}={} & \TimesLeft \\
    \defaultpos{\TypArrow}={} & \ArrowArg \\
  \end{array}
\]

We write $\defaultpos{k}$ undefined when there does not exist a $p$ such that $\defaultpos{k} = p$.

\noindent $\boxed{\constructor{t} = k}$
%
\begin{align*}
  \constructor{e} &= \econstructor{e} \\
  \constructor{p} &= \pconstructor{p} \\
  \constructor{\tau} &= \tconstructor{\tau}
\end{align*}

\noindent $\boxed{\econstructor{e} = k}$
%
\begin{align*}
  \econstructor{\eVar{G}{x}} &= \ExpVar(x) \\
  \econstructor{\eFun{G}{q}{\tau}{e}} &= \ExpLam \\
  \econstructor{\eApp{G}{e_1}{e_2}} &= \ExpApp \\
  \econstructor{\eNum{G}{n}} &= \ExpNum(n) \\
  \econstructor{\ePlus{G}{e_1}{e_2}} &= \ExpPlus \\
  \econstructor{\eTimes{G}{e_1}{e_2}} &= \ExpTimes
\end{align*}

\noindent $\boxed{\pconstructor{q} = k}$
%
\begin{align*}
  \pconstructor{\pVar{G}{x}} &= \PatVar(x)
\end{align*}

\noindent $\boxed{\tconstructor{\tau} = k}$
%
\begin{align*}
  \tconstructor{\tArrow{G}{\tau_1}{\tau_2}} &= \TypArrow \\
  \tconstructor{\tNum{G}} &= \TypNum
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

Let $t$ denote a term and $\Set$ a set of terms.

\begin{definition}
  A \emph{constructor} $k$ names the form of a term that is not a hole.
\end{definition}

\begin{definition}
  A \emph{unique identifier} $u \in \U$ is an object that can be distiinguished from other unique identifiers by inspection.
\end{definition}

\begin{definition}
  A \emph{vertex} $v{=}(u, k)$ is an instance of constructor $k \in \K$ with unique identifier $u$.
\end{definition}

\begin{definition}
  A \emph{position} $p$ names an origin of directed edges.
\end{definition}

\begin{definition}
  An \emph{edge} $\e{=}(u, v, p, v^\prime)$ is a directed connection from vertex $v$ to vertex $v'$, originating from position $p$, and identified by $u$.
  We call $v$ the \emph{source} vertex and $v'$ the \emph{target} vertex.
\end{definition}

\begin{definition}
  An \emph{edge state} $s \in \Sigma{=}\SetOf{\Plus, \Minus}$ indicates whether an edge is live $\left(\Plus\right)$ or deleted $\left(\Minus\right)$.
\end{definition}

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a partial function from edges to edge states.
  We write $G(\e) = \bot$ to mean that $G(\e)$ is undefined.
\end{definition}

\begin{definition}
  The \emph{in-graph} of a vertex $v$ is the subgraph containing all mappings from edges targeting $v$ to $\Plus$ or $\Minus$.
\end{definition}

\begin{definition}
  The \emph{out-edges} of a vertex $v$ and position $p$ is the set of all live edges with source $v$ originating from $p$.
\end{definition}

\begin{definition}
  The \emph{parents} of a vertex $v$ is the set of all live edges targeting $v$.
\end{definition}

\begin{definition}
  The \emph{ancestors} of a vertex $v$ is defined recursively as the parents of $v$ and their ancestors.
\end{definition}

% \begin{definition}
%   The \emph{in-graph} of a term $t$ is the subgraph associated with $t$, when it exists, which maps every edge targeting the root vertex of $t$.
%   For example, when $t$ is of the form $\eFun{G}{q}{\tau}{e}$, its in-graph is $G$.
%   If $t$ is of the form $\multiVertex{\e}$ or $\cycleVertex{\e}$, its in-graph maps the associated edge to $\Plus$ and all other edges to $\bot$.
%   If $t$ is not a reference and does not have an associated graph, then it is a conflict hole and therefore does not have an in-graph.
%   We write $G_t$ to denote the in-graph of $t$.
% \end{definition}

% Let $G_t$, called the \emph{in-graph} of term $t$, denote one of the following:
% \begin{itemize}
%   \item
%     The graph associated with term $t$, when such a graph exists.
%     For example, when $t$ is of the form $\eFun{G}{q}{\tau}{e}$, we have $G_t = G$.
%   \item
%     Otherwise,
%     if $t \in \SetOf{\multiVertex{\e}, \cycleVertex{\e}}$,
%     then $G_t = \SetOf{\e \mapsto \Plus}$.
% \end{itemize}

% Let $v_{G_t}$, called the \emph{in-vertex} of term $t$,
% denote the destination vertex of the edge(s) of $G_t$,
% provided that $t$ is well sorted.

Let $\fresh{u}$ denote a fresh id.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\begin{definition}
  A graph $G$ is well sorted if $\edges{G}$ are well sorted.
\end{definition}

\begin{definition}
  An edge $(u, (u_1, k_1), p, (u_2, k_2))$ is well sorted if $(p, \sort{k_2}) \in \arity{k_1}$.
\end{definition}

\begin{definition}
  A grove $(\Set[NP], \Set[MP], \Set[U])$ is well sorted if all of the following hold:
  \begin{enumerate}
    \item The terms of $\Set[NP], \Set[MP],$ and $\Set[U]$ are well sorted.
      % $\Set[NP]$, $\Set[MP]$, and $\Set[U]$ contain only well sorted terms.
    \item For all $t \in \Set[NP]$,
      we have $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} = 0$.
      % The terms in $\Set[NP]$ correspond to edges with target vertices that have no parents.
    \item For all $t \in \Set[MP]$,
      we have $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} > 1$.
      % The terms in $\Set[MP]$ correspond to edges with target vertices that have multiple parents.
    \item For all $t \in \Set[U]$, all of the following hold:
      \begin{enumerate}
        \item $\SizeOf{\SetOf{\e{=}(u, v, p, v') \SuchThat{G_t(\e) = \Plus}}} = 1$.
        \item $v' = \min{\ancestors{v'}}$.
      \end{enumerate}
      % The terms in $\Set[U]$ correspond to edges with target vertices that are unicycle roots.
    \item For all $t \in \Set[MP] \cup \Set[U]$,
      we have $\SizeOf{\SetOf{\e{=}(u, \rootVertex, \Root, v) \SuchThat{\e \in \edges{G_t} \land u \in \U \land v \in \V}}} = 0$.
      % Any terms corresponding to edges originating from $\rootVertex$ are in $\Set[NP]$.
  \end{enumerate}
\end{definition}

\begin{definition}
  A term $t$ is well sorted if one of the following holds:
  \begin{itemize}

    \item $t = \emptyHole{v{=}(u, k)}{p}$
      and there exists $s \in \SetOf{Exp, Pat, Typ}$
      such that $(p, s) \in \arity{k}$.
      % An empty hole is well sorted if the associated source vertex can have
      % children at the associated position.

    \item $t = \conflictHole{t_i}_{i \leq n}$ and all of the following hold:
      \begin{enumerate}
        \item For all $i = 1, \ldots, n$, we have $t_i$ is well sorted.
          % The conflicting terms are well sorted ...
        \item
          There exist $v_0 \in \V, p_0 \in \P$ such that,
          for all $i = 1, \ldots, n$,
          and all $\e{=}(u, v, p, v')$ such that $G_{t_i}(\e) = \Plus$,
          we have $v = v_0$ and $p = p_0$.
          % ... and all of their incoming edges have the same source vertex and position.
      \end{enumerate}

    \item $t = \multiVertex{\e}$ and all of the following hold:
      \begin{enumerate}
        \item $\e$ is well sorted.
          % The corresponding edge is well sorted ...
        \item $\SizeOf{\SetOf{\e' \SuchThat{G_t(\e') = \Plus}}} > 1$.
          % ... and its target vertex has multiple parents.
      \end{enumerate}

    \item $t = \cycleVertex{(u, v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        \item $(u, v, p, v')$ is well sorted.
          % The corresponding edge is well sorted ...
        \item $v' = \min{\ancestors{v'}}$
          % ... and its target vertex is the root ...
        \item For all $\e{=}(u_{\e}, v_{\e}, p_{\e}, v_{\e}')$
          such that $v_{\e}' \in \ancestors{v'}$,
          we have $\SizeOf{\parents{v_{\e}'}} = 1$.
          % ... of a unicycle.
      \end{enumerate}

    \item Otherwise, $G_t$ exists and all of the following hold:
      \begin{enumerate}
        \item $G_t$ is well sorted.
          % All incoming edges are well sorted ...
        \item For all $\e{=}(u, v, p, v') \in \edges{G_t}$,
          we have $v' = v_{G_t}$.
          % ... all incoming edges have the same destination vertex (and we call it the in-vertex of t).
        \item $\SizeOf{\edges{G_t}} \geq 1$.
          % The in-graph of t is not empty.
        \item There exists $u_0 \in \U$ such that,
          for all $\e{=}(u, v, p, v') \in \edges{G_t}$,
          we have $v' = v_{G_t} = (u_0, \constructor{t})$.
          % The destination vertices of all incoming edges have the same id and constructor.
          % The constructor matches the term.
      \end{enumerate}
  \end{itemize}
\end{definition}

% TODO: update confliceHole usage
% TODO: rename multiVertex / cycleVertex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

\begin{theorem}
  For any well sorted graph $G$,
  there exists a (well sorted) grove $\Grove$
  such that $\decomp{G} = \Grove$.
\end{theorem}

Proof: provide a witness that demonstrates the conclusion.

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\decomp{G} = \Grove$ then $\vertexes{G} = \vertexes{\Grove}$.
% \end{theorem}

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\recomp{\Grove} = G$ then $\vertexes{\Grove} = \vertexes{G}$.
% \end{theorem}

\figureDecompositionDefHelpersContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}\hspace*{\fill} \\

\noindent $\boxed{\decomp{G} = \Grove}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\decomp{\e} = t}$
%
\figureDecompositionDefDecompTerm

\noindent $\boxed{\edecomp{\e} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\pdecomp{\e} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\tdecomp{\e} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\edecompPrime{\e}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecompPrime{\e}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecompPrime{\e}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  If $G$ is a well sorted graph such that $\decomp{G} = \Grove$,
  then $\recomp{\Grove} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove} = G}$
%
\begin{align*}
  \recomp{(\Set[NP], \Set[MP], \Set[U])} &= \bigcup_{t \in \Set[NP] \cup \Set[MP] \cup \Set[U]} \recomp{t}
\end{align*}

\noindent $\boxed{\recomp{t} = G}$
%
\begin{align*}
  \recomp{e} &= \erecomp{e} \\
  \recomp{q} &= \precomp{q} \\
  \recomp{\tau} &= \trecomp{\tau}
\end{align*}

\noindent $\boxed{\erecomp{e} = G}$
%
\begin{align*}
  \erecomp{\eVar{G}{x}} &= G
  \\
  \erecomp{\eFun{G}{q}{\tau}{e}}
    &= G \cup \precomp{q} \cup \trecomp{\tau} \cup \erecomp{e}
  \\
  \erecomp{\eApp{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eNum{G}{n}} &= G
  \\
  \erecomp{\ePlus{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eTimes{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\conflictHole{e_i}_{i \leq n}}
  &= \bigcup_{i=1}^n \erecomp{e_i}
  \\
  \erecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

\noindent $\boxed{\precomp{q} = G}$
%
\begin{align*}
  \precomp{\pVar{G}{x}} &= G
  \\
  \precomp{\conflictHole{q_i}_{i \leq n}} &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

\noindent $\boxed{\trecomp{\tau} = G}$
%
\begin{align*}
  \trecomp{\tArrow{G}{\tau_1}{\tau_2}}
    &= G \cup \trecomp{\tau_1} \cup \trecomp{\tau_2}
  \\
  \trecomp{\tNum{G}} &= G
  \\
  \trecomp{\conflictHole{\tau_i}_{i \leq n}} &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\emptyHole{v}{p}} &= \SetOf{}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Cursors}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Terms}

\[
  \arraycolsep=0pt
  \begin{array}{lcllll}
    \Z{t} & {}\in{} & ZTerm & {}::={} &
      \Z{e}
      \mid \Z{q}
      \mid \Z{\tau}
    \\
    \Z{e} & {}\in{} & ZExp & {}::={} &
      \cursor{e}
      \mid \eFun{G}{\Z{q}}{\tau}{e}
      \mid \eFun{G}{q}{\Z{\tau}}{e}
      \mid \eFun{G}{q}{\tau}{\Z{e}}
      \mid \eApp{G}{\Z{e}}{e}
      \mid \eApp{G}{e}{\Z{e}}
      \mid \ePlus{G}{\Z{e}}{e}
      \mid \ePlus{G}{e}{\Z{e}}
      \mid \eTimes{G}{\Z{e}}{e}
      \\
    &&&&
      \mid \eTimes{G}{e}{\Z{e}}
      \mid \conflictHole{\Z{e}, \SetOf{e_i}_{i \leq n}}
    \\
    \Z{q} & {}\in{} & ZPat & {}::={} &
      \cursor{q}
      \mid \conflictHole{\Z{q}, \SetOf{q_i}_{i \leq n}}
    \\
    \Z{\tau} & {}\in{} & ZTyp & {}::={} &
      \cursor{\tau}
      \mid \tArrow{G}{\Z{\tau}}{\tau}
      \mid \tArrow{G}{\tau}{\Z{\tau}}
      \mid \conflictHole{\Z{\tau}, \SetOf{\tau_i}_{i \leq n}}
    \\
  \end{array}
\]

Let $\Z{\Set} = (\Set, \Z{t})$ denote a set of terms paired with a zippered term.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Groves}

\begin{gather*}
  \arraycolsep=0pt
  \begin{array}{lll}
    \Z{\gamma} & {}::={} &
      (\Z{\Set}_{NP}, \Set[MP], \Set[U])
      \mid (\Set[NP], \Z{\Set}_{MP}, \Set[U])
      \mid (\Set[NP], \Set[MP], \Z{\Set}_U)
  \end{array}
\end{gather*}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Cursor Erasure}\hspace*{\fill} \\

\noindent $\boxed{\erase{\Z{\gamma}} = \gamma}$
%
\begin{align*}
  \erase{(\Z{\Set}_{NP}, \Set[MP], \Set[U])} &= (\erase{\Z{\Set}_{NP}}, \Set[MP], \Set[U]) \\
  \erase{(\Set[NP], \Z{\Set}_{MP}, \Set[U])} &= (\Set[NP], \erase{\Z{\Set}_{MP}}, \Set[U]) \\
  \erase{(\Set[NP], \Set[MP], \Z{\Set}_U)} &= (\Set[NP], \Set[MP], \erase{\Z{\Set}_U})
\end{align*}

\noindent $\boxed{\erase{\Z{\Set}} = \Set}$
%
\begin{align*}
  \erase{(\Set, \Z{t})} &= \Set \cup \SetOf{t}
\end{align*}

\noindent $\boxed{\erase{\Z{e}} = e}$
%
\begin{align*}
  \erase{\cursor{e}} &= e \\
  \erase{\left(\eFun{G}{\Z{q}}{\tau}{e}\right)} &= \eFun{G}{\erase{\Z{q}}}{\tau}{e} \\
  \erase{\left(\eFun{G}{q}{\Z{\tau}}{e}\right)} &= \eFun{G}{q}{\erase{\Z{\tau}}}{e} \\
  \erase{\left(\eFun{G}{q}{\tau}{\Z{e}}\right)} &= \eFun{G}{q}{\tau}{\erase{\Z{e}}} \\
  \erase{\eApp{G}{\Z{e}_1}{e_2}} &= \eApp{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eApp{G}{e_1}{\Z{e}_2}} &= \eApp{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\ePlus{G}{\Z{e}_1}{e_2}} &= \ePlus{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\ePlus{G}{e_1}{\Z{e}_2}} &= \ePlus{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\eTimes{G}{\Z{e}_1}{e_2}} &= \eTimes{G}{\erase{\Z{e}_1}}{e_2} \\
  \erase{\eTimes{G}{e_1}{\Z{e}_2}} &= \eTimes{G}{e_1}{\erase{\Z{e}_2}} \\
  \erase{\conflictHole{\Z{e}, \SetOf{e_i}_{i \leq n}}} &= \conflictHole{\erase{\Z{e}}, \SetOf{e_i}_{i \leq n}}
\end{align*}

\noindent $\boxed{\erase{\Z{q}} = q}$
%
\begin{align*}
  \erase{\cursor{q}} &= q \\
  \erase{\conflictHole{\Z{q}, \SetOf{q_i}_{i \leq n}}} &= \conflictHole{\erase{\Z{q}}, \SetOf{q_i}_{i \leq n}}
\end{align*}

\noindent $\boxed{\erase{\Z{\tau}} = \tau}$
%
\begin{align*}
  \erase{\cursor{\tau}} &= \tau \\
  \erase{\left(\tArrow{G}{\Z{\tau}_1}{\tau_2}\right)} &= \tArrow{G}{\erase{\Z{\tau}_1}}{\tau_2} \\
  \erase{\left(\tArrow{G}{\tau_1}{\Z{\tau}_2}\right)} &= \tArrow{G}{\tau_1}{\erase{\Z{\tau}_2}} \\
  \erase{\conflictHole{\Z{\tau}, \SetOf{\tau_i}_{i \leq n}}} &= \conflictHole{\erase{\Z{\tau}}, \SetOf{\tau_i}_{i \leq n}}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\begin{theorem}[Sensibility]
  For any zippered grove $\Z{\Grove}$
  such that $\erase{\Z{\Grove}}$ is well sorted
    and $\recomp{\erase{\Z{\Grove}}} = G$,
  and any user action $\alpha$,
  if
  \[
    \applyAction{\Z{\Grove}}{\alpha}{a^{*}},
  \]
  then $G \action{a^{*}} G'$ and $G'$ is well sorted.
\end{theorem}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} &
      \Construct{k}
      \mid \Delete
      \mid \Reposition{v}{p}
    \\
  \end{array}
\]

\noindent $\boxed{\Z{\Grove} \action{\alpha} a^{*}}$
%
\begin{mathpar}
  \inferrule{
    \Z{\Set}_{NP} \action{\alpha} a^{*}
  }{
    (\Z{\Set}_{NP}, \Set[MP], \Set[U]) \action{\alpha} a^{*}
  }

  \inferrule{
    \Z{\Set}_{MP} \action{\alpha} a^{*}
  }{
    (\Set[NP], \Z{\Set}_{MP}, \Set[U]) \action{\alpha} a^{*}
  }

  \inferrule{
    \Z{\Set}_U \action{\alpha} a^{*}
  }{
    (\Set[NP], \Set[MP], \Z{\Set}_U) \action{\alpha} a^{*}
  }
\end{mathpar}

\noindent $\boxed{\Z{\Set} \action{\alpha} a^{*}}$
%
\begin{mathpar}
  \inferrule{
    \Z{t} \action{\alpha} a^{*}
  }{
    (\Set, \Z{t}) \action{\alpha} a^{*}
  }
\end{mathpar}

\noindent $\boxed{\applyAction{\Z{t}}{\alpha}{a^{*}}}$
%
\begin{mathpar}
  \inferrule[ConstructWrap]{
    \sources{G_t} = \SetOf{(v_{s_i}, p_{s_i})}_{i \leq n} \\
    \defaultpos{k} = p_k \\
    \sort{k} = \sort{k_{G_t}} \\
    (p_k, \sort{k_{G_t}}) \in \arity{k}
  }{
    \applyAction{
      \cursor{t}
    }{\Construct{k}}{
      \SequenceOf{\graphAction{\Minus}{\e}}_{\e \in \edges{G_t}};
      \SequenceOf{\graphAction{\Plus}{(\fresh{u}_{s_i}, v_{s_i}, p_{s_i}, v_k{=}(\fresh{u}_k, k))}}_{i \leq n};
      \graphAction{\Plus}{(\fresh{u}, v_k, p_k, v_{G_t})}
    }
  }

  \inferrule[ConstructConflict]{
    \sources{G_t} = \SetOf{(v_{s_i}, p_{s_i})}_{i \leq n} \\
    \defaultpos{k} \text{ undefined} \\
    \sort{k} = \sort{k_{G_t}}
  }{
    \applyAction{
      \cursor{t}
    }{\Construct{k}}{
      \SequenceOf{\graphAction{\Plus}{(\fresh{u}_{s_i}, v_{s_i}, p_{s_i}, (\fresh{u}_k, k))}}_{i \leq n}
    }
  }

  \inferrule[Construct]{
    (p_s, \sort{k}) \in \arity{k_s}
  }{
    \applyAction{
      \cursor{\emptyHole{v_s{=}(u_s, k_s)}{p_s}}
    }{\Construct{k}}{
      \graphAction{\Plus}{(\fresh{u}, v_s, p_s, (\fresh{u}_k, k))}
    }
  }

  \inferrule[Delete]{
    \edges{G_t} = \SetOf{\e_i}_{i \leq n}
  }{
    \applyAction{
      \cursor{t}
    }{\Delete}{
      \SequenceOf{\graphAction{\Minus}{\e_i}}_{i \leq n}
    }
  }

  \inferrule[Reposition]{
    \edges{G_t} = \SetOf{\e_i}_{i \leq n} \\
    (p, \sort{k_{G_t}}) \in \arity{k}
  }{
    \applyAction{
      \cursor{t}
    }{\Reposition{v{=}(u, k)}{p}}{
      \SequenceOf{\graphAction{\Minus}{\e_i}}_{i \leq n};
      \graphAction{\Plus}{(\fresh{u}, v, p, v_{G_t})}
    }
  }

  \inferrule[Conflict]{
    \SetOf{\applyAction{\cursor{t_i}}{\alpha}{a_i^{*}}}_{i \leq n}
  }{
    \applyAction{
      \cursor{\conflictHole{t_i}_{i \leq n}}
    }{\alpha}{
      \SequenceOf{a_i^{*}}_{i \leq n}
    }
  }
\end{mathpar}
%
\begin{mathpar}
  \inferrule{
    \applyAction{
      \Z{q}
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\eFun{G}{\Z{q}}{\tau}{e})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{\tau}
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\eFun{G}{q}{\Z{\tau}}{e})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{e}
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\eFun{G}{q}{\tau}{\Z{e}})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{e}_1
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      \eApp{G}{\Z{e}_1}{e_2}
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{e}_2
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      \eApp{G}{e_1}{\Z{e}_2}
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{e}_1
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\ePlus{G}{\Z{e}_1}{e_2})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{e}_2
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\ePlus{G}{e_1}{\Z{e}_2})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{e}_1
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\eTimes{G}{\Z{e}_1}{e_2})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{e}_2
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\eTimes{G}{e_1}{\Z{e}_2})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{\tau}_1
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\tArrow{G}{\Z{\tau}_1}{\tau_2})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{\tau}_2
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      (\tArrow{G}{\tau_1}{\Z{\tau}_2})
    }{
      \alpha
    }{
      a^{*}
    }
  }

  \inferrule{
    \applyAction{
      \Z{t}
    }{
      \alpha
    }{
      a^{*}
    }
  }{
    \applyAction{
      \conflictHole{\Z{t}, \SetOf{t_i}_{i \leq n}}
    }{
     \alpha
    }{
      a^{*}
    }
  }
\end{mathpar}
