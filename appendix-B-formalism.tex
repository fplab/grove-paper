\section{Formalism}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Syntax}

\figureTermSyntaxContent

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a function from edges to edge states,
  where $\E = \U \times \V \times \P \times \V$,
  unique IDs are drawn from some suitable set $\U$ equipped with a total ordering $\leq$,
  vertices are drawn from $\V$,
  positions are drawn from $\P$,
  and edge states are drawn from $\Sigma$.
\end{definition}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\figureArityContent

\begin{definition}
  Let $\e = (u, (u_1, k_1), p, (u_2, k_2))$.
  A graph $G$ is well sorted if $(p, \sort(k_2)) \in \arity(k_1)$
  for all $\e$ such that $G(\e) \in \{\Plus, \Minus\}$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

\begin{theorem}
  Let $G$ be a well sorted graph with deleted edges $D \subset \E$.
  There exists a grove $\Grove$ such that $\decomp{G} = (\Grove, D)$.
\end{theorem}

Proof: provide a witness that demonstrates the conclusion.

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\decomp{G} = \Grove$ then $\vertexes{G} = \vertexes{\Grove}$.
% \end{theorem}

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\recomp{\Grove} = G$ then $\vertexes{\Grove} = \vertexes{G}$.
% \end{theorem}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Helpers}

\figureDecompositionDefHelpersContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}\hspace*{\fill} \\

\noindent $\boxed{\decomp{G} = (\Grove, \E)}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\edecomp{v} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\pdecomp{v} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\tdecomp{v} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\edecompPrime{v}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecompPrime{v}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecompPrime{v}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  Let $G$ be a well sorted graph with deleted edges $D \subset \E$
  such that $\decomp{G} = (\Grove, D)$. Then $\recomp{\Grove}{D} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove}{\E} = G}$
%
\begin{align*}
  \recomp{(NP, MP, U)}{D} &= \recompPlus{NP, MP, U} \cup \SetOf{\e \mapsto \Minus \SuchThat{\e \in D}}
\end{align*}

\noindent $\boxed{\recompPlus{NP, MP, U} = G}$
%
\begin{align*}
  \recompPlus{NP, MP, U} &= \SetOf{\e \mapsto \Plus \SuchThat{\e \in \bigcup_{e \in NP \cup MP \cup U} \erecomp{e}}}
\end{align*}

\noindent $\boxed{\erecomp{e} = \E}$
%
\begin{align*}
  \erecomp{\varExp{x}{u}} &= \SetOf{}
  \\
  \erecomp{\numExp{n}{u}} &= \SetOf{}
  \\
  \erecomp{\appExp{e_\AppFun}{e_\AppArg}{u}}
  &= \erecomp{e_\AppFun}
  \cup \erecomp{e_\AppArg} \\
  &\cup \erecompPrime{v}{\AppFun}{e_\AppFun}
  \cup \erecompPrime{v}{\AppArg}{e_\AppArg} \\
  &\quad\text{where } v = (u, \ExpApp)
  \\
  \erecomp{\plusExp{e_\PlusLeft}{u}{e_\PlusRight}}
  &= \erecomp{e_\PlusLeft}
  \cup \erecomp{e_\PlusRight} \\
  &\cup \erecompPrime{v}{\PlusLeft}{e_\PlusLeft}
  \cup \erecompPrime{v}{\PlusRight}{e_\PlusRight} \\
  &\quad\text{where } v = (u, \ExpPlus)
  \\
  \erecomp{\lamExp{u}{q_\LamParam}{\tau_\LamType}{e_\LamBody}}
  &= \precomp{q_\LamParam}
  \cup \trecomp{\tau_\LamType}
  \cup \erecomp{e_\LamBody} \\
  &\cup \precompPrime{v}{\LamParam}{q_\LamParam}
  \cup \trecompPrime{v}{\LamType}{\tau_\LamType} \\
  &\cup \erecompPrime{v}{\LamBody}{e_\LamBody} \\
  &\quad\text{where } v = (u, \ExpLam)
  \\
  \erecomp{\hole} &= \SetOf{}
  \\
  \erecomp{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{k=1}^n \erecomp{e_k}
  \\
  \erecomp{\multiVertex{v}} &= \SetOf{}
  \\
  \erecomp{\cycleVertex{v}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\erecompPrime{v}{p}{e} = \E}$
%
\begin{align*}
  \erecompPrime{v}{p}{\varExp{x}{u}}
  &= \SetOf{(u', v, p, (u, \ExpVar(x)))}
  \\
  \erecompPrime{v}{p}{\numExp{n}{u}}
  &= \SetOf{(u', v, p, (u, \ExpNum(n)))}
  \\
  \erecompPrime{v}{p}{\appExp{e_\AppFun}{e_\AppArg}{u}}
  &= \SetOf{(u', v, p, (u, \ExpApp))}
  \\
  \erecompPrime{v}{p}{\plusExp{e_\PlusLeft}{u} {e_\PlusRight}}
  &= \SetOf{(u', v, p, (u, \ExpPlus))}
  \\
  \erecompPrime{v}{p}{\lamExp{u}{q_\LamParam}{\tau_\LamType}{e_\LamBody}}
  &= \SetOf{(u', v, p, (u, \ExpLam))}
  \\
  \erecompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \erecompPrime{v}{p}{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \erecompPrime{v}{p}{e_i}
  \\
  \erecompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \erecompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\precomp{q} = \E}$
%
\begin{align*}
  \precomp{\varPat{x}{u}} &= \SetOf{}
  \\
  \precomp{\hole} &= \SetOf{}
  \\
  \precomp{\conflictHole{q_1, \cdots, q_n}}
  &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{v}} &= \SetOf{}
  \\
  \precomp{\cycleVertex{v}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\precompPrime{v}{p}{q} = \E}$
%
\begin{align*}
  \precompPrime{v}{p}{\varPat{x}{u}}
  &= \SetOf{(u', v, p, (u, \PatVar(x)))}
  \\
  \precompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \precompPrime{v}{p}{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \precompPrime{v}{p}{e_i}
  \\
  \precompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \precompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\trecomp{\tau} = \E}$
%
\begin{align*}
  \trecomp{\arrowTyp{\tau_\ArrowArg}{u}{\tau_\ArrowResult}}
  &= \trecomp{\tau_\ArrowArg}
  \cup \trecomp{\tau_\ArrowResult} \\
  &\cup \trecompPrime{v}{\ArrowArg}{\tau_\ArrowArg}
  \cup \trecompPrime{v}{\ArrowResult}{\tau_\ArrowResult} \\
  &\quad\text{where } v = (u, \TypArrow)
  \\
  \trecomp{\numTyp{u}} &= \SetOf{}
  \\
  \trecomp{\hole} &= \SetOf{}
  \\
  \trecomp{\conflictHole{\tau_1, \cdots, \tau_n}}
  &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{u}} &= \SetOf{}
  \\
  \trecomp{\cycleVertex{u}} &= \SetOf{}
\end{align*}
%
% \vskip\baselineskip
$\boxed{\trecompPrime{v}{p}{\tau} = \E}$
%
\begin{align*}
  \trecompPrime{v}{p}{\arrowTyp{\tau_\ArrowArg}{u}{\tau_\ArrowResult}}
  &= \SetOf{(u', v, p, (u, \TypArrow)))}
  \\
  \trecompPrime{v}{p}{\numTyp{u}}
  &= \SetOf{(u', v, p, (u, \TypNum)))}
  \\
  \trecompPrime{v}{p}{\hole} &= \SetOf{}
  \\
  \trecompPrime{v}{p}{\conflictHole{\tau_1, \cdots, \tau_n}}
  &= \bigcup_{i=1}^n \trecompPrime{v}{p}{\tau_i}
  \\
  \trecompPrime{v}{p}{\multiVertex{v'}}
  &= \SetOf{(u', v, p, v')}
  \\
  \trecompPrime{v}{p}{\cycleVertex{v'}}
  &= \SetOf{(u', v, p, v')}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} & \Create{k} \mid \Delete \mid \Restore{v} \\
    %  \mid \Drop{\e}
  \end{array}
\]

\begin{align*}
  \Wrap{k, q} &= \Delete; v=\Create{k}; \Restore{v, q} \\
  \Reposition{v, q} &= \Delete; \Restore{v, q} \\
\end{align*}
%
where $v$ is the destination vertex implied by the cursor, when it exists.
When no such vertex exists, $\Restore{v}$ is a no-op.