\section{Formalism}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Terms}

\figureTermSyntaxContent

\noindent $\boxed{\constructor{t} = k}$
%
\begin{align*}
  \constructor{e} &= \econstructor{e} \\
  \constructor{p} &= \pconstructor{p} \\
  \constructor{\tau} &= \tconstructor{\tau}
\end{align*}

\noindent $\boxed{\econstructor{e} = k}$
%
\begin{align*}
  \econstructor{\eVar{G}{x}} &= \ExpVar(x) \\
  \econstructor{\eFun{G}{q}{\tau}{e}} &= \ExpLam \\
  \econstructor{\eApp{G}{e_1}{e_2}} &= \ExpApp \\
  \econstructor{\eNum{G}{n}} &= \ExpNum(n) \\
  \econstructor{\ePlus{G}{e_1}{e_2}} &= \ExpPlus \\
  \econstructor{\eTimes{G}{e_1}{e_2}} &= \ExpTimes
\end{align*}

\noindent $\boxed{\pconstructor{q} = k}$
%
\begin{align*}
  \pconstructor{\pVar{G}{x}} &= \PatVar(x)
\end{align*}

\noindent $\boxed{\tconstructor{\tau} = k}$
%
\begin{align*}
  \tconstructor{\tArrow{G}{\tau_1}{\tau_2}} &= \TypArrow \\
  \tconstructor{\tNum{G}} &= \TypNum
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graphs}

Let $t$ denote a term and $\Set$ a set of terms.

\begin{definition}
  A \emph{graph} $G : \E \rightarrow \Sigma$ is a function from edges to edge states,
  where $\E = \U \times \V \times \P \times \V$,
  unique IDs are drawn from some suitable set $\U$ equipped with a total ordering $\leq$,
  vertices are drawn from $\V$,
  positions are drawn from $\P$,
  and edge states are drawn from $\Sigma$.
\end{definition}

Let $G_t$, called the \emph{in-graph} of term $t$,
denote the outermost graph produced by $\ingraphOp$ in the construction of term $t$,
when such a graph exists.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Well-sortedness}

\figureArityContent

\begin{definition}
  A graph $G$ is well sorted if $\e$ is well sorted
  for all edges $\e$ such that $G(\e) \in \{\Plus, \Minus\}$.
\end{definition}

\begin{definition}
  An edge $\e = (u, (u_1, k_1), p, (u_2, k_2))$ is well sorted
  if $(p, \sort(k_2)) \in \arity(k_1)$.
\end{definition}

\begin{definition}
  A grove $\Grove = (\Set[NP], \Set[MP], \Set[U])$ is well sorted if all of the following hold:
  \begin{enumerate}
    \item
      The terms of $\Set[NP], \Set[MP],$ and $\Set[U]$ are well sorted.
      % ($\Set[NP]$, $\Set[MP]$, and $\Set[U]$ contain only well sorted terms.)
    \item
      Either $\Set[NP] = \varnothing$
      or there exists an $e \in \Set[NP]$ such that
      $\SizeOf{\SetOf{\e{=}(\rootVertex, \Root, v) \SuchThat{G_e(\e) = \Plus}}} = 1$ and
      $\SizeOf{\SetOf{\e'{=}(\rootVertex, \Root, v) \neq e \SuchThat{G_{e'} = \Plus}}} = 0$.
      % (Exactly one of the terms in $\Set[NP]$, if any,
      % corresponds to an edge originating from $\rootVertex$.)
    \item
      For all $t \in \Set[NP]$,
        $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} = 0$.
      % (The terms in $\Set[NP]$ correspond to vertices with no parents.)
    \item
      For all $t \in \Set[MP]$,
        $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} > 1$ and
        $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Minus}}} = 0$.
      % (The terms in $\Set[MP]$ correspond to vertices with multiple parents.)
    \item
      For all $t \in \Set[U]$,
      and all $\e{=}(v, p, v')$ such that $G_t(\e) \in \SetOf{\Plus, \Minus}$,
        $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} = 1$ and
        $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Minus}}} = 0$ and
        $v' = \min{\ancestors{v'}}$.
      % (The terms in $\Set[U]$ correspond to vertices that are unicycle roots.)
  \end{enumerate}
\end{definition}

\begin{definition}
  A term $t$ is well sorted if one of the following holds:
  \begin{enumerate}
    \item $t = \hole$.
    \item $t = \conflictHole{t_1, \ldots, t_n}$ and $t_1, \ldots, t_n$ are well sorted.
    \item $t = \multiVertex{\e}$ and all of the following hold:
      \begin{enumerate}
        \item $\e$ is well sorted.
        \item
          $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) = \Plus}}} > 1$.
          % all multiparent references refer to a multiparent root
          % (TODO: do we need this? be careful with wording)
      \end{enumerate}
    \item $t = \cycleVertex{(v, p, v')}$ and all of the following hold:
      \begin{enumerate}
        \item $(v, p, v')$ is well sorted.
        \item $v' = \min{\ancestors{v'}}$
        \item
          For all $\e{=}(v_{\e}, p_{\e}, v_{\e}')$
          such that $v_{\e}' \in \ancestors{v'}$,
          $\SizeOf{\parents{v_{\e}'}} = 1$.
          % all unicycle references refer to a unicycle root
          % (TODO: do we need this? be careful with wording.
          % Could try to reconstruct the path from root (referenced) to ref (referencer).)
      \end{enumerate}
    \item Otherwise, $G_t$ exists and all of the following hold:
    \begin{enumerate}
      \item
      $G_t$ is well sorted.
      % all incoming edges are well sorted
      \item
      $\SizeOf{\SetOf{\e \SuchThat{G_t(\e) \in \SetOf{\Plus, \Minus}}}} \geq 1$.
      % The in-graph of t is not empty.
    \item
      For all $\e{=}(v, p, v')$ such that $G_t(\e) \in \SetOf{\Plus, \Minus}$,
      $v' = (u, \constructor{t})$ fixed.
      % All term constructors match their corresponding target vertex constructors.
      % The ids of the target vertices of all incoming edges are the same.
    \end{enumerate}
  \end{enumerate}
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decomposition and Recomposition}

\begin{theorem}
  For any well sorted graph $G$,
  there exists a (well sorted) grove $\Grove$
  such that $\decomp{G} = \Grove$.
\end{theorem}

Proof: provide a witness that demonstrates the conclusion.

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\decomp{G} = \Grove$ then $\vertexes{G} = \vertexes{\Grove}$.
% \end{theorem}

% \begin{theorem}
%   Let $G$ be a well sorted graph.
%   If $\recomp{\Grove} = G$ then $\vertexes{\Grove} = \vertexes{G}$.
% \end{theorem}

\figureDecompositionDefHelpersContent

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Decomposition}\hspace*{\fill} \\

\noindent $\boxed{\decomp{G} = \Grove}$
%
\figureDecompositionDefDecomp

\noindent $\boxed{\edecomp{\e} = e}$
%
\figureDecompositionDefEdecomp

\noindent $\boxed{\pdecomp{\e} = q}$
%
\figureDecompositionDefPdecomp

\noindent $\boxed{\tdecomp{\e} = \tau}$
%
\figureDecompositionDefTdecomp

\noindent $\boxed{\edecompPrime{\e}{p} = e}$
%
\figureDecompositionDefEdecompPrime

\noindent $\boxed{\pdecompPrime{\e}{p} = q}$
%
\figureDecompositionDefPdecompPrime

\noindent $\boxed{\tdecompPrime{\e}{p} = \tau}$
%
\figureDecompositionDefTdecompPrime%

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Recomposition}\hspace*{\fill} \\

\begin{theorem}
  If $G$ is a well sorted graph such that $\decomp{G} = \Grove$,
  then $\recomp{\Grove} = G$.
\end{theorem}

\noindent $\boxed{\recomp{\Grove} = G}$
%
\begin{align*}
  \recomp{(\Set[NP], \Set[MP], \Set[U])} &= \bigcup_{e \in \Set[NP] \cup \Set[MP] \cup \Set[U]} \erecomp{e}
\end{align*}

\noindent $\boxed{\erecomp{e} = G}$
%
\begin{align*}
  \erecomp{\eVar{G}{x}} &= G
  \\
  \erecomp{\eFun{G}{q}{\tau}{e}}
    &= G \cup \precomp{q} \cup \trecomp{\tau} \cup \erecomp{e}
  \\
  \erecomp{\eApp{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eNum{G}{n}} &= G
  \\
  \erecomp{\ePlus{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\eTimes{G}{e_1}{e_2}}
    &= G \cup \erecomp{e_1} \cup \erecomp{e_2}
  \\
  \erecomp{\conflictHole{e_1, \cdots, e_n}}
  &= \bigcup_{i=1}^n \erecomp{e_i}
  \\
  \erecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \erecomp{\hole} &= \SetOf{}
\end{align*}

\noindent $\boxed{\precomp{q} = G}$
%
\begin{align*}
  \precomp{\pVar{G}{x}} &= G
  \\
  \precomp{\conflictHole{q_1, \cdots, q_n}} &= \bigcup_{i=1}^n \precomp{q_i}
  \\
  \precomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \precomp{\hole} &= \SetOf{}
\end{align*}

\noindent $\boxed{\trecomp{\tau} = G}$
%
\begin{align*}
  \trecomp{\tArrow{G}{\tau_1}{\tau_2}}
    &= G \cup \trecomp{\tau_1} \cup \trecomp{\tau_2}
  \\
  \trecomp{\tNum{G}} &= G
  \\
  \trecomp{\conflictHole{\tau_1, \cdots, \tau_n}} &= \bigcup_{i=1}^n \trecomp{\tau_i}
  \\
  \trecomp{\multiVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\cycleVertex{\e}} &= \SetOf{\e \mapsto \Plus}
  \\
  \trecomp{\hole} &= \SetOf{}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Cursors}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Terms}

\[
  \arraycolsep=0pt
  \begin{array}{lrlll}
    \hat{e} & {}\in ZExp & {}::={} &
      \cursor{e}
      \mid \eFun{G}{\hat{q}}{\tau}{e}
      \mid \eFun{G}{q}{\hat{\tau}}{e}
      \mid \eFun{G}{q}{\tau}{\hat{e}}
      \mid \eApp{G}{\hat{e}}{e}
      \mid \eApp{G}{e}{\hat{e}}
      \mid \ePlus{G}{\hat{e}}{e}
      \mid \ePlus{G}{e}{\hat{e}}
      \mid \eTimes{G}{\hat{e}}{e}
      \mid \eTimes{G}{e}{\hat{e}}
    \\
    \hat{\tau} & {}\in ZTyp & {}::={} &
      \cursor{\tau}
      \mid \tArrow{G}{\hat{\tau}}{\tau}
      \mid \tArrow{G}{\tau}{\hat{\tau}}
    \\
    \hat{q} & {}\in ZPat & {}::={} &
      \cursor{q}
    \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Zippered Groves}

\begin{gather*}
  \arraycolsep=0pt
  \begin{array}{lll}
    \hat{\gamma} & {}::={} &
      (\hat{NP}, MP, U)
      \mid (NP, \hat{MP}, U)
      \mid (NP, MP, \hat{U})
  \end{array} \\
  \hat{NP}, \hat{MP}, \hat{U} = \SetOf{e_1, \ldots, e_{k-1}, \hat{e_k}, e_{k+1}, \ldots, e_n} \\
  \qquad 1 \leq k \leq n
\end{gather*}

(Exactly one of $NP, MP, U$ may contain a single zippered term.)

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsubsection{Cursor Erasure}\hspace*{\fill} \\

\noindent $\boxed{\erase{\hat{\gamma}} = \gamma}$
%
\begin{align*}
  \erase{(\hat{NP}, MP, U)} &= (\erase{\hat{NP}}, MP, U) \\
  \erase{(NP, \hat{MP}, U)} &= (NP, \erase{\hat{MP}}, U) \\
  \erase{(NP, MP, \hat{U})} &= (NP, MP, \erase{\hat{U}})
\end{align*}

\noindent $\boxed{\erase{\left(Exp \cup ZExp\right)} = Exp}$
%
\begin{align*}
  \erase{\SetOf{e_1, \ldots, e_{k-1}, \hat{e_k}, e_{k+1}, \ldots, e_n}} &= \SetOf{e_1, \ldots, e_{k-1}, \erase{\hat{e_k}}, e_{k+1}, \ldots, e_n}
\end{align*}

\noindent $\boxed{\erase{\hat{e}} = e}$
%
\begin{align*}
  \erase{\cursor{e}} &= e \\
  \erase{\left(\eFun{G}{\hat{q}}{\tau}{e}\right)} &= \eFun{G}{\erase{\hat{q}}}{\tau}{e} \\
  \erase{\left(\eFun{G}{q}{\hat{\tau}}{e}\right)} &= \eFun{G}{q}{\erase{\hat{\tau}}}{e} \\
  \erase{\left(\eFun{G}{q}{\tau}{\hat{e}}\right)} &= \eFun{G}{q}{\tau}{\erase{\hat{e}}} \\
  \erase{\eApp{G}{\hat{e_1}}{e_2}} &= \eApp{G}{\erase{\hat{e_1}}}{e_2} \\
  \erase{\eApp{G}{e_1}{\hat{e_2}}} &= \eApp{G}{e_1}{\erase{\hat{e_2}}} \\
  \erase{\ePlus{G}{\hat{e_1}}{e_2}} &= \ePlus{G}{\erase{\hat{e_1}}}{e_2} \\
  \erase{\ePlus{G}{e_1}{\hat{e_2}}} &= \ePlus{G}{e_1}{\erase{\hat{e_2}}} \\
  \erase{\eTimes{G}{\hat{e_1}}{e_2}} &= \eTimes{G}{\erase{\hat{e_1}}}{e_2} \\
  \erase{\eTimes{G}{e_1}{\hat{e_2}}} &= \eTimes{G}{e_1}{\erase{\hat{e_2}}}
\end{align*}

\noindent $\boxed{\erase{\hat{\tau}} = \tau}$
%
\begin{align*}
  \erase{\cursor{\tau}} &= \tau \\
  \erase{\left(\tArrow{G}{\hat{\tau_1}}{\tau_2}\right)} &= \tArrow{G}{\erase{\hat{\tau_1}}}{\tau_2} \\
  \erase{\left(\tArrow{G}{\tau_1}{\hat{\tau_2}}\right)} &= \tArrow{G}{\tau_1}{\erase{\hat{\tau_2}}}
\end{align*}

\noindent $\boxed{\erase{\hat{q}} = q}$
%
\begin{align*}
  \erase{\cursor{q}} &= q
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Actions}

\[
  \arraycolsep=0pt
  \begin{array}{llll}
    \alpha & {}::={} &
      \Construct{k}
      \mid \Delete
      \mid \Reposition{v, p}
    \\
  \end{array}
\]

% \noindent $\boxed{\hat{e} \aArrow{\alpha} \hat{e}}}$
% %
% \begin{align*}
%   \
% \end{align*}

% Cases:
% \begin{itemize}
%   \item construct @ hole (create current edge)
%   \item construct @ conflict (create new edge into conflict ??)
%   \item construct @ non-hole (wrap current edge)
%   \item delete @ hole (no-op)
%   \item delete @ conflict (destroy all edges ??)
%   \item delete @ non-hole (destroy current edge)
%   \item reposition @ hole (no-op)
%   \item reposition @ conflict (???)
%   \item reposition @ non-hole (destroy current edge and create new edge with same destination vertex)
% \end{itemize}
