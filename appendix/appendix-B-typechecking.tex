\section{Representation of terms}
\label{sec:marked-calculus}

\subsection{Syntax}
\[
\begin{array}{lllll}
     \EMV \in & \EMName & \Coloneqq & 
        \var{x}
        \mid \num 
        \mid \plus{\ELV_1}{\ELV_2} 
        \mid \mult{\ELV_1}{\ELV_2}
        \mid \lam{x}{\TLMV}{\ELV}
        \mid \app{\ELV_1}{\ELV_2}
        \mid \multiref
        \mid \uniref \\
     \ELV \in & \ELMName & \Coloneqq & 
        \ehole
        \mid \lexp{\EMV} 
        \mid \conflict{\EMV} \\
     \ECMV \in & \ECMName & \Coloneqq &
        \var{x}
        \mid \num
        \mid \plus{\ELMV_1}{\ELMV_2}
        \mid \mult{\ELMV_1}{\ELMV_2}
        \mid \lam{x}{\TLMV}{\ELV}
        \mid \app{\ELMV_1}{\ELMV_2}
        \mid \multiref
        \mid \uniref \\ 
        & & & \ECFree{\var{x}} 
        \mid \incontype
        \mid \lamasc
        \mid \lamanamarr
        \mid \apsynmarr \\ 
        % \mid \lamge \\
     \ELMV \in & \ELMName & \Coloneqq &
        \ehole
        \mid \lexp{\ECMV}
        \mid \conflict{\ECMV} \\

    \TMV \in & \TMName & \Coloneqq & 
        \tnum 
        \mid \tarrow 
        \mid \multiref 
        \mid \uniref \\ 
    \TLMV \in & \TLMName & \Coloneqq &
        \ehole
        \mid \lexp{\TMV}
        \mid \conflict{\TMV} \\
    \STMV \in & \STMName & \Coloneqq & 
        \TUnknown
        \mid \tNum{}
        \mid \starrow \\
    \Provp \in & \Prov & \Coloneqq &
        (v, p) \mid \mathsf{exp}(v, p) \mid \rightarrow_L(\Provp) \mid \rightarrow_R(\Provp)
\end{array}
\]

\subsection{Types}

\judgbox{\graphErase{\TMV} = \STMV} $\TMV$ erases to $\STMV$
%
\begin{mathpar}
    \inferrule[GENum]{ }{
        \graphErase{\tnum} = \tNum{}
    }
    
    \inferrule[GEArr]{
        \graphErase{\TMV_1} = \STMV_1 \\
        \graphErase{\TMV_2} = \STMV_2
    }{
        \graphErase{\tarrow} = \starrow
    }
    
    \inferrule[GEMultiParent]{ }{ 
        \graphErase{\multiref{v}} = \TUnknown
    }

    \inferrule[GEUnicycle]{ }{ 
        \graphErase{\uniref} = \TUnknown
    }
\end{mathpar}

\judgbox{\graphErase{\TLMV} = \STMV} $\TLMV$ graph erases to $\STMV$
%
\begin{mathpar}
    \inferrule[GEHole]{ }{
        \graphErase{\ehole} = \TUnknown
    }
    
    \inferrule[GEExp]{
        \graphErase{\TMV} = \STMV
    }{ 
        \graphErase{\lexp{\TMV}} = \STMV
    }
    
    \inferrule[GEConflict]{ }{
        \graphErase{\conflict{\TMV}} = \TUnknown
    }
\end{mathpar}

\judgbox{\ensuremath{\consistent{\STMV_1}{\STMV_2}}} $\STMV_1$ is consistent with $\STMV_2$
%
\begin{mathpar}
  \inferrule[TCUnknown1]{ }{
    \consistent{\TUnknown}{\STMV}
  }

  % \inferrule[TCUnknown2]{ }{
  %   \consistent{\TMV}{\TUnknown}
  % }

  % \inferrule[TCRefl]{ }{
  %   \consistent{\TMV}{\TMV}
  % }

  % \inferrule[TCArr]{
  %   \consistent{\TMV_1}{\TMV_1'} \\
  %   \consistent{\TMV_2}{\TMV_2'} \\
  % }{
  %   \consistent{\TArrow{\TMV_1}{\TMV_2}}{\TArrow{\TMV_1'}{\TMV_2'}}
  % }

  % \inferrule[TCProd]{
  %   \consistent{\TMV_1}{\TMV_1'} \\
  %   \consistent{\TMV_2}{\TMV_2'} \\
  % }{
  %   \consistent{\TProd{\TMV_1}{\TMV_2}}{\TProd{\TMV_1'}{\TMV_2'}}
  % }
\end{mathpar} \\

\subsection{Unmarked expressions}
\label{sec:marked-unmarked-expressions}
\judgbox{\ctxSynTypeU{\ctx}{\EMV}{\STMV}} $\EMV$ synthesizes type $\STMV$
%
\begin{mathpar}
  \inferrule[USVar]{
    \inCtx{\ctx}{\eVar{}{x}}{\STMV}
  }{
    \ctxSynTypeU{\ctx}{\var{x}}{\STMV}
  }

  \inferrule[USNum]{ }{
    \ctxSynTypeU{\ctx}{\num}{\tNum{}}
  }

  \inferrule[USLam]{
    \graphErase{\TLMV_1} = \STMV_1 \\
    \ctxSynTypeU{\extendCtx{\ctx}{x}{\STMV_1}}{\ELV}{\STMV_2}
  }{
    \ctxSynTypeU{\ctx}{\lam{x}{\TLMV_1}{\ELV}}{\starrow}
  }

  \inferrule[USAp]{
    \ctxSynTypeU{\ctx}{\ELV_1}{\STMV} \\
    \matchedArrow{\STMV}{\STMV_1}{\STMV_2} \\
    \ctxAnaTypeU{\ctx}{\ELV_2}{\STMV_1}
  }{
    \ctxSynTypeU{\ctx}{\app{\ELV_1}{\ELV_2}}{\STMV_2}
  }  

  \inferrule[USPlus]{
    \ctxAnaTypeU{\ctx}{\ELV_1}{\tNum{}} \\
    \ctxAnaTypeU{\ctx}{\ELV_2}{\tNum{}}
  }{
    \ctxSynTypeU{\ctx}{\plus{\ELV_1}{\ELV_2}}{\tNum{}}
  }

  \inferrule[USTimes]{
    \ctxAnaTypeU{\ctx}{\ELV_1}{\tNum{}} \\
    \ctxAnaTypeU{\ctx}{\ELV_2}{\tNum{}}
  }{
    \ctxSynTypeU{\ctx}{\mult{\ELV_1}{\ELV_2}}{\tNum{}}
  }

  \inferrule[USMultiLocation]{ }{
    \ctxSynTypeU{\ctx}{\multiref}{\TUnknown}
  }

  \inferrule[USCycleLocation]{ }
  {
    \ctxSynTypeU{\ctx}{\uniref}{\TUnknown} 
  }
  
\end{mathpar} \\

\judgbox{\ctxSynTypeU{\ctx}{\ELV}{\STMV}} $\ELV$ synthesizes type $\STMV$
%
\begin{mathpar}
    \inferrule[USHole]{ }{
        \ctxSynTypeU{\ctx}{\ehole}{\TUnknown}
    }

    \inferrule[USExp]{
        \ctxSynTypeU{\ctx}{\EMV}{\STMV}
    }{ 
        \ctxSynTypeU{\ctx}{\lexp{\EMV}}{\STMV}
    }
    
    \inferrule[USLocal]{
    }{
        \ctxSynTypeU{\ctx}{\conflict{\TMV}}{\TUnknown}
    }

\end{mathpar}

\judgbox{\ctxAnaTypeU{\ctx}{\EMV}{\STMV}} $\EMV$ analyzes against type $\STMV$
%
\begin{mathpar}
  \inferrule[UALam]{
    \graphErase{\TLMV} = \STMV \\
    \matchedArrow{\STMV_3}{\STMV_1}{\STMV_2} \\
    \consistent{\STMV}{\STMV_1} \\
    \ctxAnaTypeU{\extendCtx{\ctx}{x}{\STMV}}{\ELV}{\STMV_2}
  }{
    \ctxAnaTypeU{\ctx}{\reglam}{\STMV_3}
  }

  \inferrule[UASubsume]{
    \ctxSynTypeU{\ctx}{\EMV}{\STMV'} \\
    \consistent{\STMV}{\STMV'} \\
    \subsumable{\EMV}
  }{
    \ctxAnaTypeU{\ctx}{\EMV}{\STMV}
  }
\end{mathpar} \\

\judgbox{\ctxAnaTypeU{\ctx}{\ELV}{\STMV}} $\ELV$ analyzes against type $\STMV$
%
\begin{mathpar}
    \inferrule[ULASubsume]{ 
        \ctxSynTypeU{\ctx}{\ELV}{\STMV'} \\
        \consistent{\STMV}{\STMV'}
    }{ 
        \ctxAnaTypeU{\ctx}{\ELV}{\STMV}
    }
\end{mathpar}

\judgbox{\subsumable{\EMV}} $\EMV$ is subsumable
%
\begin{mathpar}
  \inferrule[USuVar]{ }{
    \subsumable{\eVar{u}{x}}
  }

  \inferrule[USuNum]{ }{
    \subsumable{\eNum{u}{n}}
  }

  \inferrule[USuPlus]{
  }{
    \subsumable{\plus{\ELV_1}{\ELV_2}}
  }

  \inferrule[USuTimes]{
  }{
    \subsumable{\mult{\ELV_1}{\ELV_2}}
  }

  \inferrule[USuAp]{
  }{
    \subsumable{\app{\ELV_1}{\ELV_2}}
  }

  \inferrule[USuMultiParent]{ }{
    \subsumable{\multiref}
  }

  \inferrule[USuUnicycle]{ }{
    \subsumable{\uniref}
  }
\end{mathpar}

\judgbox{\subsumable{\ELV}} $\ELV$ is subsumable
%
\begin{mathpar}
    \inferrule[USuHole]{ }{
        \subsumable{\emptyHole{v}{p}}
    }

    \inferrule[USuExp]{ }{
        \subsumable{\lexp{\EMV}}
    }

    \inferrule[USuConflict]{ }{
        \subsumable{\conflict{\EMV}}
    }
\end{mathpar}

\subsubsection{Constrained Matched Arrow}

\judgbox{\ensuremath{\matchedArrowConstraint{\STMV}{\STMV_1}{\STMV_2}{C}}} $\STMV$ has matched arrow type $\TArrow{\STMV_1}{\STMV_2}$ and generates constraints $C$
\begin{mathpar}
  \judgment{ }{
    \matchedArrowConstraint{\TUnknown^p}{\TUnknown^{\rightarrow_L(p)}}{\TUnknown^{\rightarrow_R(p)}}{\{ \TUnknown^p \approx \tarr{\TUnknown^{\rightarrow_L(p)}}{\TUnknown^{\rightarrow_R(p)}} \}}
  }{TMAHole-C}

  \judgment{ }{
    \matchedArrowConstraint{\TArrow{\STMV_1}{\STMV_2}}{\STMV_1}{\STMV_2}{\{\}}
  }{TMAArr-C}
\end{mathpar}


\subsubsection{Mode}
%
\[
\begin{array}{cc}
    m \in Mode \coloneqq & syn \mid ana(\STMV) \\
\end{array}
\]

\subsubsection{Local Info Mapping}

\judgbox{\Setof{(u,w,\ctx,m)}} 
%
$M$ is a set of 4-tuples of $u$ (vertex-IDs), $w$ (edge-IDs), \ctx and mode $m$

% \subsubsection{Meet of Types} 
% \judgbox{\meet{\STMV_1}{\STMV_2}}

% \[\begin{array}{ccr}
%     \meet{\STMV}{\TUnknown} & = & \STMV \\
%     \meet{\TUnknown}{\STMV} & = & \STMV \\
%     \meet{\tNum{}}{\tNum{}} & = & \tNum{} \\
%     \meet{(\tarr{\STMV_1}{\STMV_2})}{(\tarr{\STMV_1^`}{\STMV_2^`})} & = & \tarr{(\meet{\STMV_1}{\STMV_1^`})}{(\meet{\STMV_2}{\STMV_2^`})} \\
%     & & \bot otherwise
% \end{array}\]

\subsection{Marking judgments}

\judgbox{\synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}{C}{M}} $\EMV$ is marked into $\ECMV$ and synthesizes type $\STMV$ and generates constraints $C$ and local info mapping $M$
%
\begin{mathpar}
  \inferrule[MKSCVar]{
    \inCtx{\ctx}{x}{\STMV}
  }{
    \synMarkConstraint{\ctx}{\eVar{u}{x}}{\eVar{u}{x}}{\STMV}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MKSCFree]{
    \notInCtx{\ctx}{x}
  }{
    \synMarkConstraint{\ctx}{\eVar{u}{x}}{\ECFree{\eVar{u}{x}}}{\TUnknown^{exp(u)}}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MKSCNum]{ }{
    \synMarkConstraint{\ctx}{\eNum{u}{n}}{\eNum{u}{n}}{\tNum{}}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MKSCPlus]{
    \anaMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\tNum{}}{\cConstraint_1}{\mConstraint_1} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\tNum{}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synMarkConstraint{\ctx}{\ePlus{u}{\ELV_1}{\ELV_2}}{\ePlus{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}{\cConstraint_1 \cup \cConstraint_2}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MKSCTimes]{
    \anaMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\tNum{}}{\cConstraint_1}{\mConstraint_1} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\tNum{}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synMarkConstraint{\ctx}{\eTimes{u}{\ELV_1}{\ELV_2}}{\eTimes{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}{\cConstraint_1 \cup \cConstraint_2}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MKSCLam]{
    \graphErase{\TLMV_1} = \STMV_1 \\
    \synMarkConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELV}{\ELMV}{\STMV_2}{\cConstraint}{\mConstraint}
  }{
    \synMarkConstraint{\ctx}{\lam{x}{\TLMV_1}{\ELV}}{\lam{x}{\TLMV_1}{\ELMV}}{\starrow}{\cConstraint}{\mConstraint}
  }

  \inferrule[MKSCAp1]{
    \synMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\STMV}{\cConstraint_1}{\mConstraint_1} \\
    \matchedArrowConstraint{\STMV}{\STMV_1}{\STMV_2}{\cConstraint_2} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\STMV_1}{\cConstraint_3}{\mConstraint_2} \\
  }{
    \synMarkConstraint{\ctx}{\eApp{u}{\ELV_1}{\ELV_2}}{\eApp{u}{\ELMV_1}{\ELMV_2}}{\STMV_2}{\cConstraint_1 \cup \cConstraint_2 \cup \cConstraint_3}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MKSCAp2]{
    \synMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\STMV}{\cConstraint_1}{\mConstraint_1} \\
    \notMatchedArrow{\STMV} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\TUnknown^{\rightarrow_{L}{(exp(u))}}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synMarkConstraint{\ctx}{\eApp{u}{\ELV_1}{\ELV_2}}{\app{\ECApSynNonMatchedArrow{\ELMV_1}}{\ELMV_2}}{\TUnknown^{\rightarrow_{R}{(exp(u))}}}{\cConstraint_1 \cup \cConstraint_2 \cup \SetOf{\constrain{\TUnknown^{exp(u)}}{\tarr{\TUnknown^{\rightarrow_L(exp(u))}}{\TUnknown^{\rightarrow_R(exp(u))}}}}
    }{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MKSCMultiParent]{ }{
    \synMarkConstraint{\ctx}{\multiref}{\multiref}{\TUnknown^{exp(id-of(v))}}{\constraintNil{}}{(id-of(v), w , \ctx, syn)}
  }
  
  \inferrule[MKSCUnicycle]{ }{
    \synMarkConstraint{\ctx}{\uniref}{\uniref}{\TUnknown^{exp(id-of(v)}}{\constraintNil{}}{(id-of(v),w , \ctx, syn)}
  }  
\end{mathpar} \\

\judgbox{\synMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}}
%
\begin{mathpar}
    \inferrule[MKSCHole]{ }{
        \synMarkConstraint{\ctx}{\emptyHole{v}{p}}{\emptyHole{v}{p}}{\TUnknown^{exp(v,p)}}{\Setof{\constrain{\TUnknown^{exp(v,p)}}{\texttt{etc}}}}{\mapNil}
    }

    \inferrule[MKSCExp]{ 
        \synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}
    }{ 
        \synMarkConstraint{\ctx}{\lexp{\EMV}}{\lexp{\ECMV}}{\STMV}{\cConstraint}{\mConstraint} 
    }

   \inferrule[MKSCConflict]{ 
    \Setof{\synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV_i}{\cConstraint_i}{\mConstraint_i}}_{i<n}
    }{
        \synMarkConstraint{\ctx}{\conflict{\EMV}}{\conflict{\ECMV}}{\TUnknown^{exp(v,p)}}{\Setof{\constrain{\TUnknown^{(exp(u_i))}}{\STMV_i}}_{i<n} \cup \bigcup_{i<n} \cConstraint_i}{\bigcup_{i<n} \mConstraint_1}
    }
\end{mathpar}

\judgbox{\anaMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}}
%
\begin{mathpar}
    \inferrule[MKACSubsume]{ 
        \synMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \consistent{\STMV}{\STMV'} \\
        \subsumable{\ELMV}
    }{
        \anaMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}    
    }

    \inferrule[MKAConflict]{ 
        \Setof{\anaMarkConstraint{\ctx}{\EMV_i}{\ECMV_i}{\STMV}{\cConstraint_i}{\mapNil}}_{i<n}
    }{ 
        \anaMarkConstraint{\ctx}{\conflict{\EMV}}{\conflict{\ECMV}}{\STMV}{\bigcup_{i<n} \cConstraint_i}{\mapNil}
    }

    \inferrule[MKACSuInconType]{
        \synMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \inconsistent{\STMV}{\STMV'} \\
    }{
        \anaMarkConstraint{\ctx}{\ELV}{\incontype}{\STMV}{\cConstraint}{\mConstraint}    
    }
\end{mathpar}


\judgbox{\anaMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}} $\EMV$ is marked into $\ECMV$ and analyzes type $\STMV$ and generates constraints \cConstraint and local-info mapping \mConstraint
%
\begin{mathpar}
    \inferrule[MKACLam1]{
        \graphErase{\TLMV} = \STMV \\
        \matchedArrowConstraint{\STMV_3}{\STMV_1}{\STMV_2}{\cConstraint_1} \\
        \consistent{\STMV}{\STMV_1} \\
        \anaMarkConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELV}{\ELMV}{\STMV_2}{\cConstraint_2}{\mConstraint_1}
    }{
        \anaMarkConstraint{\ctx}{\lam{x}{\TLMV}{\EMV}}{\lam{x}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint_1 \cup \cConstraint_2 \cup \Setof{\constrain{\STMV}{\STMV_1}}}{\mConstraint_1}
    }

     \inferrule[MKACLam2]{
        \graphErase{\TLMV} = \STMV \\
        \notMatchedArrow{\STMV_3} \\
        \anaMarkConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELV}{\ELMV}{\TUnknown^{anon}}{\cConstraint}{\mConstraint}
    }{
        \anaMarkConstraint{\ctx}{\reglam}{\ECLamAnaNonMatchedArrow{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint \cup \Setof{\constrain{\TUnknown^{exp(u)}}{\STMV_3}}}{\mConstraint}
    }

    \inferrule[MKACLam3]{
        \erase{\TLMV} = \STMV \\
        \matchedArrowConstraint{\STMV_3}{\STMV_1}{\STMV_2}{\cConstraint_1} \\
        \inconsistent{\STMV}{\STMV_1} \\
        \anaMarkConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELV}{\ELMV}{\STMV_2}{\cConstraint_2}{\mConstraint}
    }{
        \anaMarkConstraint{\ctx}{\reglam}{\ECLamInconAsc{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint_1 \cup \cConstraint_2 \cup \Setof{\constrain{\TUnknown^{exp(u)}}{\STMV_3}}}{\mConstraint}
    }

\inferrule[MKACMultiParent]{
    }{
    \anaMarkConstraint{\ctx}{\multiref}{\multiref}{\STMV}{\constraintNil{}}{(id-of(v), w ,\ctx, ana(\STMV))}
  }
  
  \inferrule[MKACUnicycle]{ 
    }{
    \anaMarkConstraint{\ctx}{\uniref}{\uniref}{\STMV}{\constraintNil{}}{(id-of(v), w ,\ctx, ana(\STMV))}
  }

  \inferrule[MKACInconsistentTypes]{
    \synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV'}{\cConstraint}{\mConstraint} \\
    \inconsistent{\STMV}{\STMV'} \\
    \subsumable{\EMV}
  }{
    \anaMarkConstraint{\ctx}{\EMV}{\incontype}{\STMV}{\cConstraint}{\mConstraint}
  }

  \inferrule[MKACSubsume]{
    \synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV'}{\cConstraint}{\mConstraint} \\
    \consistent{\STMV}{\STMV'} \\
    \subsumable{\EMV}
  }{
    \anaMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}
  }    
\end{mathpar}


\judgbox{\markless{\ECMV}} $\ECMV$ has no marks
%
\begin{mathpar}
    \inferrule[MLVar]{ }{
        \markless{\var{x}}
    } 

    \inferrule[MLNum]{ }{
        \markless{\num}
    }


    \inferrule[MLLam]{
        \markless{\ELMV}
    }{
        \markless{\lam{x}{\TMV}{\ELMV}}
    }

    \inferrule[MLPlus]{
        \markless{\ELMV_1} \\
        \markless{\ELMV_2}
    }{
        \markless{\plus{\ELMV_1}{\ELMV_2}}
    }

    \inferrule[MLTimes]{
        \markless{\ELMV_1} \\
        \markless{\ELMV_2}
    }{
        \markless{\mult{\ELMV_1}{\ELMV_2}}
    }

    \inferrule[MLAp]{
        \markless{\ELMV_1} \\
        \markless{\ELMV_2}
    }{
        \markless{\app{\ELMV_1}{\ELMV_2}}
    }

    \inferrule[MLMultiParent]{ }{
        \markless{\multiref}
    }

    \inferrule[MLUnicycle]{ }{
        \markless{\uniref}
    }
\end{mathpar}

\judgbox{\markless{\ELMV}} $\ELMV$ has no marks
%
\begin{mathpar}
    \inferrule[MLHole]{ }{
        \markless{\emptyHole{v}{p}}
    }

    \inferrule[MLExp]{ 
        \markless{\EMV}
    }{
        \markless{\lexp{\EMV}}
    }

    \inferrule[MLConflict]{ 
        \Setof{\markless{\ECMV_i}}_{i<n}
    }{
        \markless{\conflict{\ECMV}}
    }
    
\end{mathpar}


\judgbox{\synConstraint{\ctx}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}} $\ELMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MSCHole]{ }{
        \synConstraint{\ctx}{\emptyHole{v}{p}}{\TUnknown^{exp(v,p)}}{\Setof{\constrain{\TUnknown^{exp(v,p)}}{\texttt{etc}}}}{\mapNil}
    }

    \inferrule[MSCExp]{ 
        \synConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}
    }{ 
        \synConstraint{\ctx}{\lexp{\ECMV}}{\STMV}{\cConstraint}{\mConstraint} 
    }

   \inferrule[MSCConflict]{ 
    \Setof{\synConstraint{\ctx}{\ECMV}{\STMV_i}{\cConstraint_i}{\mConstraint_i}}_{i<n}
    }{
        \synConstraint{\ctx}{\conflict{\ECMV}}{\TUnknown^{(v,p)}}{\Setof{\constrain{\TUnknown^{(exp(u))}}{\STMV_i}}_{i<n} \cup \bigcup_{i<n} \cConstraint_i}{\bigcup_{i<n} \mConstraint_1}
    }
\end{mathpar}

\judgbox{\synConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}} $\ECMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MSCVar]{
    \inCtx{\ctx}{x}{\STMV}
  }{
    \synConstraint{\ctx}{\eVar{u}{x}}{\STMV}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MSCFree]{
    \notInCtx{\ctx}{x}
  }{
    \synConstraint{\ctx}{\ECFree{\eVar{u}{x}}}{\TUnknown^{exp(u)}}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MSCNum]{ }{
    \synConstraint{\ctx}{\eNum{u}{n}}{\tNum{}}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MSCPlus]{
    \anaConstraint{\ctx}{\ELMV_1}{\tNum{}}{\cConstraint_1}{\mConstraint_1} \\
    \anaConstraint{\ctx}{\ELMV_2}{\tNum{}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synConstraint{\ctx}{\ePlus{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}{\cConstraint_1 \cup \cConstraint_2}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCTimes]{
    \anaConstraint{\ctx}{\ELMV_1}{\tNum{}}{\cConstraint_1}{\mConstraint_1} \\
    \anaConstraint{\ctx}{\ELMV_2}{\tNum{}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synConstraint{\ctx}{\eTimes{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}{\cConstraint_1 \cup \cConstraint_2}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCLam]{
    \graphErase{\TLMV_1} = \STMV_1 \\
    \synConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELMV}{\STMV_2}{\cConstraint}{\mConstraint}
  }{
    \synConstraint{\ctx}{\lam{x}{\TLMV_1}{\ELMV}}{\starrow}{\cConstraint}{\mConstraint}
  }

  \inferrule[MSCAp1]{
    \synConstraint{\ctx}{\ELMV_1}{\STMV}{\cConstraint_1}{\mConstraint_1} \\
    \matchedArrowConstraint{\STMV}{\STMV_1}{\STMV_2}{\cConstraint_2} \\
    \anaConstraint{\ctx}{\ELMV_2}{\STMV_1}{\cConstraint_3}{\mConstraint_2} \\
  }{
    \synConstraint{\ctx}{\eApp{u}{\ELMV_1}{\ELMV_2}}{\STMV_2}{\cConstraint_1 \cup \cConstraint_2 \cup \cConstraint_3}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCAp2]{
    \synConstraint{\ctx}{\ELMV_1}{\STMV}{\cConstraint_1}{\mConstraint_1} \\
    \notMatchedArrow{\STMV} \\
    \anaConstraint{\ctx}{\ELMV_2}{\TUnknown^{\rightarrow_{L}{(exp(u))}}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synConstraint{\ctx}{\app{\ECApSynNonMatchedArrow{\ELMV_1}}{\ELMV_2}}{\TUnknown^{\rightarrow_{R}{(exp(u))}}}{\cConstraint_1 \cup \cConstraint_2 \cup \SetOf{\constrain{\TUnknown^{exp(u)}}{\tarr{\TUnknown^{\rightarrow_L(exp(u))}}{\TUnknown^{\rightarrow_R(exp(u))}}}}
    }{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCMultiParent]{ }{
    \synConstraint{\ctx}{\multiref}{\TUnknown^{exp(id-of(v))}}{\constraintNil{}}{(id-of(v), w , \ctx, syn)}
  }
  
  \inferrule[MSCUnicycle]{ }{
    \synConstraint{\ctx}{\uniref}{\TUnknown^{exp(id-of(v)}}{\constraintNil{}}{(id-of(v),w , \ctx, syn)}
  }  
\end{mathpar}

\judgbox{\anaConstraint{\ctx}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}} $\ELMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MACSubsume]{ 
        \synConstraint{\ctx}{\ELMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \consistent{\STMV}{\STMV'} \\
        \subsumable{\ELMV}
    }{
        \anaConstraint{\ctx}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}    
    }

    \inferrule[MAConflict]{ 
        \Setof{\anaConstraint{\ctx}{\ECMV_i}{\STMV}{\cConstraint_i}{\mapNil}}_{i<n}
    }{ 
        \anaConstraint{\ctx}{\conflict{\ECMV}}{\STMV}{\bigcup_{i<n} \cConstraint_i}{\mapNil}
    }

    \inferrule[MACSuInconType]{
        \synConstraint{\ctx}{\ELMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \inconsistent{\STMV}{\STMV'} \\
    }{
        \anaConstraint{\ctx}{\incontype}{\STMV}{\cConstraint}{\mConstraint}    
    }
\end{mathpar}

\judgbox{\anaConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}} $\ECMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MACLam1]{
        \graphErase{\TLMV} = \STMV \\
        \matchedArrowConstraint{\STMV_3}{\STMV_1}{\STMV_2}{\cConstraint_1} \\
        \consistent{\STMV}{\STMV_1} \\
        \anaConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELMV}{\STMV_2}{\cConstraint_2}{\mConstraint_1}
    }{
        \anaConstraint{\ctx}{\lam{x}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint_1 \cup \cConstraint_2 \cup \Setof{\constrain{\STMV}{\STMV_1}}}{\mConstraint_1}
    }

    \inferrule[MACLam2]{
        \graphErase{\TLMV} = \STMV \\
        \notMatchedArrow{\STMV_3} \\
        \anaConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELMV}{\TUnknown^{anon}}{\cConstraint}{\mConstraint}
    }{
        \anaConstraint{\ctx}{\ECLamAnaNonMatchedArrow{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint \cup \Setof{\constrain{\TUnknown^{exp(u)}}{\STMV_3}}}{\mConstraint}
  }

    \inferrule[MACLam3]{
        \erase{\TLMV} = \STMV \\
        \matchedArrowConstraint{\STMV_3}{\STMV_1}{\STMV_2}{\cConstraint_1} \\
        \inconsistent{\STMV}{\STMV_1} \\
        \anaConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELMV}{\STMV_2}{\cConstraint_2}{\mConstraint}
    }{
        \anaConstraint{\ctx}{\ECLamInconAsc{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint_1 \cup \cConstraint_2 \cup \Setof{\constrain{\TUnknown^{exp(u)}}{\STMV_3}}}{\mConstraint}
    }

    \inferrule[MACMultiParent]{
    }{
        \anaConstraint{\ctx}{\multiref}{\STMV}{\constraintNil{}}{(id-of(v), w ,\ctx, ana(\STMV))}
    }
  
    \inferrule[MACUnicycle]{ 
    }{
        \anaConstraint{\ctx}{\uniref}{\STMV}{\constraintNil{}}{(id-of(v), w ,\ctx, ana(\STMV))}
     }

    \inferrule[MACInconsistentTypes]{
        \synConstraint{\ctx}{\ECMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \inconsistent{\STMV}{\STMV'} \\
        \subsumable{\EMV}
    }{
        \anaConstraint{\ctx}{\incontype}{\STMV}{\cConstraint}{\mConstraint}
    }

    \inferrule[MACSubsume]{
        \synConstraint{\ctx}{\ECMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \consistent{\STMV}{\STMV'} \\
        \subsumable{\EMV}
    }{
        \anaConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}
    }
\end{mathpar}


\judgbox{\subsumable{\ECMV}} $ECMV$ is subsumable
%
\begin{mathpar}
    \inferrule[UMSuVar]{ }{
    \subsumable{\eVar{u}{x}}
  }

  \inferrule[UMSuNum]{ }{
    \subsumable{\eNum{u}{n}}
  }

  \inferrule[UMSuPlus]{ 
    \subsumable{\ELMV_1} \\
    \subsumable{\ELMV_2}
  }{
    \subsumable{\plus{\ELMV_1}{\ELMV_2}}
  }

  \inferrule[UMSuTimes]{ 
    \subsumable{\ELMV_1} \\
    \subsumable{\ELMV_2}
  }{
    \subsumable{\mult{\ELMV_1}{\ELMV_2}}
  }

  \inferrule[UMSuAp]{
    \subsumable{\ELMV_1} \\
    \subsumable{\ELMV_2}
  }{
    \subsumable{\app{\ELMV_1}{\ELMV_2}}
  }

  \inferrule[UMSuMultiParent]{ }{
    \subsumable{\multiref}
  }

  \inferrule[UMSuUnicycle]{ }{
    \subsumable{\uniref}
  }
\end{mathpar}

\judgbox{\subsumable{\ELMV}} $\ELMV$ is subsumable
%
\begin{mathpar}
    \inferrule[UMSuHole]{ }{
        \subsumable{\emptyHole{v}{p}}
    }

    \inferrule[UMSuExp]{ 
        \subsumable{\ECMV}
    }{
        \subsumable{\lexp{\ECMV}}
    }
\end{mathpar}


\subsection{Mark erasure}
\label{sec:marked-mark-erasure}
$\judgbox{\markErase{\ECMV}}$ is a metafunction defined as follows:
%
\[\begin{array}{rcl}
  \erasesToRow{\eVar{u}{x}}{\eVar{u}{x}} \\
  \erasesToRow{\ECFree{\var{x}}}{\var{x}} \\
    \erasesToRow{\eNum{u}{n}}{\eNum{u}{n}} \\
  \erasesToRow{\plus{\ELMV_1}{\ELMV_2}}{\plus{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\mult{\ELMV_1}{\ELMV_2}}{\mult{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\reglam}{\lam{x}{\TLMV}{\markErase{\ELMV}}} \\
  \erasesToRow{\ECLamInconAsc{\var{x}}{\TLMV}{\ELMV}}{\lam{x}{\TLMV}{(\markErase{\ELMV})}} \\
  \erasesToRow{\ECLamAnaNonMatchedArrow{\var{x}}{\TLMV}{\ELMV}}{\lam{x}{\TLMV}{(\markErase{\ELMV})}} \\
  \erasesToRow{\eApp{u}{\ELMV_1}{\ELMV_2}}{\eApp{u}{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\eApp{u}{\ECApSynNonMatchedArrow{\ELMV_1}}{\ELMV_2}}{\eApp{u}{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\ECInconType{\ECMV}}{\markErase{\ECMV}} \\
\end{array}\]
$\judgbox{\markErase{\ELMV}}$ is a metafunction defined as follows:
%
% \newcommand{\erasesToRow}[2]{\markErase{#1} & = & #2}
\[\begin{array}{rcl}
    \erasesToRow{\emptyHole{v}{p}}{\emptyHole{v}{p}} \\
    \erasesToRow{\lexp{\ECMV}}{\lexp{\markErase{\ECMV}}} \\
    \erasesToRow{\conflict{\ECMV}}{\conflict{\markErase{\ECMV}}}
\end{array}\]


\subsection{Metatheorems}
\label{sec:marked-metatheorems}
\begin{theorem}[name=Marking Totality] \
  \begin{enumerate}
    \item For all $\ctx$ and $\EMV$, there exist $\ECMV$ and $\STMV$ such that
      $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$.
    \item For all $\ctx$ and $\ELV$, there exist $\ELMV$ and $\STMV$ such that
      $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$.
    \item For all $\ctx$, $\EMV$, and $\STMV$, there exists $\ECMV$ such that
      $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$.
    \item For all $\ctx$, $\ELV$, and $\STMV$, there exists $\ELMV$ such that
      $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[name=Marking Well-Formedness] \
  \begin{enumerate}
    \item If $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$, then $\ctxSynTypeM{\ctx}{\ECMV}{\STMV}$ and
      $\erasesTo{\ECMV}{\EMV}$.
    \item If $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$, then $\ctxSynTypeM{\ctx}{\ELMV}{\STMV}$ and
      $\erasesTo{\ELMV}{\ELV}$.
    \item If $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$, then $\ctxAnaTypeM{\ctx}{\ECMV}{\STMV}$ and
      $\erasesTo{\ECMV}{\EMV}$.
    \item If $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$, then $\ctxAnaTypeM{\ctx}{\ELMV}{\STMV}$ and
      $\erasesTo{\ELMV}{\ELV}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[name=Marking of Well-Typed/Ill-Typed Expressions] \
  \begin{enumerate}
    \item \begin{enumerate}
        \item If $\ctxSynTypeU{\ctx}{\EMV}{\STMV}$ and $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$,
          then $\markless{\ECMV}$.
        \item If $\ctxSynTypeU{\ctx}{\ELV}{\STMV}$ and $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$,
          then $\markless{\ELMV}$.
        \item If $\ctxAnaTypeU{\ctx}{\EMV}{\STMV}$ and $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$,
          then $\markless{\ECMV}$.
        \item If $\ctxAnaTypeU{\ctx}{\ELV}{\STMV}$ and $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$,
          then $\markless{\ELMV}$.
      \end{enumerate}

    \item \begin{enumerate}
        \item If there does not exist $\STMV$ such that $\ctxSynTypeU{\ctx}{\EMV}{\STMV}$, then for
          all $\ECMV$ and $\STMV'$ such that $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV'}$, it is not
          the case that $\markless{\ECMV}$.
        \item If there does not exist $\STMV$ such that $\ctxSynTypeU{\ctx}{\ELV}{\STMV}$, then for
          all $\ELMV$ and $\STMV'$ such that $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV'}$, it is not
          the case that $\markless{\ELMV}$.
        \item If there does not exist $\STMV$ such that $\ctxAnaTypeU{\ctx}{\EMV}{\STMV}$, then for
          all $\ECMV$ and $\STMV'$ such that $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV'}$, it is not
          the case that $\markless{\ECMV}$.
        \item If there does not exist $\STMV$ such that $\ctxAnaTypeU{\ctx}{\ELV}{\STMV}$, then for
          all $\ELMV$ and $\STMV'$ such that $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV'}$, it is not
          the case that $\markless{\ELMV}$.
      \end{enumerate}
  \end{enumerate}
\end{theorem}

\begin{theorem}[name=Marking Unicity] \
  \begin{enumerate}
    \item If $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV_1}{\STMV_1}$ and
      $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV_2}{\STMV_2}$, then $\ECMV_1 = \ECMV_2$ and $\STMV_1 =
      \STMV_2$.
    \item If $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV_1}{\STMV_1}$ and
      $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV_2}{\STMV_2}$, then $\ELMV_1 = \ELMV_2$ and $\STMV_1 =
      \STMV_2$.
    \item If $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV_1}{\STMV}$ and
      $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV_2}{\STMV}$, then $\ECMV_1 = \ECMV_2$.
    \item If $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV_1}{\STMV}$ and
      $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV_2}{\STMV}$, then $\ELMV_1 = \ELMV_2$.
  \end{enumerate}
\end{theorem}


