\section{Representation of terms}
\label{sec:marked-calculus}

\subsection{Syntax}
\[\begin{array}{lllll}
    \STMV \in & \STMName & \Coloneqq & 
        \TUnknown
        \mid \tNum{}
        \mid \starrow \\
    \TMV \in & \TMName & \Coloneqq & 
        \tnum 
        \mid \tarrow 
        \mid \multiref 
        \mid \uniref \\ 
    \TLMV \in & \TLMName & \Coloneqq &
        \ehole
        \mid \lexp{\TMV}
        \mid \conflict{\TMV} \\
     \EMV \in & \EMName & \Coloneqq & 
        \var{x}
        \mid \num 
        \mid \plus{\ELV_1}{\ELV_2} 
        \mid \mult{\ELV_1}{\ELV_2}
        \mid \lam{x}{\TLMV}{\ELV}
        \mid \app{\ELV_1}{\ELV_2}
        \mid \multiref
        \mid \uniref \\
     \ELV \in & \ELMName & \Coloneqq & 
        \ehole
        \mid \lexp{\EMV} 
        \mid \conflict{\EMV} \\
     \ECMV \in & \ECMName & \Coloneqq &
        \var{x}
        \mid \num
        \mid \plus{\ELMV_1}{\ELMV_2}
        \mid \mult{\ELMV_1}{\ELMV_2}
        \mid \lam{x}{\TLMV}{\ELV}
        \mid \app{\ELMV_1}{\ELMV_2}
        \mid \multiref
        \mid \uniref \\ 
        & & & \ECFree{\var{x}} 
        \mid \incontype
        \mid \lamasc
        \mid \lamanamarr
        \mid \apsynmarr \\ 
        % \mid \lamge \\
    \ELMV \in & \ELMName & \Coloneqq &
        \ehole
        \mid \lexp{\ECMV}
        \mid \conflict{\ECMV} \\
    \Provp \in & \Prov & \Coloneqq &
        \mathsf{typ}(\ell)
        \mid \mathsf{exp}(\ell)
        \mid \mathsf{ref}(w)
        \mid \mathsf{mark}(u)
        \mid ~\rightarrow_L(\Provp) \mid ~\rightarrow_R(\Provp)
        \mid \mathsf{anon} \\
    m \in & \mathsf{Mode} & \Coloneqq & \mathsf{syn} \mid \mathsf{ana}(\STMV)
\end{array}\]

\subsection{Types}

\judgbox{\graphErase{\TMV} = \STMV} $\TMV$ erases to $\STMV$
%
\begin{mathpar}
    \inferrule[GENum]{ }{
        \graphErase{\tnum} = \tNum{}
    }
    
    \inferrule[GEArr]{
        \graphErase{\TMV_1} = \STMV_1 \\
        \graphErase{\TMV_2} = \STMV_2
    }{
        \graphErase{\tarrow} = \starrow
    }
    
    \inferrule[GEMultiParent]{ }{ 
        \graphErase{\multiref{v}} = \TUnknown
    }

    \inferrule[GEUnicycle]{ }{ 
        \graphErase{\uniref} = \TUnknown
    }
\end{mathpar}

\judgbox{\graphErase{\TLMV} = \STMV} $\TLMV$ graph erases to $\STMV$
%
\begin{mathpar}
    \inferrule[GEHole]{ }{
        \graphErase{\ehole} = \TUnknown
    }
    
    \inferrule[GEExp]{
        \graphErase{\TMV} = \STMV
    }{ 
        \graphErase{\lexp{\TMV}} = \STMV
    }
    
    \inferrule[GEConflict]{ }{
        \graphErase{\conflict{\TMV}} = \TUnknown
    }
\end{mathpar}

\judgbox{\ensuremath{\consistent{\STMV_1}{\STMV_2}}} $\STMV_1$ is consistent with $\STMV_2$
%
\begin{mathpar}
  \inferrule[TCUnknown1]{ }{
    \consistent{\TUnknown}{\STMV}
  }

  \inferrule[TCUnknown2]{ }{
    \consistent{\STMV}{\TUnknown}
  }

  \inferrule[TCRefl]{ }{
    \consistent{\STMV}{\STMV}
  }

  \inferrule[TCArr]{
    \consistent{\STMV_1}{\STMV_1'} \\
    \consistent{\STMV_2}{\STMV_2'} \\
  }{
    \consistent{\TArrow{\STMV_1}{\STMV_2}}{\TArrow{\STMV_1'}{\STMV_2'}}
  }
\end{mathpar} \\

\judgbox{\ensuremath{\matchedArrow{\STMV}{\STMV_1}{\STMV_2}}} $\STMV$ has matched arrow type $\TArrow{\STMV_1}{\STMV_2}$
%
\begin{mathpar}
  \inferrule[TMAUnknown]{ }{
    \matchedArrow{\TUnknown}{\TUnknown}{\TUnknown}
  }

  \inferrule[TMAArr]{ }{
    \matchedArrow{\TArrow{\STMV_1}{\STMV_2}}{\STMV_1}{\STMV_2}
  }
\end{mathpar} \\

\judgbox{\ensuremath{\matchedArrowConstraint{\STMV}{\STMV_1}{\STMV_2}{C}}} $\STMV$ has matched arrow type $\TArrow{\STMV_1}{\STMV_2}$ and generates constraints $C$
%
\begin{mathpar}
  \judgment{ }{
    \matchedArrowConstraint{\TUnknown^\Provp}{\TUnknown^{\rightarrow_L(\Provp)}}{\TUnknown^{\rightarrow_R(\Provp)}}{\{ \TUnknown^\Provp \approx \tarr{\TUnknown^{\rightarrow_L(\Provp)}}{\TUnknown^{\rightarrow_R(\Provp)}} \}}
  }{TMAUnknown-C}

  \judgment{ }{
    \matchedArrowConstraint{\TArrow{\STMV_1}{\STMV_2}}{\STMV_1}{\STMV_2}{\{\}}
  }{TMAArr-C}
\end{mathpar}

\subsection{Unmarked expressions}
\label{sec:marked-unmarked-expressions}
\judgbox{\ctxSynTypeU{\ctx}{\EMV}{\STMV}} $\EMV$ synthesizes type $\STMV$
%
\begin{mathpar}
  \inferrule[USVar]{
    \inCtx{\ctx}{\eVar{}{x}}{\STMV}
  }{
    \ctxSynTypeU{\ctx}{\var{x}}{\STMV}
  }

  \inferrule[USNum]{ }{
    \ctxSynTypeU{\ctx}{\num}{\tNum{}}
  }

  \inferrule[USLam]{
    \graphErase{\TLMV_1} = \STMV_1 \\
    \ctxSynTypeU{\extendCtx{\ctx}{x}{\STMV_1}}{\ELV}{\STMV_2}
  }{
    \ctxSynTypeU{\ctx}{\lam{x}{\TLMV_1}{\ELV}}{\starrow}
  }

  \inferrule[USAp]{
    \ctxSynTypeU{\ctx}{\ELV_1}{\STMV} \\
    \matchedArrow{\STMV}{\STMV_1}{\STMV_2} \\
    \ctxAnaTypeU{\ctx}{\ELV_2}{\STMV_1}
  }{
    \ctxSynTypeU{\ctx}{\app{\ELV_1}{\ELV_2}}{\STMV_2}
  }  

  \inferrule[USPlus]{
    \ctxAnaTypeU{\ctx}{\ELV_1}{\tNum{}} \\
    \ctxAnaTypeU{\ctx}{\ELV_2}{\tNum{}}
  }{
    \ctxSynTypeU{\ctx}{\plus{\ELV_1}{\ELV_2}}{\tNum{}}
  }

  \inferrule[USTimes]{
    \ctxAnaTypeU{\ctx}{\ELV_1}{\tNum{}} \\
    \ctxAnaTypeU{\ctx}{\ELV_2}{\tNum{}}
  }{
    \ctxSynTypeU{\ctx}{\mult{\ELV_1}{\ELV_2}}{\tNum{}}
  }

  \inferrule[USMultiLocationConflict]{ }{
    \ctxSynTypeU{\ctx}{\multiref}{\TUnknown}
  }

  \inferrule[USCycleLocationConflict]{ }
  {
    \ctxSynTypeU{\ctx}{\uniref}{\TUnknown} 
  }  
\end{mathpar} \\

\judgbox{\ctxSynTypeU{\ctx}{\ELV}{\STMV}} $\ELV$ synthesizes type $\STMV$
%
\begin{mathpar}
    \inferrule[USHole]{ }{
        \ctxSynTypeU{\ctx}{\ehole}{\TUnknown}
    }

    \inferrule[USExp]{
        \ctxSynTypeU{\ctx}{\EMV}{\STMV}
    }{ 
        \ctxSynTypeU{\ctx}{\lexp{\EMV}}{\STMV}
    }
    
    \inferrule[USLocalConflict]{
    }{
        \ctxSynTypeU{\ctx}{\conflict{\TMV}}{\TUnknown}
    }

\end{mathpar}

\judgbox{\ctxAnaTypeU{\ctx}{\EMV}{\STMV}} $\EMV$ analyzes against type $\STMV$
%
\begin{mathpar}
  \inferrule[UALam]{
    \graphErase{\TLMV} = \STMV \\
    \matchedArrow{\STMV_3}{\STMV_1}{\STMV_2} \\
    \consistent{\STMV}{\STMV_1} \\
    \ctxAnaTypeU{\extendCtx{\ctx}{x}{\STMV}}{\ELV}{\STMV_2}
  }{
    \ctxAnaTypeU{\ctx}{\reglam}{\STMV_3}
  }

  \inferrule[UAMultiLocationConflict]{ }{
    \ctxAnaTypeU{\ctx}{\multiref}{\STMV}
  }

  \inferrule[UACycleLocationConflict]{ }
  {
    \ctxAnaTypeU{\ctx}{\uniref}{\STMV} 
  }

  \inferrule[UASubsume]{
    \ctxSynTypeU{\ctx}{\EMV}{\STMV'} \\
    \consistent{\STMV}{\STMV'} \\
    \subsumable{\EMV}
  }{
    \ctxAnaTypeU{\ctx}{\EMV}{\STMV}
  }
\end{mathpar} \\

\judgbox{\ctxAnaTypeU{\ctx}{\ELV}{\STMV}} $\ELV$ analyzes against type $\STMV$
%
\begin{mathpar}
    \inferrule[ULASubsume]{ 
        \ctxSynTypeU{\ctx}{\ELV}{\STMV'} \\
        \consistent{\STMV}{\STMV'}
    }{ 
        \ctxAnaTypeU{\ctx}{\ELV}{\STMV}
    }
\end{mathpar}

\judgbox{\subsumable{\EMV}} $\EMV$ is subsumable
%
\begin{mathpar}
  \inferrule[USuVar]{ }{
    \subsumable{\eVar{u}{x}}
  }

  \inferrule[USuNum]{ }{
    \subsumable{\eNum{u}{n}}
  }

  \inferrule[USuPlus]{
  }{
    \subsumable{\plus{\ELV_1}{\ELV_2}}
  }

  \inferrule[USuTimes]{
  }{
    \subsumable{\mult{\ELV_1}{\ELV_2}}
  }

  \inferrule[USuAp]{
  }{
    \subsumable{\app{\ELV_1}{\ELV_2}}
  }
\end{mathpar}

\judgbox{\subsumable{\ELV}} $\ELV$ is subsumable
%
\begin{mathpar}
    \inferrule[USuHole]{ }{
        \subsumable{\emptyHole{v}{p}}
    }

    \inferrule[USuExp]{ }{
        \subsumable{\lexp{\EMV}}
    }

    \inferrule[USuConflict]{ }{
        \subsumable{\conflict{\EMV}}
    }
\end{mathpar}

% \subsubsection{Local Info Mapping}
% \judgbox{\Setof{(u,w,\ctx,m)}} 
% %
% $M$ is a set of 4-tuples of $u$ (vertex-IDs), $w$ (edge-IDs), \ctx and mode $m$

% \subsubsection{Meet of Types} 
% \judgbox{\meet{\STMV_1}{\STMV_2}}

% \[\begin{array}{ccr}
%     \meet{\STMV}{\TUnknown} & = & \STMV \\
%     \meet{\TUnknown}{\STMV} & = & \STMV \\
%     \meet{\tNum{}}{\tNum{}} & = & \tNum{} \\
%     \meet{(\tarr{\STMV_1}{\STMV_2})}{(\tarr{\STMV_1^`}{\STMV_2^`})} & = & \tarr{(\meet{\STMV_1}{\STMV_1^`})}{(\meet{\STMV_2}{\STMV_2^`})} \\
%     & & \bot otherwise
% \end{array}\]

\subsection{Marking}

\judgbox{\synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}} $\EMV$ is marked into $\ECMV$ and synthesizes type $\STMV$
%
\begin{mathpar}
  \inferrule[MKSVar]{
    \inCtx{\ctx}{x}{\STMV}
  }{
     \synMarkConstraint{\ctx}{\eVar{u}{x}}{\eVar{u}{x}}{\STMV}
  }

  \inferrule[MKSFree]{
    \notInCtx{\ctx}{x}
  }{
    \synMarkConstraint{\ctx}{\eVar{u}{x}}{\ECFree{\eVar{u}{x}}}{\TUnknown^{\mathsf{mark}(u)}}
  }

  \inferrule[MKSNum]{ }{
    \synMarkConstraint{\ctx}{\eNum{u}{n}}{\eNum{u}{n}}{\tNum{}}
  }

  \inferrule[MKSPlus]{
    \anaMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\tNum{}} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\tNum{}}
  }{
    \synMarkConstraint{\ctx}{\ePlus{u}{\ELV_1}{\ELV_2}}{\ePlus{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}
  }

  \inferrule[MKSTimes]{
    \anaMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\tNum{}} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\tNum{}}
  }{
    \synMarkConstraint{\ctx}{\eTimes{u}{\ELV_1}{\ELV_2}}{\eTimes{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}
  }

  \inferrule[MKSLam]{
    \graphErase{\TLMV_1} = \STMV_1 \\
    \synMarkConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELV}{\ELMV}{\STMV_2}
  }{
    \synMarkConstraint{\ctx}{\lam{x}{\TLMV_1}{\ELV}}{\lam{x}{\TLMV_1}{\ELMV}}{\starrow}
  }

  \inferrule[MKSAp1]{
    \synMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\STMV} \\
    \matchedArrow{\STMV}{\STMV_1}{\STMV_2} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\STMV_1} \\
  }{
    \synMarkConstraint{\ctx}{\eApp{u}{\ELV_1}{\ELV_2}}{\eApp{u}{\ELMV_1}{\ELMV_2}}{\STMV_2}
  }

  \inferrule[MKSAp2]{
    \synMarkConstraint{\ctx}{\ELV_1}{\ELMV_1}{\STMV} \\
    \notMatchedArrow{\STMV} \\
    \anaMarkConstraint{\ctx}{\ELV_2}{\ELMV_2}{\TUnknown^{\rightarrow_{L}{(\mathsf{mark}(u))}}}
  }{
    \synMarkConstraint{\ctx}{\eApp{u}{\ELV_1}{\ELV_2}}{\app{\ECApSynNonMatchedArrow{\ELMV_1}}{\ELMV_2}}{\TUnknown^{\rightarrow_{R}{(\mathsf{mark}(u))}}}
  }

  \inferrule[MKSMultiLocationConflict]{ }{
    \synMarkConstraint{\ctx}{\multiref}{\multiref}{\TUnknown^{\mathsf{ref}(w)}}
  }
  
  \inferrule[MKSCycleLocationConflict]{ }{
    \synMarkConstraint{\ctx}{\uniref}{\uniref}{\TUnknown^{\mathsf{ref}(w)}}
  }  
\end{mathpar} \\

\judgbox{\synMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV}} $\ELV$ is marked into $\ELMV$ and synthesizes type $\STMV$
%
\begin{mathpar}
    \inferrule[MKSHole]{ }{
        \synMarkConstraint{\ctx}{\emptyHole{\ell}}{\emptyHole{\ell}}{\TUnknown^{\mathsf{exp}(\ell)}}
    }

    \inferrule[MKSExp]{ 
        \synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}
    }{ 
        \synMarkConstraint{\ctx}{\lexp{\EMV}}{\lexp{\ECMV}}{\STMV}
    }

   \inferrule[MKSLocalConflict]{ 
      \Setof{\synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV_i}}_{i<n}
    }{
        \synMarkConstraint{\ctx}{\conflict{\EMV}}{\conflict{\ECMV}}{\TUnknown^{\mathsf{exp}(\ell)}}
    }
\end{mathpar}

\judgbox{\anaMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}} $\EMV$ is marked into $\ECMV$ and analyzes type $\STMV$
%
\begin{mathpar}
    \inferrule[MKALam1]{
        \matchedArrow{\STMV_3}{\STMV_1}{\STMV_2} \\
        \graphErase{\TLMV} = \STMV \\
        \consistent{\STMV}{\STMV_1} \\
        \anaMarkConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELV}{\ELMV}{\STMV_2}
    }{
        \anaMarkConstraint{\ctx}{\lam{x}{\TLMV}{\EMV}}{\lam{x}{\TLMV}{\ELMV}}{\STMV_3}
    }

     \inferrule[MKALam2]{
        \notMatchedArrow{\STMV_3} \\
        \graphErase{\TLMV} = \STMV \\
        \anaMarkConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELV}{\ELMV}{\TUnknown^{\mathsf{anon}}}
    }{
        \anaMarkConstraint{\ctx}{\reglam}{\ECLamAnaNonMatchedArrow{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}
    }

    \inferrule[MKALam3]{
        \matchedArrow{\STMV_3}{\STMV_1}{\STMV_2} \\
        \graphErase{\TLMV} = \STMV \\
        \inconsistent{\STMV}{\STMV_1} \\
        \anaMarkConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELV}{\ELMV}{\STMV_2}
    }{
        \anaMarkConstraint{\ctx}{\reglam}{\ECLamInconAsc{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}
    }

    \inferrule[MKAMultiLocationConflict]{ }{
      \anaMarkConstraint{\ctx}{\multiref}{\multiref}{\STMV}
    }
  
  \inferrule[MKACycleLocationConflict]{ }{
    \anaMarkConstraint{\ctx}{\uniref}{\uniref}{\STMV}
  }

  \inferrule[MKASubsume]{
    \synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV'} \\
    \consistent{\STMV}{\STMV'} \\
    \subsumable{\EMV}
  }{
    \anaMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV}
  }    

  \inferrule[MKAInconsistentTypes]{
    \synMarkConstraint{\ctx}{\EMV}{\ECMV}{\STMV'} \\
    \inconsistent{\STMV}{\STMV'} \\
    \subsumable{\EMV}
  }{
    \anaMarkConstraint{\ctx}{\EMV}{\incontype}{\STMV}
  }
\end{mathpar}

\judgbox{\anaMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV}} $\ELV$ is marked into $\ELMV$ and analyzes against type $\STMV$
%
\begin{mathpar}
  \inferrule[MKASubsume]{
    \synMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV'} \\
    \consistent{\STMV}{\STMV'}
  }{
    \anaMarkConstraint{\ctx}{\ELV}{\ELMV}{\STMV}
  }
\end{mathpar}

\judgbox{\markless{\ECMV}} $\ECMV$ has no marks
%
\begin{mathpar}
    \inferrule[MLVar]{ }{
        \markless{\var{x}}
    } 

    \inferrule[MLNum]{ }{
        \markless{\num}
    }


    \inferrule[MLLam]{
        \markless{\ELMV}
    }{
        \markless{\lam{x}{\TMV}{\ELMV}}
    }

    \inferrule[MLPlus]{
        \markless{\ELMV_1} \\
        \markless{\ELMV_2}
    }{
        \markless{\plus{\ELMV_1}{\ELMV_2}}
    }

    \inferrule[MLTimes]{
        \markless{\ELMV_1} \\
        \markless{\ELMV_2}
    }{
        \markless{\mult{\ELMV_1}{\ELMV_2}}
    }

    \inferrule[MLAp]{
        \markless{\ELMV_1} \\
        \markless{\ELMV_2}
    }{
        \markless{\app{\ELMV_1}{\ELMV_2}}
    }

    \inferrule[MLMultiParent]{ }{
        \markless{\multiref}
    }

    \inferrule[MLUnicycle]{ }{
        \markless{\uniref}
    }
\end{mathpar}

\judgbox{\markless{\ELMV}} $\ELMV$ has no marks
%
\begin{mathpar}
    \inferrule[MLHole]{ }{
        \markless{\emptyHole{v}{p}}
    }

    \inferrule[MLExp]{ 
        \markless{\EMV}
    }{
        \markless{\lexp{\EMV}}
    }

    \inferrule[MLConflict]{ 
        \Setof{\markless{\ECMV_i}}_{i<n}
    }{
        \markless{\conflict{\ECMV}}
    }
    
\end{mathpar}


\judgbox{\synConstraint{\ctx}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}} $\ELMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MSCHole]{ }{
        \synConstraint{\ctx}{\emptyHole{v}{p}}{\TUnknown^{\mathsf{exp}(v,p)}}{\Setof{\constrain{\TUnknown^{\mathsf{exp}(v,p)}}{\texttt{etc}}}}{\mapNil}
    }

    \inferrule[MSCExp]{ 
        \synConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}
    }{ 
        \synConstraint{\ctx}{\lexp{\ECMV}}{\STMV}{\cConstraint}{\mConstraint} 
    }

   \inferrule[MSCConflict]{ 
    \Setof{\synConstraint{\ctx}{\ECMV}{\STMV_i}{\cConstraint_i}{\mConstraint_i}}_{i<n}
    }{
        \synConstraint{\ctx}{\conflict{\ECMV}}{\TUnknown^{(v,p)}}{\Setof{\constrain{\TUnknown^{(\mathsf{exp}(u))}}{\STMV_i}}_{i<n} \cup \bigcup_{i<n} \cConstraint_i}{\bigcup_{i<n} \mConstraint_1}
    }
\end{mathpar}

\judgbox{\synConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}} $\ECMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MSCVar]{
    \inCtx{\ctx}{x}{\STMV}
  }{
    \synConstraint{\ctx}{\eVar{u}{x}}{\STMV}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MSCFree]{
    \notInCtx{\ctx}{x}
  }{
    \synConstraint{\ctx}{\ECFree{\eVar{u}{x}}}{\TUnknown^{\mathsf{exp}(u)}}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MSCNum]{ }{
    \synConstraint{\ctx}{\eNum{u}{n}}{\tNum{}}{\constraintNil{}}{\mapNil}
  }

  \inferrule[MSCPlus]{
    \anaConstraint{\ctx}{\ELMV_1}{\tNum{}}{\cConstraint_1}{\mConstraint_1} \\
    \anaConstraint{\ctx}{\ELMV_2}{\tNum{}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synConstraint{\ctx}{\ePlus{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}{\cConstraint_1 \cup \cConstraint_2}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCTimes]{
    \anaConstraint{\ctx}{\ELMV_1}{\tNum{}}{\cConstraint_1}{\mConstraint_1} \\
    \anaConstraint{\ctx}{\ELMV_2}{\tNum{}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synConstraint{\ctx}{\eTimes{u}{\ELMV_1}{\ELMV_2}}{\tNum{}}{\cConstraint_1 \cup \cConstraint_2}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCLam]{
    \graphErase{\TLMV_1} = \STMV_1 \\
    \synConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELMV}{\STMV_2}{\cConstraint}{\mConstraint}
  }{
    \synConstraint{\ctx}{\lam{x}{\TLMV_1}{\ELMV}}{\starrow}{\cConstraint}{\mConstraint}
  }

  \inferrule[MSCAp1]{
    \synConstraint{\ctx}{\ELMV_1}{\STMV}{\cConstraint_1}{\mConstraint_1} \\
    \matchedArrowConstraint{\STMV}{\STMV_1}{\STMV_2}{\cConstraint_2} \\
    \anaConstraint{\ctx}{\ELMV_2}{\STMV_1}{\cConstraint_3}{\mConstraint_2} \\
  }{
    \synConstraint{\ctx}{\eApp{u}{\ELMV_1}{\ELMV_2}}{\STMV_2}{\cConstraint_1 \cup \cConstraint_2 \cup \cConstraint_3}{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCAp2]{
    \synConstraint{\ctx}{\ELMV_1}{\STMV}{\cConstraint_1}{\mConstraint_1} \\
    \notMatchedArrow{\STMV} \\
    \anaConstraint{\ctx}{\ELMV_2}{\TUnknown^{\rightarrow_{L}{(\mathsf{exp}(u))}}}{\cConstraint_2}{\mConstraint_2}
  }{
    \synConstraint{\ctx}{\app{\ECApSynNonMatchedArrow{\ELMV_1}}{\ELMV_2}}{\TUnknown^{\rightarrow_{R}{(\mathsf{exp}(u))}}}{\cConstraint_1 \cup \cConstraint_2 \cup \SetOf{\constrain{\TUnknown^{\mathsf{exp}(u)}}{\tarr{\TUnknown^{\rightarrow_L(\mathsf{exp}(u))}}{\TUnknown^{\rightarrow_R(\mathsf{exp}(u))}}}}
    }{\mConstraint_1 \cup \mConstraint_2}
  }

  \inferrule[MSCMultiParent]{ }{
    \synConstraint{\ctx}{\multiref}{\TUnknown^{\mathsf{exp}(\mathsf{idof}(v))}}{\constraintNil{}}{(\mathsf{idof}(v), w , \ctx, syn)}
  }
  
  \inferrule[MSCUnicycle]{ }{
    \synConstraint{\ctx}{\uniref}{\TUnknown^{\mathsf{exp}(\mathsf{idof}(v)}}{\constraintNil{}}{(\mathsf{idof}(v),w , \ctx, syn)}
  }  
\end{mathpar}

\judgbox{\anaConstraint{\ctx}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}} $\ELMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MACSubsume]{ 
        \synConstraint{\ctx}{\ELMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \consistent{\STMV}{\STMV'} \\
        \subsumable{\ELMV}
    }{
        \anaConstraint{\ctx}{\ELMV}{\STMV}{\cConstraint}{\mConstraint}    
    }

    \inferrule[MAConflict]{ 
        \Setof{\anaConstraint{\ctx}{\ECMV_i}{\STMV}{\cConstraint_i}{\mapNil}}_{i<n}
    }{ 
        \anaConstraint{\ctx}{\conflict{\ECMV}}{\STMV}{\bigcup_{i<n} \cConstraint_i}{\mapNil}
    }

    \inferrule[MACSuInconType]{
        \synConstraint{\ctx}{\ELMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \inconsistent{\STMV}{\STMV'} \\
    }{
        \anaConstraint{\ctx}{\incontype}{\STMV}{\cConstraint}{\mConstraint}    
    }
\end{mathpar}

\judgbox{\anaConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}} $\ECMV$ analyzes type $\STMV$ under typing context $\ctx$ and generates constraints \cConstraint, and local-info \mConstraint
%
\begin{mathpar}
    \inferrule[MACLam1]{
        \graphErase{\TLMV} = \STMV \\
        \matchedArrowConstraint{\STMV_3}{\STMV_1}{\STMV_2}{\cConstraint_1} \\
        \consistent{\STMV}{\STMV_1} \\
        \anaConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELMV}{\STMV_2}{\cConstraint_2}{\mConstraint_1}
    }{
        \anaConstraint{\ctx}{\lam{x}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint_1 \cup \cConstraint_2 \cup \Setof{\constrain{\STMV}{\STMV_1}}}{\mConstraint_1}
    }

    \inferrule[MACLam2]{
        \graphErase{\TLMV} = \STMV \\
        \notMatchedArrow{\STMV_3} \\
        \anaConstraint{\extendCtx{\ctx}{x}{\STMV}}{\ELMV}{\TUnknown^{anon}}{\cConstraint}{\mConstraint}
    }{
        \anaConstraint{\ctx}{\ECLamAnaNonMatchedArrow{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint \cup \Setof{\constrain{\TUnknown^{\mathsf{exp}(u)}}{\STMV_3}}}{\mConstraint}
  }

    \inferrule[MACLam3]{
        \erase{\TLMV} = \STMV \\
        \matchedArrowConstraint{\STMV_3}{\STMV_1}{\STMV_2}{\cConstraint_1} \\
        \inconsistent{\STMV}{\STMV_1} \\
        \anaConstraint{\extendCtx{\ctx}{x}{\STMV_1}}{\ELMV}{\STMV_2}{\cConstraint_2}{\mConstraint}
    }{
        \anaConstraint{\ctx}{\ECLamInconAsc{\var{x}}{\TLMV}{\ELMV}}{\STMV_3}{\cConstraint_1 \cup \cConstraint_2 \cup \Setof{\constrain{\TUnknown^{\mathsf{exp}(u)}}{\STMV_3}}}{\mConstraint}
    }

    \inferrule[MACMultiParent]{
    }{
        \anaConstraint{\ctx}{\multiref}{\STMV}{\constraintNil{}}{(\mathsf{idof}(v), w ,\ctx, ana(\STMV))}
    }
  
    \inferrule[MACUnicycle]{ 
    }{
        \anaConstraint{\ctx}{\uniref}{\STMV}{\constraintNil{}}{(\mathsf{idof}(v), w ,\ctx, ana(\STMV))}
    }

    \inferrule[MACInconsistentTypes]{
        \synConstraint{\ctx}{\ECMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \inconsistent{\STMV}{\STMV'} \\
        \subsumable{\EMV}
    }{
        \anaConstraint{\ctx}{\incontype}{\STMV}{\cConstraint}{\mConstraint}
    }

    \inferrule[MACSubsume]{
        \synConstraint{\ctx}{\ECMV}{\STMV'}{\cConstraint}{\mConstraint} \\
        \consistent{\STMV}{\STMV'} \\
        \subsumable{\EMV}
    }{
        \anaConstraint{\ctx}{\ECMV}{\STMV}{\cConstraint}{\mConstraint}
    }
\end{mathpar}


\judgbox{\subsumable{\ECMV}} $ECMV$ is subsumable
%
\begin{mathpar}
    \inferrule[UMSuVar]{ }{
    \subsumable{\eVar{u}{x}}
  }

  \inferrule[UMSuNum]{ }{
    \subsumable{\eNum{u}{n}}
  }

  \inferrule[UMSuPlus]{ 
    \subsumable{\ELMV_1} \\
    \subsumable{\ELMV_2}
  }{
    \subsumable{\plus{\ELMV_1}{\ELMV_2}}
  }

  \inferrule[UMSuTimes]{ 
    \subsumable{\ELMV_1} \\
    \subsumable{\ELMV_2}
  }{
    \subsumable{\mult{\ELMV_1}{\ELMV_2}}
  }

  \inferrule[UMSuAp]{
    \subsumable{\ELMV_1} \\
    \subsumable{\ELMV_2}
  }{
    \subsumable{\app{\ELMV_1}{\ELMV_2}}
  }

  \inferrule[UMSuMultiParent]{ }{
    \subsumable{\multiref}
  }

  \inferrule[UMSuUnicycle]{ }{
    \subsumable{\uniref}
  }
\end{mathpar}

\judgbox{\subsumable{\ELMV}} $\ELMV$ is subsumable
%
\begin{mathpar}
    \inferrule[UMSuHole]{ }{
        \subsumable{\emptyHole{v}{p}}
    }

    \inferrule[UMSuExp]{ 
        \subsumable{\ECMV}
    }{
        \subsumable{\lexp{\ECMV}}
    }
\end{mathpar}


\subsection{Mark erasure}
\label{sec:marked-mark-erasure}
$\judgbox{\markErase{\ECMV}}$ is a metafunction defined as follows:
%
\[\begin{array}{rcl}
  \erasesToRow{\eVar{u}{x}}{\eVar{u}{x}} \\
  \erasesToRow{\ECFree{\var{x}}}{\var{x}} \\
    \erasesToRow{\eNum{u}{n}}{\eNum{u}{n}} \\
  \erasesToRow{\plus{\ELMV_1}{\ELMV_2}}{\plus{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\mult{\ELMV_1}{\ELMV_2}}{\mult{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\reglam}{\lam{x}{\TLMV}{\markErase{\ELMV}}} \\
  \erasesToRow{\ECLamInconAsc{\var{x}}{\TLMV}{\ELMV}}{\lam{x}{\TLMV}{(\markErase{\ELMV})}} \\
  \erasesToRow{\ECLamAnaNonMatchedArrow{\var{x}}{\TLMV}{\ELMV}}{\lam{x}{\TLMV}{(\markErase{\ELMV})}} \\
  \erasesToRow{\eApp{u}{\ELMV_1}{\ELMV_2}}{\eApp{u}{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\eApp{u}{\ECApSynNonMatchedArrow{\ELMV_1}}{\ELMV_2}}{\eApp{u}{\markErase{\ELMV_1}}{\markErase{\ELMV_2}}} \\
  \erasesToRow{\ECInconType{\ECMV}}{\markErase{\ECMV}} \\
\end{array}\]
$\judgbox{\markErase{\ELMV}}$ is a metafunction defined as follows:
%
% \newcommand{\erasesToRow}[2]{\markErase{#1} & = & #2}
\[\begin{array}{rcl}
    \erasesToRow{\emptyHole{v}{p}}{\emptyHole{v}{p}} \\
    \erasesToRow{\lexp{\ECMV}}{\lexp{\markErase{\ECMV}}} \\
    \erasesToRow{\conflict{\ECMV}}{\conflict{\markErase{\ECMV}}}
\end{array}\]


\subsection{Metatheorems}
\label{sec:marked-metatheorems}
\begin{theorem}[name=Marking Totality] \
  \begin{enumerate}
    \item For all $\ctx$ and $\EMV$, there exist $\ECMV$ and $\STMV$ such that
      $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$.
    \item For all $\ctx$ and $\ELV$, there exist $\ELMV$ and $\STMV$ such that
      $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$.
    \item For all $\ctx$, $\EMV$, and $\STMV$, there exists $\ECMV$ such that
      $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$.
    \item For all $\ctx$, $\ELV$, and $\STMV$, there exists $\ELMV$ such that
      $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[name=Marking Well-Formedness] \
  \begin{enumerate}
    \item If $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$, then $\ctxSynTypeM{\ctx}{\ECMV}{\STMV}$ and
      $\erasesTo{\ECMV}{\EMV}$.
    \item If $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$, then $\ctxSynTypeM{\ctx}{\ELMV}{\STMV}$ and
      $\erasesTo{\ELMV}{\ELV}$.
    \item If $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$, then $\ctxAnaTypeM{\ctx}{\ECMV}{\STMV}$ and
      $\erasesTo{\ECMV}{\EMV}$.
    \item If $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$, then $\ctxAnaTypeM{\ctx}{\ELMV}{\STMV}$ and
      $\erasesTo{\ELMV}{\ELV}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[name=Marking of Well-Typed/Ill-Typed Expressions] \
  \begin{enumerate}
    \item \begin{enumerate}
        \item If $\ctxSynTypeU{\ctx}{\EMV}{\STMV}$ and $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$,
          then $\markless{\ECMV}$.
        \item If $\ctxSynTypeU{\ctx}{\ELV}{\STMV}$ and $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$,
          then $\markless{\ELMV}$.
        \item If $\ctxAnaTypeU{\ctx}{\EMV}{\STMV}$ and $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV}$,
          then $\markless{\ECMV}$.
        \item If $\ctxAnaTypeU{\ctx}{\ELV}{\STMV}$ and $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV}$,
          then $\markless{\ELMV}$.
      \end{enumerate}

    \item \begin{enumerate}
        \item If there does not exist $\STMV$ such that $\ctxSynTypeU{\ctx}{\EMV}{\STMV}$, then for
          all $\ECMV$ and $\STMV'$ such that $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\STMV'}$, it is not
          the case that $\markless{\ECMV}$.
        \item If there does not exist $\STMV$ such that $\ctxSynTypeU{\ctx}{\ELV}{\STMV}$, then for
          all $\ELMV$ and $\STMV'$ such that $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV}{\STMV'}$, it is not
          the case that $\markless{\ELMV}$.
        \item If there does not exist $\STMV$ such that $\ctxAnaTypeU{\ctx}{\EMV}{\STMV}$, then for
          all $\ECMV$ and $\STMV'$ such that $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\STMV'}$, it is not
          the case that $\markless{\ECMV}$.
        \item If there does not exist $\STMV$ such that $\ctxAnaTypeU{\ctx}{\ELV}{\STMV}$, then for
          all $\ELMV$ and $\STMV'$ such that $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV}{\STMV'}$, it is not
          the case that $\markless{\ELMV}$.
      \end{enumerate}
  \end{enumerate}
\end{theorem}

\begin{theorem}[name=Marking Unicity] \
  \begin{enumerate}
    \item If $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV_1}{\STMV_1}$ and
      $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV_2}{\STMV_2}$, then $\ECMV_1 = \ECMV_2$ and $\STMV_1 =
      \STMV_2$.
    \item If $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV_1}{\STMV_1}$ and
      $\ctxSynFixedInto{\ctx}{\ELV}{\ELMV_2}{\STMV_2}$, then $\ELMV_1 = \ELMV_2$ and $\STMV_1 =
      \STMV_2$.
    \item If $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV_1}{\STMV}$ and
      $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV_2}{\STMV}$, then $\ECMV_1 = \ECMV_2$.
    \item If $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV_1}{\STMV}$ and
      $\ctxAnaFixedInto{\ctx}{\ELV}{\ELMV_2}{\STMV}$, then $\ELMV_1 = \ELMV_2$.
  \end{enumerate}
\end{theorem}


