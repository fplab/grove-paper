
\section{Discussion and Conclusion}%
\label{sec:Discussion and Conclusion}
\begin{quote}
    \textit{``The fact that commutation can fail [in Darcs] makes a huge difference in the whole patch formalism. It may be possible to create a formalism in which commutation always succeeds, with the result of what would otherwise be a commutation that fails being something like a virtual particle ... and it may be that such a formalism would allow strict mathematical proofs ... However, I’m not sure how you’d deal with a request to delete a file that has not yet been created, for example. Obviously you’d need to create some kind of antifile, which would annihilate with the file when that file finally got created ...''} 
    
    -- David Roundy, Theory of patches~\cite{old-darcs-manual}
\end{quote}



This paper proposes a radically simpler, albeit practically ambitious, rearchitecture of collaborative editing. Our contributions together result in a typed collaborative structure calculus called Grove 
where, uniquely, all edits, including code relocations that stymie existing approaches, commute and where there are no semantic gaps: all possible editor states, including editor states with various kinds of unresolved conflicts, are semantically meaningful. 

This paper focuses on the core theoretical underpinnings of this approach,
developing mechanized metatheory for both the patch language and the type system. 
A number of research problems on algorithmic, networking, and user interface aspects of the problem open up given these foundations. For example, we point out several situations where presenting non-conflicted but heuristically attention-worthy merges may be worthwhile, and we leave to future work the user experience design of this process. We intend to use the Grove workbench to integrate these efforts into the Hazel programming environment, though its editor component has been evolving so rapidly as to prevent experimentation in this direction so far.

Although our focus was on tree editing, some aspects of a program are more naturally linearly structured, e.g. string literals. We also leave to future work the problem of combining existing work on sequence CRDTs~\cite{ahmed2011evaluating,kleppmann2020moving} with our work on tree/graph CRDTs.

% In practice, it may be helpful to garbage collect orphaned vertices once there is consensus across collaborators that the deletion is permanent, but we do not consider this consensus protocol formally in this paper. In an open-ended collaboration scenario (where the set of collaborators is not known, e.g. on GitHub), we simply retain all vertices.

% TODO: talk about linear sequences in code


% TODO: leaves

% TODO: our model supports treating these as a cons-list of characters

% TODO: (Place somewhere) This move semantics gives us a richer structure than
% when treating code as a list of lines.  We exploit
% this in Section~REF:TODO in order merge edits that involve moving code.

% TODO: Traditional diff: no relation (and indent might change)

% TODO: memory usage

% TODO: cache eviction algorithm

% TODO: Finally, note that through we present several complex scenarios, this is merely for presentation.
% In practice, these complex scenarios occur less frequently than portrayed here.

% \subsection{Variable names, strings, and numbers}%
% \label{sub:Variable names, strings, and numbers}

% NOTE: we could implement each digit as a separate characters

% GUI for string conflicts: use popups
