
\section{Grove By Example}%
\label{sec:Grove By Example}

This section introduces collaborative structure editing in Grove.
We begin in \autoref{sub:Program Representation} with how we use graphs to represent programs with holes.
\autoref{sub:Single-User Actions} explores actions performed by a single user, Alice,
and \autoref{sub:Multi-user Interactions} explores interactions between two users, Alice and Bob,
as they edit their own instances of a shared program.

\subsection{Program Representation}%
\label{sub:Program Representation}

\figureSimple{}

The \textit{edit state} of a Grove instance is a graph representing a program
in a language with concrete syntax for holes,
or terms that have not been written yet or have already been deleted.
For example, \autoref{fig:Simple:a} gives one such graph and its corresponding program,~\texttt{x * \hole},
whose missing right operand is denoted by $\hole$.

The edit state is a directed graph with a distinguished root vertex.
Each vertex represents a term in a hypothetical programming language
and is labeled with a globally unique identifier and a term constructor.     % TODO: should we informally define `constructor' here?
In \autoref{fig:Simple:a}, the root vertex has identifier 0 and constructor~\textbullet.
Terms \vSimpleTimes{} and \vSimpleX{} have constructors~\texttt{*} and \texttt{var(x)}, respectively.
For clarity, we abbreviate \texttt{var(x)} as simply \texttt{x}.

Each constructor has an associated set of \emph{child positions} for naming subterms.
For instance, the~\texttt{*} constructor has positions
for~\texttt{L}~(i.e., left child)
and~\texttt{R}~(i.e., right child).
The~\texttt{var} constructor has no child positions
and takes a variable name as an argument, e.g.,~\texttt{x} in \texttt{var(x)}.\footnote{Note that,
  for the purposes of this paper, we represent identifiers and number literals
  indivisibly.  See Section~TODO:REF, for how we would allow editing individual characters.}      % TODO: should we keep this footnote?
The root vertex constructor~\textbullet~has a single child position \texttt{Root}.

Each edge is labeled with a globally unique identifier~(e.g.,~1 and~3 in \autoref{fig:Simple:a})
and a child position (e.g., \texttt{Root} and \texttt{L} in \autoref{fig:Simple:a}).
An edge indicates that the destination vertex is a child of the origin vertex at the given position.
%Visually, we indicate the position of an edge by the location of its origin.
For clarity, we reserve odd numbers for vertex identifiers and even numbers for edge identifiers.

Finally, holes are represented by the absence of a child.
For example, in \autoref{fig:Simple:a} the absence of an \texttt{R} child under \vSimpleTimes{}
corresponds to the hole in the right operand of~\texttt{x * \hole}.

\figureWrapMove{}
% \figureMove{}

\subsection{Single-User Actions}%
\label{sub:Single-User Actions}

In the remainder of this section, we consider user actions and interactions,
starting in this subsection with a single user performing one edit at a time
and continuing in \autoref{sub:Multi-user Interactions} with multiple users performing single edits concurrently.

Each action by the user corresponds to one or more graph update operations.
Graph updates can only add fresh edges or vertices or remove existing edges.
All user actions are relative to an instance-local cursor and cursors are not replicated across instances.
We discuss cursor representations in detail in \autoref{sub:Cursors}.

\subsubsection{Construction Actions}%
\label{sub:Construction}

To start our examples, say Alice's cursor is on the hole in~\texttt{x * \hole} in \autoref{fig:Simple:a}.
Alice constructs the variable~\texttt{y}, which produces the edit state in \autoref{fig:Simple:b}.
This fills the hole by creating a new vertex \vSimpleY{} containing the variable reference
as a child of \vSimpleTimes{} at position \texttt{R} connected via edge \eSimpleY{}.
The resulting graph represents the expression \texttt{x * y}.

\subsubsection{Deletion Actions}%
\label{sub:Deletion}

% \figureMove{}

Next, Alice moves the cursor to~\texttt{x} and deletes it, leavingx~\texttt{\hole{} * y}.
This deletes edge~\eSimpleX{} as shown in \autoref{fig:Simple:c}.
Notice that vertex \vSimpleX{} continues to exist,
and if it had any children, those children would remain connected to it.

Once a vertex is created, it is never deleted.
This allows further interaction with those vertices by other users without risk of spontaneous cursor motion,
as shown later in this section.
In remaining diagrams, we omit such orphaned vertices if they are not relevant to the exposition.

Once an edge with a particular identifier is deleted, it cannot be recreated.
For instance, if Alice performed an ``undo'' on this deletion,
a fresh edge between \vSimpleTimes{} and \vSimpleX{} would be created.

\subsubsection{Wrapping Actions}%
\label{sub:Wrapping}

Next, Alice moves the cursor to parent vertex \vSimpleTimes{}
and constructs a binary addition expression with constructor~\texttt{+}.
If the cursor were on a hole,
a fresh term would be constructed in its place, as in \autoref{sub:Construction} above.
However, since Alice's cursor is on an existing term \texttt{*},
it is interpreted as a wrapping action instead of a construction action.
This corresponds to the following sequence of graph updates, shown in \autoref{fig:Wrap}:
(a) delete edge \eSimpleTimes{} leaving \vSimpleTimes{} temporarily orphaned,
(b) add fresh vertex \vWrapPlus{} as a child of the root vertex, and
(c) add fresh edge to \vSimpleTimes{} in left (\texttt{L}) child position of the new vertex.
Our choice here of wrapping with a bias for the left child position is arbitrary.

\subsubsection{Repositioning Actions}%
\label{sub:Repositioning}

We have two options for moving a term from one place to another.
The first is to delete the term from its original position and then reconstruct it in its new position.
Since edges are uniquely identifiable,
this option precludes the use of edge identities in any cursor representation,
as doing so would lead directly to the repositioning problem.

Consequently, we take the second option: explicit repositioning actions that preserve identities.
These could be triggered by, for example, a drag and drop or a cut and paste---but not a copy and paste,
or a second paste after a cut, which do not need to preserve identity
and so could rely on reconstruction as already described in \autoref{sub:Construction}.

In the graph, explicit repositioning involves simply deleting the edge from the original parent
and then adding a new edge to it from the new parent.
Thus the term is indeed \textit{repositioned}, not copied.

For example, in \autoref{fig:Move} Alice continues by
repositioning \texttt{\hole{} * y} from the left child of \texttt{+} to the right child.
This corresponds to the following sequence of graph edits, shown in \autoref{fig:Move}:
(a) delete \eWrapTimes{} leaving \vSimpleTimes{} temporarily orphaned and
(b) add \eMoveTimes{} to \vSimpleTimes{} in the right child position of \vWrapPlus{}.

% \figureDifferentParts{}
\figureDifferentPartsNestedParts{}

%\figureCommutativity{}
\begin{figure}
  \centering
  \begin{tikzpicture}
    \path (-3cm, 0cm) node (a) [align=center]            {Original \\ Version};
    \path ( 0cm, 1cm) node (b) [align=center,alice node] {Alice's  \\ Version};
    \path ( 0cm,-1cm) node (c) [align=center,bob node]   {Bob's    \\ Version};
    \path ( 3cm, 0cm) node (d) [align=center]            {Synchronized \\ Version};
    \path [draw,->,alice step] (a) -- node [pos=0.7,align=center,auto]      {Alice's \\ Edits} (b);
    \path [draw,->,bob step]   (a) -- node [pos=0.7,align=center,auto,swap] {Bob's \\ Edits}   (c);
    \path [draw,->,merge step] (b) -- node [pos=0.3,align=center,auto]      {Share \\ Edits} (d);
    \path [draw,->,merge step] (c) -- node [pos=0.3,align=center,auto,swap] {Share \\ Edits} (d);
  \end{tikzpicture}
  \caption{Commutativity of Edits.}
  \label{fig:Commutativity}
\end{figure}

\subsection{Multi-user Interactions}%
\label{sub:Multi-user Interactions}

We now turn our attention to how Grove handles multiple users.
The examples in this section generalize to any number of users,
but for simplicity we consider only two: Alice and Bob.
Alice and Bob each maintain their own editor instances independently
and perform actions relative to its state using their own cursors, as we discuss in \autoref{sub:Cursors}.

Users collaborate by sharing graph updates corresponding to user edits,
e.g., via direct network connections or relayed through a server.
% TODO: CITE(how to share network data -- DHT? consensus? ).
The granularity of communication may vary.
For real-time collaboration, graph updates may be sent as they occur.
For asynchronous version control, updates may be batched together in the form of commits.
As we will show, since these edits are commutative,
all instances converge to the same state once all updates are shared.
We assume users have some way to create globally unique identifiers
% for verticies and edges
without coordination~(e.g.,~GUIDs).
% TODO:CITE:GUIDS).

\subsubsection{Editing Different Parts of the Code}%
\label{sub:Editing Different Parts of the Code}

Alice and Bob start where Alice left off in the previous section
with the state \texttt{\hole{} + \hole{} * y} shown in \autoref{fig:Move:b}.
Alice then adds~\vDifferentPartsAlice{} as the left child of \vSimpleTimes{}.
At the same time, Bob changes \vSimpleY{} to \vDifferentPartsBob{}.
Before either shares their graph updates with the other,
Alice and Bob have the graphs in \autoref{fig:DifferentParts:a} and \autoref{fig:DifferentParts:b}, respectively.
Note that the transition from \autoref{fig:Move:b} to \autoref{fig:DifferentParts:b}
represents multiple graph updates,
i.e., deleting~\eSimpleY{} and adding~\eDifferentPartsBob{} along with its child~\vDifferentPartsBob{}.
We thus mark the transition with a star.
Once Alice and Bob share their graph edits and apply each other's updates to their own copy of the graph,
they both have the graph in \autoref{fig:DifferentParts:c}.

% \figureNestedParts{}

\subsubsection{Commutativity}%
\label{sub:Commutativity:informal}

% \todo{rev}
Note that aside from sharing edge deletions and additions,
merging requires no coordination between Alice and Bob.
For example, suppose Alice and Bob did not transmit their edits to each other
but instead to a third user, Chris.
Chris can apply the edits from Alice and Bob in any order
and will always get the graph in \autoref{fig:DifferentParts:c}.

In other words, our update model obeys the commutativity shown in \autoref{fig:Commutativity}.
For any sequences of edits from Alice and Bob,
applying them in any order always produces the same results.
(We show this formally in \autoref{sub:Commutativity:formal}.)

\subsubsection{Editing Nested Parts of the Code}%%
\label{sub:Editing Nested Parts of the Code}

After all of Alice's and Bob's updates have been shared,
they both have the edit state \texttt{\hole{} + u * y} in \autoref{fig:DifferentParts:c}.
Alice changes~\vDifferentPartsAlice{} to~\vNestedPartsAlice{},
producing the graph in \autoref{fig:NestedParts:a}.
Meanwhile, Bob repositions~\vSimpleTimes{} (along with its children)
from the~\texttt{R} child of~\vWrapPlus{} to its~\texttt{L} child
by deleting~\eMoveTimes{} and adding~\eNestedPartsBob{}.
The resulting graph is shown in \autoref{fig:NestedParts:b}.
Because updates are located by edge identifiers instead of by paths relative to the root vertex,
each of Alice's and Bob's updates can be applied to the other's graph
and afterwards they will both have the graph in \autoref{fig:NestedParts:c}.

Note that commutativity has consequences in this scenario.
Since all updates must eventually lead to the same edit state regardles of the order in which they are applied,
if Alice, say, receives Bob's deletion of~\eMoveTimes{}, makes some local changes,
and then receives Bob's addition of~\eNestedPartsBob{},
the result must still be the graph in \autoref{fig:NestedParts:c}.
In that case, Alice's edits would then temporarily be within the term deleted by Bob.
Thus, our semantics must allows users to edit deleted terms.
Whether or how this is presented in the user interface is another question.

% TODO: \todo{TODO}She can restore that code using a restoration action add a fresh edge to it.

\subsection{Merge Conflicts}%
\label{sub:Merge Conflicts}

Although the collaborative edits discussed so far merge cleanly,
they can also lead to graphs that do not map cleanly to a syntax tree.
We call these states \emph{conflicts}
and consider separate cases for \emph{multi-child}, \emph{multi-parent}, and \emph{unicycle} conflicts.
As with merge conflicts in version-control systems such as git, these all require user intervention to resolve.
We consider common merge scenarios first, then move onto more unusual scenarios.
 
\subsubsection{Multi-child conflicts}%
\label{sub:Multi-child conflicts}

\figureMultiChild{}

Suppose Alice and Bob both have the edit state \texttt{w * v + \hole} in \autoref{fig:NestedParts:c}.
Alice moves the cursor to the hole and constructs~\vMultiChildAlice{} as the~\texttt{R} child of~\vWrapPlus{}.
At the same time, Bob constructs~\vMultiChildBob{} in the same position.
Now Alice and Bob have the graphs in \autoref{fig:MultiChild:a} and \autoref{fig:MultiChild:b}, respectively.
Note that these graphs have two different edges,
\eMultiChildAlice{} and \eMultiChildBob{}, for the~\texttt{R} position of~\vWrapPlus{}.

We merge these edits by including \emph{both} \eMultiChildAlice{} and \eMultiChildBob{}
as edges originating from the \texttt{R} position of \vWrapPlus{}.
This results in a multi-child conflict in the~\texttt{R} position of~\vWrapPlus,
shown in \autoref{fig:MultiChild:c},
where there are multiple edges originating from the same position of a vertex.
In the user interface, we flag this conflict with the notation~$\conflictHole{x,y}$.

% TODO: "delete both"

Such conflicts can be resolved by deleting one of the conflicting edges
and editing the remaining term into the correctly merged value.
For example, Alice could delete \eMultiChildBob{} and then change~\vMultiChildAlice{} into~\texttt{x * y}.
% To ensure users can continue editing while in a conflicted state,
% all conflicts must be resolved before a program can be run.\footnote{It
%   may be possible to develop evaluation models that allow these sorts of conflicts,
%   but that is beyond the scope of this paper.})
% % TODO: need example of fully-automatic resolution and semi-automatic resolution.
% Note that as a convenience to the user, certain simple conflicts might be automatically resolved,
% but we consider this a higher-level, user-interface consideration.
Handling conflicts in this way is similar to handling traditional merge conflicts
in that it presents alternate versions of the conflicted state
that must be transformed by users into the desired result.
Our approach is different in that merge conflicts in a line-based model
may break semantic editor services, such as semantic search or type-preserving refactorings,
that could continue to work inside and outside the conflict in a graph-based model.
% It is just the where the multi-child happens that editor services may break down.
\autoref{sec:Related Work} discusses more differences.

\subsubsection{Multi-parent conflicts}%
\label{sub:Multi-parent conflicts}

\figureMultiParent{}

Multi-parent conflicts occur when multiple edges share a destination vertex,
as opposed to multi-child conflicts which share a common origin.
An example of this is in \autoref{fig:MultiParent},
which shows the edit state Alice and Bob converge on after deleting the conflict and the \texttt{v}.
Alice then moves~\vNestedPartsAlice{} to the~\texttt{R} position of~\vSimpleTimes{}.
At the same time, Bob also moves~\vNestedPartsAlice{} to the~\texttt{R} position of~\vWrapPlus{}.
This results in the edit states of \autoref{fig:MultiParent:b} and \autoref{fig:MultiParent:c}
In both cases, the edits are modeled as one edge deletion followed by one edge addition.
Alice deletes~\eNestedPartsAlice{} and adds~\eMultiParentAlice{}.
At the same times, Bob deletes~\eNestedPartsAlice{} and adds~\eMultiParentBob{}.
As we explain in \autoref{sec:Formalism}, deletions are idempotent,
so the fact that Alice and Bob both deleted~\eNestedPartsAlice{} will not lead to a conflict.
However, both~\eMultiParentAlice{} (added by Alice) and~\eMultiParentBob{} (added by Bob)
point to the same vertex.
Once all updates are merged, the resulting edit state is given in \autoref{fig:MultiParent:d}.
Notice~\vNestedPartsAlice{} has two edges pointing to it.

TODO: talk about how to resolve the conflict

% \subsubsection{Single-User Cycles}
% \label{sub:Cycles}

% TODO: cut this section

% \figureSingleUserCycles{}

% Another case we must consider is when cycles appear in the graph.
% We categorize these into cycles caused by the action of a single user
% and cycles caused by the interaction of the actions of multiple users.

% In a single user context,
% normal insertion and deletion of code by the user cannot create cycles.
% However, it is possible with certain kinds of copy and paste.
% For example, suppose Alice is editing the code in \autoref{fig:Single-User Cycles:a}
% and uses copy and paste to copy \Vertex{TODO} to the right child of \Vertex{TODO}.
% There are two ways to interpret the paste action.
% The first interpretation is to create a deep copy of \Vertex{TODO}.
% This results in \autoref{fig:Single-User Cycles:b} and
% does not cause a cycle.
% The second interpretation is to simply add an edge to \Vertex{TODO}.
% This results in \autoref{fig:Single-User Cycles:b}
% and causes a cycle.

% Note that not all pastes should be deep copies.
% For example, Alice may have accomplished code move in \autoref{sub:Editing Nested Parts of the Code}
% by a cutting from the old position and pasting to the new position.
% Preserving Bob's nested edits requires that the paste be by reference instead of by copy.
% Distinguishing when a paste should be by reference versus by copy
% is ultimately a user interface question.
% Cycles caused by the local user's edits can be detected as soon as a user enters them
% by noting either that the graph would contain a cycle or the vertex
% already has a parent somewhere in the graph.

% Thus, as a user interface consideration, it might be best to either
% disallow such edits to at least warn users when their
% edits would create a cycle.

\subsubsection{Cycles}%
\label{sub:Multi-User Cycles}

\figureCycle{}

In addition to multi-child and multi-parent conflicts, merges
can cause cycles in the graph.\footnote{In theory a single user could
generate cycles, but this could be detected immediately and the user action
that caused that cycle rejected.
Thus, we are only concerned with cycles that cannot be immediately detected
and prevented by the editor.}
For example, consider the situation in \autoref{fig:Cycle}.
\autoref{fig:Cycle:a} shows the graph after Alice and Bob have made some edits,
and shared them with each other.
Alice then moves~\vMultiCycleTimes{} to the \texttt{R} child of~\vWrapPlus{}
and then~\vMultiCyclePlus{} underneath that.
Bob does the same but puts~\vMultiCycleTimes{} under~\vMultiCyclePlus{}.
This results in \autoref{fig:Cycle:b} and \autoref{fig:Cycle:c}, respectively.

On their own, neither of these edits creates a cycle.
However, merging the edit actions of both Alice and Bob results in the graph
in \autoref{fig:Cycle:d}, which has a cycle
between~\vMultiCycleTimes{} and~\vMultiCyclePlus{}.
As with the other kinds of conflict, resolving it requires user input.
For example, by either deleting both~\eMultiCycleBobPlus{} and~\eMultiCycleBobTimes{}~(thus favoring Alice's version)
or deleting both~\eMultiCycleAliceTimes{} and~\eMultiCycleAlicePlus{}~(thus favoring Bob's version).

\paragraph{Disconnected Cycles}

\figureDisconnect{}

TODO: technically a cycle

TODO: in general detect when there are or were edits to something now deleted

\todo{UI would show orphans only once edits orphans occur}

Finally, there is a particular type of cycle worth discussing.

Since a cycle like this that is connected to the root vertex always
contains vertexes with multiple parents that if removed would break the cycle,
we use the user interface described in \autoref{sub:Multi-parent conflicts}
to display these kinds of programs.
For example, \autoref{fig:Cycle:d} would be displayed.
We leave the user interface considerations of resolving the conflict such a
cycle represents to future work.

Finally, when multi-user edits are merged,
parts of the graph can become disconnected from the root
even though they are connected to the root in each user's
copy of the graph before the merge.

For example, consider the situation in \autoref{fig:Disconnect:a},
which shows the graph after Alice and Bob have made some edits,
and shared their edits with each other.
Alice then moves~\vMultiCycleTimes{} under~\vSimpleTimes{},
while Bob moves~\vSimpleTimes{} under~\vMultiCycleTimes{}.
This results in \autoref{fig:Disconnect:b} and \autoref{fig:Disconnect:c}, respectively.

When these edits are merged, the result is \autoref{fig:Disconnect:d}.
Since Alice deleted~\eNestedPartsBob{}
and Bob deleted~\eMultiCycleAliceTimes{},
when these are merged~\vMultiCycleTimes{} and~\vSimpleTimes{}
are disconnected from the root.

This is similar to the type of merge conflict
that can arise in traditional version control systems
when two users delete different functions that
are duplicates of the other.

Fortunately, we can detect this situation and warn the user
since the disconnection appears after merging two graphs
in which vertexes were not already disconnected.

\subsection{Cursors}%
\label{sub:Cursors}

\paragraph{Representation}

For most editing a cursor is represented by a position within a vertex.
For example, in TODO, Bob's cursor might be at the TODO position of the TODO:vertex.
Representing it this way means that if Bob or some other user deletes TODO:vertex
and replaces it with a different vertex, Bob's cursor is still valid.
We specify a position within a vertex instead of a vertex because TODO.

However, there is one case where we need a more precise cursor.
That is when a vertex has a multi-child conflict (e.g. TODO in FIG:TODO).
We want users to beable to put their cussor on either the conflict as a whole
(e.g., TODO: \texttt{\{ x | y \}})
or on an individual element (e.g., \texttt{x} or \texttt{y}).
In the former case, a pair of a vertex and a child position suffices.
For the latter case, we represent cursors by an edge identifier (e.g., TODO in TODO:FIG).

\paragraph{Communication}

In our system all edits use edge and vertex identifiers, and user
cursors do not affect the interpretation of graph edits.
Thus, cursors need not be communicated to other users.
However, in a collaborative setting, seeing the cursors of other users
can be useful.
For this purpose, editors can announce their cursor position to other editors.
At any point in time, the announcement
with the most recent timestamp
for a particular user
is used.

Note that this cursor position may refer to edges or verticies that
do not yet exist on the receivers machine.
In these cases, we can either not display the other user's cursor (and perhaps
have a visual display flagging this fact), or we can display the most recent
cursor that represents a valid position in the local graph (perhaps
shown in a fadded color to show that this cursor is known to not be up to date).
(Or perhaps, all cursors always fade/decay over time like on radar blips.)
