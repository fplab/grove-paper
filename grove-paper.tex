%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous,nonacm]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

\renewcommand{\topfraction}{1} % Allow floats to take up the page
\renewcommand{\textfraction}{0}


%% Packages
\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{graphicx}

% Support \includegraphics of .dot files
\DeclareGraphicsRule{.dot}{pdf}{.pdf}{`dot -Tpdf #1 -o \noexpand\OutputFile}


%%%%%%%%
% TikZ Stuff
%\usepackage{etex} % Fix "No room for new \dimen" error
\usepackage{shellesc} % Fix bug that breaks the tikz 'external' library
\usepackage{tikz}
\usetikzlibrary{babel} % Ensure compatibility the 'babel' package

\usetikzlibrary{external} % Needs to be separately enabled
%\tikzexternalize % Enable externalization
%\usepackage{lua-visual-debug}

\usetikzlibrary{arrows.meta} % Arrow Tips
\tikzset{>=Stealth}
%\tikzset{<=stealth}
%\tikzset{arrows={-Stealth[scale=50]}}
%\tikzset{edge from parent/.style={draw,->,line width=0.6pt}}
%\tikzset{wideline/.style={line width=0.7pt}}
%\tikzset{boldline/.style={color=black,line width=1.0pt}}

\usetikzlibrary{
  graphs,       % Graph *notation*
  graphdrawing, % Graph *layout*
}

\usegdlibrary{
  trees,
}

%%%%%%%%
% Lang components

% sets
\def\E{\mathcal{E}}
\def\G{\mathcal{G}}
\def\I{\mathcal{I}}
\def\K{\mathcal{K}}
\def\U{\mathcal{U}}
\def\V{\mathcal{V}}

% constructors
\def\ExpVar{\mathsf{Exp\_var}}
\def\ExpLam{\mathsf{Exp\_lam}}
\def\ExpApp{\mathsf{Exp\_app}}
\def\ExpNum{\mathsf{Exp\_num}}
\def\ExpPlus{\mathsf{Exp\_plus}}
\def\PatVar{\mathsf{Pat\_var}}
\def\TypNum{\mathsf{Typ\_num}}
\def\TypArrow{\mathsf{Typ\_arrow}}

% indexes
\def\Root{\mathsf{Root}}
\def\LamParam{\mathsf{Lam\_param}}
\def\LamType{\mathsf{Lam\_type}}
\def\LamBody{\mathsf{Lam\_body}}
\def\AppFun{\mathsf{App\_fun}}
\def\AppArg{\mathsf{App\_arg}}
\def\PlusLeft{\mathsf{Plus\_left}}
\def\PlusRight{\mathsf{Plus\_right}}
\def\ArrowArg{\mathsf{Arrow\_arg}}
\def\ArrowResult{\mathsf{Arrow\_result}}

% relations
\DeclareMathOperator{\arity}{\text{arity}}

\newcommand{\hole}{\ensuremath{\square}} %\textcolor{violet}{\llparenthesis}}\textcolor{violet}{\rrparenthesis}}

\begin{document}

%% Title information
\title[Grove]{Grove: A Convergent Collaborative Structure-Editor Calculus}
%\subtitle{Subtitle}

%% Author information
\author{Michael D. Adams}
\orcid{0000-0003-3160-6972}

\author{Eric Griffis}
\orcid{nnnn-nnnn-nnnn-nnnn}

\author{Cyrus Omar}
\orcid{0000-0003-4502-7971}
\affiliation{
  \position{Assistant Research Scientist}
  \department[0]{Computer Science and Engineering}
  \department[1]{Electrical Engineering and Computer Science}
  \department[2]{College of Engineering}
  \institution{University of Michigan}
  \streetaddress{Bob and Betty Beyster Building, 2260 Hayward Street}
  \city{Ann Arbor}
  \state{MI}
  \postcode{48109-2121}
  \country{USA}
}


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10011007.10011006.10011008</concept_id>
%<concept_desc>Software and its engineering~General programming languages</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%<concept>
%<concept_id>10003456.10003457.10003521.10003525</concept_id>
%<concept_desc>Social and professional topics~History of programming languages</concept_desc>
%<concept_significance>300</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}
%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
% \keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{sec:introduction}

Motivation: 
- collaborative editing (both synchronous ala Google Docs and asynchronous version control) 
  is good and important as computing grows
- semantic structure editing is good because it solves the gap problem (semantic editor services 
  are always available) -- cite Hazelnut papers (talk about holes)
- previous approaches to collaborative editing have limitations
  - diff/merge based approaches (trying to solve the inverse problem based on final states -- 
    you lose the actual actions that were performed, and have to reconstruct them or an approx.
    of them i.e. add line/delete line actions -- would need to adapt this to structure editing,
    some papers have started to look at that, but fundamentally we don't want to throw away the
    knowledge we have about the edits!)
  - operational transforms (complexity, you have to patch previous actions based on new actions)
  - CRDT-based collaborative editing (that's all been on text, not PL semantics) -- this is good
    because it is relatively simple: you just send all the edits to all the replicas and they are 
    convergent by design
- we want to have the same convergence for a CRDT-based collaborative structure editor that maintains
  the sensibility invariant of Hazelnut, i.e. every editor state has meaning. mention that maintaining sensibility 
  allows scaling of semantic editor services in the presence of large number of collaborators (in contrast,
  using VS Code or other collaborative text editors with large numbers of collaborators means that almost always
  the semantic editor services will be disabled because the program is going to be broken in multiple places
  transiently)

  this is tricky because:
  - some edits might be conflicting -- solve this with "conflict holes"
  - adding cut/paste or delete/restore allows for degenerate programs (cycles, multiple parents, etc.)
- since we are commutative, we solve both synchronus and async collaborative editing
  - and this resolves issues around merges and conflicts
- contribution of this paper is to solve these problems from type-theoretic first principles:
  - ...
- Hazel

\subsection{Contributions and Paper Organization}
\label{sec:paper-organization}

\section{Grove By Example}
\label{sec:grove-by-example}

TODO: gray-scale unchanged parts of diagrams

TODO: somewhere in here, maybe multiple places, we want to talk about typing the intermediate states that arise

TODO: annotate vertexes and edges with ids (gray superscript?)

Single User Intuition:
 - manipulating trees,
 - holes

Multi User Intuition:
 - vertexes have unique ids
 - edits create or delete edges in the tree,
 - vertexes are automatically created when an edge goes to it
 
Deeper intuition:
 - edges have unique ids
 - once deleted an edge can never be recreated (though, a new edge (with a new id) can be created in the same spot as the original)

For presentational simplicity we omit param\_type in all lambdas

\subsection{Structure Editing}

We present this at two levels.
One is the underlying graph model, which
involves explicit identifiers, graph edges, indexes, and add and delete
operations.

The other is the interface a user might see,
which omits these details unless needed.

Throughout these examples the graph model is presented
as a graph with.

\subsubsection{Trees and Holes}
\label{sub:Trees and Holes}

TODO: explain holes.

\begin{figure}
\centering 
\includegraphics[scale=0.75]{graphviz/simple-tree-with-hole/1.dot}
\caption{A simple tree with a hole}
\label{fig:A simple tree with a hole}
\end{figure}
NEEDS UI EXAMPLE

Consider the tree in Figure~\ref{fig:A simple tree with a hole},
which represents the code \texttt{2 + \hole}.

Note that this tree contains three vertexes.
The first is depicted with a simple dot and is the root vertex.
The other two are labeled \texttt{plus} and \texttt{num(2)}
and represent the plus operator and the numeric literal 2, respectively.

Each vertex has a unique identifier and a list of positions
for child vertexes.
In this figure, the \texttt{plus} and \texttt{num(2)} vertexes have
identifiers 3 and 6 respectively,
the \texttt{plus} vertex has positions for its left and right children
and the \texttt{num(2)} vertex has no positions for any children.
The root vertex has the distinguished identifier 0
and has one position for its children.

Also each edge has a unique identifier. In Figure~\ref{fig:A simple tree with a hole},
these edges have idenifiers 4 and 7.  These are used
when adding and deleting edges as discussed in the
next subsubsection.

In this paper we represent variables and numeric constants
as leaves and represent their names or values as
arguments to those constructors (e.g., \texttt{2} in \texttt{num(2)}).
(In TODO:REF, we discuss how to allow edits within these.)

TODO: web page Svg ?

Declarative sentences

Outline refinement

The edge coming out of it to the TODO:word of the expression.
We call this the \emph{rooted} vertex.

\subsubsection{Delete and Add}

\begin{figure}
\centering
\begin{tikzpicture}
\path (0,0)    node {\includegraphics[scale=0.75]{graphviz/delete-and-add/1.dot}};
\path (0,-4cm) node {\includegraphics[scale=0.75]{graphviz/delete-and-add/2.dot}};
\path (0,-8cm) node {\includegraphics[scale=0.75]{graphviz/delete-and-add/3.dot}};
\end{tikzpicture}
\caption{Delete and Add}
\label{fig:Delete and Add}
\end{figure}
NEEDS UI EXAMPLE

We model edits to the code as sequences of deletions and additions of edges to this graph.
For example, consider the first graph in Figure~\ref{fig:Delete and Add}, which
represents the expression \texttt{1 + 2}.
Suppose we want to change the \texttt{2} into a \texttt{3} so the expression
becomes \texttt{1 + 3}.
We model this by first deleting edge~7.
This results in the middle graph in Figure~\ref{fig:Delete and Add}, which
represents the expression \texttt{1 + \hole}.
Note that vertex~9 still exists and can be manipulated (which we will exploit in the next subsection).
Vertex~9 is just not reachable from the root.

After that deletion, we then add a new vertex to represent~\texttt{3} and an
edge to it.  This results in the bottom graph in Figure~\ref{fig:Delete and Add}.

Note that this edge has a new identifier distinct from the one before.
An edge once deleted cannot be restored.  Instead a new edge (with a new id) is created.

Explain orphans

Note that we will omit orphans from diagrams if they are not relevant
(e.g., they are deleted and are not added back later)

Note that we do not explicitly delete or add vertexes.
Our only actions are deleting or adding \textit{edges}.
Vertexes are implicitly created whenever an edge
is created that points to it.
Deleting vertexes is not necessary, as we can simply
remove the edge pointing to it.

\subsubsection{Move}

\begin{figure}
\centering
\begin{tikzpicture}
\path (0,0)    node {\includegraphics[scale=0.75]{graphviz/move/1.dot}};
\path (0,-5cm) node {\includegraphics[scale=0.75]{graphviz/move/2.dot}};
\path (0,-9cm) node {\includegraphics[scale=0.75]{graphviz/move/3.dot}};
\end{tikzpicture}
\caption{Move}
\label{fig:Move}
\end{figure}

An interesting consequence of our design is that a move operation
does not have to delete code from one position and create a copy
in another position.
Instead, by deleting just the edge to the code to be moved and then
adding a new edge to that code somewhere else, the actual code is
moved, not just a copy.

For example, consider Figure~\ref{fig:Move}, which represents
the movement of \texttt{1 * 2} from the left child of \texttt{plus}
to its right child.  The top graph is the code before the move.
First, edge~7 is deleted, which results in the middle graph
where the rooted code is now \texttt{\hole{} + \hole},
and vertex~6 is orphaned.

Next edge~16 is added, which results in the bottom graph
where the rooted code is now \texttt{\hole{} + 1 * 2},
and vertex~6 is no longer orphaned.

This move semantics gives us a richer structure than
when treating code as a list of lines.  We exploit
this in Section~REF:TODO in order merge edits that involve moving code.

Of course, if the user wants a genuine copy
and not just a move, that can be achieved
by creating new vertexes with fresh identifiers.
(TODO: figure for this?)

This is similar to the paste with formatting versus
paste without formatting.

If only one restore, then it does what you expect (basically a cut and paste)

If multiple replicas restore to different places, then you get some complexity:

\subsection{Collaborative Structure Editing}

\subsubsection{Editing Different Parts of the Code}

\begin{figure}
\centering
TODO: add screenshot of code text to each node
TODO: remove orphans from diagram
\begin{tikzpicture}
\path (0,0)       node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/1.dot}};
\path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/2A.dot}};
\path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/2B.dot}};
\path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/3.dot}};
\end{tikzpicture}
\caption{Editing Different Parts of the Code}
\label{fig:Editing Different Parts of the Code}
\end{figure}

When editing different parts of the code

For example, suppose there are users, A and B,
that are synchronized with each other and
have the code \texttt{3 + 4}.
That is to say, they both have
the top graphs in Figure~\ref{fig:Editing Different Parts of the Code}.

Next, suppose user A changes the \texttt{3} to a \texttt{13},
and user B changes the \texttt{4} to a \texttt{14}.
Before transmitting their edits to each other,
user A thus has left graph and user B has the right graph.
For user A, this involves deleting edge~7 and creating edge~14.
For user B, this involves deleting edge~10 and creating edge~18.

To merge these two graphs each user simply replays the edge deletions and additions
that the other user performed.

Both user then have the bottom graph and are again synchronized with each other.

Note that aside from transmitting the edge deletions and additions,
no coordination between A and B is needed to coordinate the merge.
For example, suppose that A and B did not transmit their edits to each other
but to a third user, C, that has the original graph at the top of Figure~\ref{fig:Editing Different Parts of the Code}.
User C can replay the edits from A and B in any order and will always get
the graph at the bottom of Figure~\ref{fig:Editing Different Parts of the Code}.

Stated more formally, our edit model obeys commutativity
as shown in Figure~\ref{fig:Commutativity}.
For any two sequences of edits $\vec{\alpha}$ and $\vec{\alpha}^\prime$,
applying them in either order produces the same results.

\begin{figure}
\centering
TODO: commutativity diagram of screenshots with two cursors
\caption{TODO:Commutativity}
\label{fig:Commutativity}
\end{figure}

\subsubsection{Editing Nested Parts of the Code}

(Similar to how git merged across moves.
A notable difference though is that \texttt{git} detects
file moves by structural similarity rather than
our nominal equality.
(We exploit this in Subsection~REF:TODO).

\begin{figure}
\centering
TODO: add screenshot of code text to each node
TODO: remove orphans from diagram
TODO: annotate edges with delete and restore
\begin{tikzpicture}
\path (0,0)       node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/1.dot}};
\path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/2A.dot}};
\path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/2B.dot}};
\path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/3.dot}};
\end{tikzpicture}
\caption{Editing Nested Parts of the Code}
\label{fig:Editing Nested Parts of the Code}
\end{figure}

Consider Figure~\ref{fig:Editing Nested Parts of the Code}.
Alice and Bob both start with the top graph, which represents the code \texttt{2 * x + \hole{}}.
Alice changes the \texttt{2} to a \texttt{3}, which results in the left graph.
Bob moves the \texttt{2 * x} from the left of the plus to the right of the plus
by deleting edge~7 and adding edge~16, which results in the right graph.
Since vertex and edge identifiers are preserved by these,
both Alice's and Bob's edits can be applied to the other's graph,
which results in both Alice and Bob having the bottom graph.

As with Subsection~SEC:TODO, this merge does not require coordination
between Alice and Bob.  They could independently send their edits
to a third party, Charley, who could replay their edits in any order
and will always get the bottom graph.

A consequence of this design is that we allow users to edit
parts of the code that have been deleted.  For example,
Alice might receive Bob's deletion of edge~7 before making her
edits and before receiving Bob's adding of edge~16.
Her edits would then be within the code deleted by Bob.

TODO:figure

Contrast with a traditional diff

\subsubsection{Direct conflicts}

\begin{figure}
\centering
\begin{tikzpicture}
\path (0,0)       node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/1.dot}};
\path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/2A.dot}};
\path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/2B.dot}};
\path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/3.dot}};
\end{tikzpicture}
\caption{Direct Conflicts}
\label{fig:Direct Conflicts}
\end{figure}

Finally, we address genuine conflicts between edits.
Consider the top graph of Figure~\ref{fig:Direct Conflicts}.
Suppose Alice inserts the number literal \texttt{2} into the body of the lambda
while Bob inserts the function application \texttt{f x} also into the body of the lambda.
These results in the left and right graphs of \ref{fig:Direct Conflicts} respectively.
In particular pay attention to the edges going out of the \texttt{body} index of node~3.
In the left graph it is edge~10, which points to a number literal,
and in the right graph it is edge~13, which points to a function application.

We merge these by including \emph{both} edges as edges going out of the \texttt{body} index
of node~3.
This results in the bottom graph of Figure~\ref{fig:Direct Conflicts}.
The conflict between Alice's and Bob's changes is
represented by the fact that there are multiple edges going out of one index (i.e. the \texttt{body}
index of node~3).
In the graph representation, we flag this conflict by highlighting its edges
in red.
In the textual representation, we flag this conflict with the notation \texttt{\{ 2 | f x \}}.
This is a conflict that much eventually be resolved by the user by deleting
one of the edges and editing the other to be the merged value.
For example, one could delete edge~10 and then edit the \texttt{x}
to be \texttt{x + 2}.
Note that users can continue to edit the code while in this conflicted state.
It just must be resolved before the the code can be run.\footnote{
It may be possible to develop evaluation models that allow these sorts of conflicts,
but that is beyond the scope of this paper.}.

Compare this to what happens when there are conflicts in a traditional,
line/diff-based version control system (e.g., \texttt{git}, \texttt{mercurial}, \texttt{svn}, etc.).
Those systems annotate files with difference markers (e.g., sequences of \texttt{<}, \texttt{>}, or \texttt{=})
when a merge conflict happens.
These show alternate versions versions of the code, and it is up to the user
to replace those alternates with the desired merged result.

Our tree-based model is similar in that it presents alternate versions
of the code, and it is up to the user to replace those alternates with the desired merged result.
Our model is different, in that merge conflicts in the line-based model
prevent some semantic editor services from running
that could continue to run in the tree-based model because
code inside and outside the conflict is still valid code.
It is just the point where they meet the poses a potential problem for editor services.
Another place our model is different
is that changes are explicit rather than being inferred.
Finally, in our model, since all changes are in terms of
the structure of the code rather than lines,
all changes respect that structure.
This is unlike the line-based model where there is no guarantee
that a merge conflict follows the structure of the code.
Finally, our model differs from the traditional model
in that we have explict add and remove actions
where the traditional model infers these from a differencing algorithm.

Note that as a convenience to the user, certain simple
conflicts might be automatically resolved,
but we consider this a higher-level, user-interface consideration.

TODO: need example of fully-automatic resolution and semi-automatic resolution

Multiple adds cause conflicts
(Not usually presented in the UI)


\subsubsection{Wrapping Code}

\begin{figure}
\centering
TODO: naive add that creates a conflict
\begin{tikzpicture}
\path (0,0)       node {\includegraphics[scale=0.5]{graphviz/wrapping/1.dot}};
\path (0cm,-4cm)  node {\includegraphics[scale=0.5]{graphviz/wrapping/2.dot}};
\path (0cm,-8cm)  node {\includegraphics[scale=0.5]{graphviz/wrapping/3.dot}};
\path (0cm,-12cm) node {\includegraphics[scale=0.5]{graphviz/wrapping/4.dot}};
\path (0cm,-16cm) node {\includegraphics[scale=0.5]{graphviz/wrapping/5.dot}};
\end{tikzpicture}
\caption{Wrapping}
\label{fig:Wrapping}
\end{figure}

Before further exploring how to merge changes from multiple users,
we want to point out a common idiom that we call \emph{wrapping}.
Consider the first graph in Figure~\ref{fig:Wrapping}, which
represents the code \texttt{$\lambda$ x . x}, and suppose
the user's cursor is in the body field of the lambda (i.e., around the variable
reference to \texttt{x} in the body of the lambda).

If the user requests that a plus be inserted,
the editor may notice that there is something already in that hole.
A naive editor could certainly add the plus by creating a new
edge from the body index of the lambda to a freshly created \texttt{plus} vertex.
This would result in a conflict between the \texttt{plus} and the existing \texttt{var}
as shown in Figure~REF:TODO.
A better user experience
would be interpret the request for a plus to mean to
take whatever (if anything) is in the cursor
and place it as a child of the plus.
This \emph{wraps} the existing \texttt{var} in the \texttt{plus}
and results in the code \texttt{$\lambda$ x . x + \hole}.
(This is similar to the behavior in other structure editors such as in CITE:TODO.)
Translating this into edge deletes and adds results in the sequence of graphs in Figure~\ref{fig:Wrapping}.
Note that this is a layer above

Traditional: no relation (and indent might change)

\subsubsection{Conflicting wrap operations}
Multi-parent

\begin{figure}
\centering
\begin{tikzpicture}
% TODO: texttt
% TODO: position the different graphs
\path (0,0)       node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/1.dot}};
\path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/2A.dot}};
\path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/2B.dot}};
\path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/3.dot}};
% \path (0cm,0cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     x
%   }
% };
% \path (-3cm,-2cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     + -> {
%       1,
%       x
%     }
%   }
% };
% \path (3cm,-2cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     * -> {
%       x,
%       2
%     }
%   }
% };
% \path (0cm,-4cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     + -> {
%       1,
%       x
%     },
%     * -> {
%       x,
%       2
%     }
%   }
% };
% \path (2cm,-8cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     + -> {
%       1,
%       * -> {
%         x,
%         2
%       }
%     }
%   }
% };
% \path (-2cm,-8cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     * -> {
%       + -> {
%         1,
%         x
%       },
%       2
%     }
%   }
% };
\end{tikzpicture}
\caption{Conflicting wraps}
\label{fig:Conflicting wraps}
\end{figure}

TODO: SHOW intermediate Steps (maybe no graph)
  Show user's perspective
  Accept one side = delete others (select this)
  Delete x in *
  Move + to x


\begin{figure}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[tree layout] {
  lam[as={$\lambda_{\texttt{x}}$}] -> {
    + -> {
      1,
      x
    },
    * -> {
      x,
      2
    }
  }
};
\path (2cm,-4cm) graph[tree layout] {
  lam[as={$\lambda_{\texttt{x}}$}] -> {
    + -> {
      1,
      * -> {
        x,
        2
      }
    }
  }
};
\path (-2cm,-4cm) graph[tree layout] {
  lam[as={$\lambda_{\texttt{x}}$}] -> {
    * -> {
      + -> {
        1,
        x
      },
      2
    }
  }
};
\end{tikzpicture}
\caption{Wrap Resolution}
\label{fig:Wrap Resolution}
\end{figure}

NEEDS UI MOCKUP

Say: "might not be a popup"

\subsubsection{Cycles}

Synthetic cycles:

DIAGRAM: restoring into yourself (paste before delete?)

Organic cycles:

DIAGRAM: if cycles between "1 +" and "2 *" in previous diagrams

NEEDS UI MOCKUP

(Maybe not in initial grove by example) The A and B diamond example

\section{Formalism}
\label{sec:formalism}

\subsection{Syntax}

% $\arraycolsep=2pt\begin{array}{llcl}
% \mathsf{Typ} & \tau & ::= & t ~\vert~ \aparr{\tau}{\tau} ~\vert~ \aall{t}{\tau} ~\vert~ \arec{t}{\tau} ~\vert~ \aprod{\labelset}{\mapschema{\tau}{i}{\labelset}} ~\vert~ \asum{\labelset}{\mapschema{\tau}{i}{\labelset}}\\
% \mathsf{Exp} & e & ::= & x ~\vert~ \aelam{\tau}{x}{e} ~\vert~ \aeap{e}{e} ~\vert~ \aetlam{t}{e} ~\vert~ \aetap{e}{\tau} ~\vert~ \aefold{e} ~\vert~ \aetpl{\labelset}{\mapschema{e}{i}{\labelset}} ~\vert~  \aein{\ell}{e} \\
% & & \vert & \aematchwith{n}{e}{\seqschemaX{r}}\\
% \mathsf{Rule} & r & ::= & \aematchrule{p}{e}\\
% \mathsf{Pat} & p & ::= & x  ~\vert~ \aewildp ~\vert~ \aefoldp{p} ~\vert~ \aetplp{\labelset}{\mapschema{p}{i}{\labelset}} ~\vert~ \aeinjp{\ell}{p}
% \end{array}$

\begin{figure}
\[
\arraycolsep=0pt
\begin{array}{rlll}
 p    & {}\in Pat & {}\mathrel{::=}{} & x \mid \_ \\
 e    & {}\in Exp & {}\mathrel{::=}{} & \lambda p\mathord{:}\tau.e \mid e~e \mid e + e \mid n \mid \_ \\
 \tau & {}\in Typ & {}\mathrel{::=}{} & \tau \rightarrow \tau \mid Num \mid \_
\end{array}
\]
\caption{Formal syntax (as a grammar) for the lambda calculus that we are considering.}
\label{fig:formal-syntax}
\end{figure}

Turn that into a constructor set K + index set I + arity function (has type: K -> $\wp$(I)).

$\K = \{ \Root, \ExpVar, \ExpLam, \ExpApp, \ExpNum, \ExpPlus,$ 

$\qquad\ \ \PatVar, \TypNum, \TypArrow \}$

$\I = \{ \Root, \LamParam, \LamType, \LamBody, \AppFun, \AppArg,$

$\qquad\ \ \PlusLeft, \PlusRight, \ArrowArg, \ArrowResult \}$

\vspace{2ex}

$\arity : \K \rightarrow \wp(\I)$

\vspace{2ex}

\begin{tabular}{ll}
    $\K$ & $\wp(\I)$ \\
    \hline
    $\Root$ & $\{ \Root \}$ \\
    $\ExpLam$ & $\{ \LamParam, \LamType, \LamBody \}$ \\
    $\ExpApp$ & $\{ \AppFun, \AppArg \}$ \\
    $\ExpPlus$ & $\{ \PlusLeft, \PlusRight \}$ \\
\end{tabular}

\subsection{Convergent Graphs}

\subsubsection{Graphs}

Graph is a function from edges to edge states.

$\G : \E \rightarrow \{ \bot, +, - \}$

An edge is a uuid * source vertex * index * target vertex.  (We are assuming you can generate globally unique IDs.)

\def\e{\varepsilon}

An edge $\e \in \E = \U \times \V \times \I \times \V$ is ...

A vertex is a pair of a uuid and a constructor. (uuid + constructor is the identity)

$\V = \U \times \K$

An edge state is bottom + - . Define the total ordering (forms a lattice).

Define $\sqcup_{edge state}$ (i.e. join)

lattice ordering $\bot < + < -$ LUB e.g., join A B = C

You can map from syntax to graph by selecting
unique IDs (for both edges and vertexes).
    - holes are not explicit in the graph

\subsubsection{Graph Actions}
A graph action is a +E or -E.

Graph action semantics is a transition system
between graphs. (join with whatever it was before)

G --action--> G'

\subsection{Agda Mechanization}
\label{sub:agda-mechanization}

Discuss uniqueness of uuid

\begin{theorem}[Commutativity]

G  -- a1 a2 --> G'

------------------

G' -- a2 a1 --> G

\end{theorem}

\subsection{Type System}
\label{sub:type-system}

editor states:

conflicts (multiple children in the same spot)

multi-parent

cycles

non-empty holes

----------------

User must supply edge selection for multi-parent


\subsection{Edit Actions}
Mapping to graph actions

Sensibility -- mapping back from graphs
to well-typed states that fixes holes

\section{TODO}
TODO: leaves

TODO: our model supports treating these as a cons-list of characters

\section{Implementation}
\label{sec:implementation}
GRV -- how it is implemented, how it connects to the formalism, describe the graph, 

We implemented GRV as a core OCaml library in approximately 1,500 lines of code, and a basic Web interface in approximately 600 lines of OCaml code and 250 lines of HTML+CSS+Javascript.

Compared to the core language, our implementation lacks support for lists and case expressions.

Optimizations: least fixed point 

\section{Related Work}
\label{sec:related-work}

Hazel

CRDTs

Pidjul

Etherpad

Live Share

Git

Darcs

Unision?

\section{Discussion and Conclusion}
\label{sec:conclusion}

\subsection{Variable names, strings, and numbers}

NOTE: we could implement each digit as a separate characters

GUI for string conflicts: use popups

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

%% Bibliography
%\bibliography{bibfile}

\end{document}
