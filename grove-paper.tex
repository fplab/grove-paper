%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review,anonymous,nonacm]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

\bibliographystyle{ACM-Reference-Format}
%\citestyle{acmauthoryear}
\citestyle{acmnumeric}

%%%%%%%%

\renewcommand{\topfraction}{1} % Allow floats to take up the page
\renewcommand{\textfraction}{0}

%%%%%%%%
% \autoref from hyperref
\renewcommand{\AMSautorefname}          {Equation}
\renewcommand{\appendixautorefname}     {Appendix}
\renewcommand{\chapterautorefname}      {Chapter}
\renewcommand{\equationautorefname}     {Equation}
\renewcommand{\FancyVerbLineautorefname}{Line}
\renewcommand{\figureautorefname}       {Figure}
\renewcommand{\footnoteautorefname}     {Footnote}
\renewcommand{\Hfootnoteautorefname}    {Footnote}
\renewcommand{\itemautorefname}         {Item}
\renewcommand{\Itemautorefname}         {Item}
\renewcommand{\pageautorefname}         {Page}
\renewcommand{\paragraphautorefname}    {Section}
\renewcommand{\partautorefname}         {Part}
\renewcommand{\sectionautorefname}      {Section}
\renewcommand{\subparagraphautorefname} {Section}
\renewcommand{\subsectionautorefname}   {Section}
\renewcommand{\subsubsectionautorefname}{Section}
\renewcommand{\tableautorefname}        {Table}
\renewcommand{\theoremautorefname}      {Theorem}

%% Packages
\usepackage{booktabs}
\usepackage[rule=false]{subcaption}
\usepackage{graphicx}
\usepackage{semantic}
\let\colonapprox\undefined % Avoid redefinition error in `colonequals`
\let\colonsim\undefined % Avoid redefinition error in `colonequals`
\usepackage{colonequals}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{fontawesome}
\usepackage{array}

% math ligatures
\mathlig{::=}{\coloncolonequals}
\mathlig{|-}{\vdash}
\mathlig{:->}{\mapsto}
\mathlig{-->a}{\overset{a}{\longrightarrow}}
%\mathlig{||}{|}
%\mathlig{|}{:}
%\mathlig{:}{\!:\!}
\newcommand{\abs}[1]{\left|{#1}\right|}

\def\_{\texttt{\textunderscore}}


%%%%%%%%
% TikZ Stuff
%\usepackage{etex} % Fix "No room for new \dimen" error
\usepackage{shellesc} % Fix bug that breaks the tikz 'external' library
\usepackage{tikz}
\usetikzlibrary{babel} % Ensure compatibility the 'babel' package

\usetikzlibrary{external} % Needs to be separately enabled
%\tikzexternalize % Enable externalization
%\usepackage{lua-visual-debug}

\usetikzlibrary{arrows.meta} % Arrow Tips
\tikzset{>=Stealth}
%\tikzset{<=stealth}
%\tikzset{arrows={-Stealth[scale=50]}}
%\tikzset{edge from parent/.style={draw,->,line width=0.6pt}}
%\tikzset{wideline/.style={line width=0.7pt}}
%\tikzset{boldline/.style={color=black,line width=1.0pt}}

\usetikzlibrary{
  backgrounds,  % Provides "framed" and "gridded"
  graphs,       % Graph *notation*
  graphdrawing, % Graph *layout*
  quotes,       % Quote syntax (e.g., "foo")
}

\usegdlibrary{
  trees,
}

\tikzset{
  every picture/.style={framed, background rectangle/.style={draw=gray!50}},
}
\tikzset{edge style/.style={
  draw,
  font={\small\ttfamily},
  /tikz/every edge quotes/.style={
    %draw=gray!20,
    anchor=west,
    swap/.append code={
      \ifpgfarrowswap
        \pgfkeysalso{anchor=west}
      \else
        \pgfkeysalso{anchor=east}
      \fi}},
}}
\tikzset{graphs/graph style/.style={
  tree layout,
  level sep=1cm,
  nodes={draw, rounded corners=1mm},
  edges={edge style},
}}
\tikzset{graphs/root style/.style={
 %draw=none,
 as={\textbullet$_{0}$}
}}

%%%%%%%%
% Lang components

% sets
\def\A{\mathcal{A}}
\def\C{\mathcal{C}}
\def\E{\mathcal{E}}
\def\G{\mathcal{G}}
\def\I{\mathcal{I}}
\def\K{\mathcal{K}}
\def\P{\mathcal{P}}
\def\S{\mathcal{S}}
\def\U{\mathcal{U}}
\def\V{\mathcal{V}}
\def\e{\varepsilon}
\def\AA{\textbf{A}}
\def\EE{\textbf{E}}

% constructors
\def\ExpVar{\mathsf{Exp\_var}}
\def\ExpLam{\mathsf{Exp\_lam}}
\def\ExpApp{\mathsf{Exp\_app}}
\def\ExpNum{\mathsf{Exp\_num}}
\def\ExpPlus{\mathsf{Exp\_plus}}
\def\PatVar{\mathsf{Pat\_var}}
\def\TypNum{\mathsf{Typ\_num}}
\def\TypArrow{\mathsf{Typ\_arrow}}

% indexes
\def\Root{\mathsf{Root}}
\def\LamParam{\mathsf{Lam\_param}}
\def\LamType{\mathsf{Lam\_type}}
\def\LamBody{\mathsf{Lam\_body}}
\def\AppFun{\mathsf{App\_fun}}
\def\AppArg{\mathsf{App\_arg}}
\def\PlusLeft{\mathsf{Plus\_left}}
\def\PlusRight{\mathsf{Plus\_right}}
\def\ArrowArg{\mathsf{Arrow\_arg}}
\def\ArrowResult{\mathsf{Arrow\_result}}

% actions
\def\Create{\text{Create}}
\def\Destroy{\text{Destroy}}
\def\Down{\text{Down}}
\def\Enqueue{\text{Enqueue}}
\def\Left{\text{Left}}
\def\Move{\text{Move}}
\def\Num{\text{Num}}
\def\Restore{\text{Restore}}
\def\Right{\text{Right}}
\def\Select{\text{Select}}
\def\Send{\text{Send}}
\def\Up{\text{Up}}

% relations
\DeclareMathOperator{\arity}{\text{arity}}
\DeclareMathOperator{\childVertexes}{\text{childVertexes}}
\DeclareMathOperator{\cursorChildren}{\text{cursorChildren}}
\DeclareMathOperator{\vertexChildren}{\text{vertexChildren}}
\DeclareMathOperator{\deleted}{\text{deleted}}
\DeclareMathOperator{\dom}{\text{dom}}
\DeclareMathOperator{\edges}{\text{edges}}
\DeclareMathOperator{\known}{\text{known}}
\DeclareMathOperator{\liveEdges}{\text{liveEdges}}
\DeclareMathOperator{\liveVertexes}{\text{liveVertexes}}
\DeclareMathOperator{\multiparents}{\text{multiparents}}
\DeclareMathOperator{\orphans}{\text{orphans}}
\DeclareMathOperator{\parents}{\text{parents}}
\DeclareMathOperator{\parentVertexes}{\text{parentVertexes}}
\DeclareMathOperator{\reachable}{\text{reachable}}
\DeclareMathOperator{\seen}{\text{seen}}
\DeclareMathOperator{\unseen}{\text{unseen}}
\DeclareMathOperator{\vertexes}{\text{vertexes}}
\DeclareMathOperator{\vertex}{\text{vertex}}
\DeclareMathOperator{\publish}{\text{publish}}
\DeclareMathOperator{\leftIndex}{\text{leftIndex}}
\DeclareMathOperator{\rightIndex}{\text{rightIndex}}
\DeclareMathOperator{\downIndex}{\text{downIndex}}
\DeclareMathOperator{\defaultIndex}{\text{defaultIndex}}

% Define outline versions of + and -
\def\outlinepad{0.4pt}
\def\outlinestroke{0.4pt}
\newcommand{\Plus}{\mathord{
\begin{tikzpicture}[anchor=base, baseline]
%\node at (0,0) {+};
\path[draw, line width=\outlinestroke]
   ( 0.333em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --( 0.333em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad, -0.084em-\outlinestroke/2-\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad, -0.084em-\outlinestroke/2-\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.333em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.333em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.583em+\outlinestroke/2+\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.583em+\outlinestroke/2+\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --cycle
 ;
\end{tikzpicture}
}}
\newcommand{\Minus}{\mathord{
\begin{tikzpicture}[anchor=base, baseline]
%\node at (0,0) {$-$};
\path[draw, line width=\outlinestroke]
   ( 0.306em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --( 0.306em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.306em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.306em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --cycle
 ;
\end{tikzpicture}
}}

\newcommand{\hole}{\ensuremath{\square}} %\textcolor{violet}{\llparenthesis}}\textcolor{violet}{\rrparenthesis}}

% Support \includegraphics of .dot files
\DeclareGraphicsRule{.dot}{pdf}{.pdf}{`dot -Tpdf #1 -o \noexpand\OutputFile}

\newcommand{\Edge}[1]{Edge~#1}
\newcommand{\Vertex}[1]{Vertex~#1}

\begin{document}

%% Title information
\title[Grove]{Grove: A Convergent Collaborative Structure-Editor Calculus}
%\subtitle{Subtitle}

%% Author information
\author{Michael D. Adams}
\orcid{0000-0003-3160-6972}

\author{Eric Griffis}
\orcid{nnnn-nnnn-nnnn-nnnn}

\author{Cyrus Omar}
\orcid{0000-0003-4502-7971}
\affiliation{
  %\position{Assistant Research Scientist}
  \department[0]{Computer Science and Engineering}
  \department[1]{Electrical Engineering and Computer Science}
  \department[2]{College of Engineering}
  \institution{University of Michigan}
  \streetaddress{Bob and Betty Beyster Building, 2260 Hayward Street}
  \city{Ann Arbor}
  \state{MI}
  \postcode{48109-2121}
  \country{USA}
}


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10011007.10011006.10011008</concept_id>
%<concept_desc>Software and its engineering~General programming languages</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%<concept>
%<concept_id>10003456.10003457.10003521.10003525</concept_id>
%<concept_desc>Social and professional topics~History of programming languages</concept_desc>
%<concept_significance>300</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}
%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
% \keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{sec:Introduction}

TODO: fix the following warning which are reported by LaTeX but not Overleaf: Class acmart Warning: A possible image without description on input line 321.


Motivation:
- collaborative editing (both synchronous ala Google Docs and asynchronous version control) 
  is good and important as computing grows
- semantic structure editing is good because it solves the gap problem (semantic editor services 
  are always available) -- cite Hazelnut papers (talk about holes)
- previous approaches to collaborative editing have limitations
  - diff/merge based approaches (trying to solve the inverse problem based on final states -- 
    you lose the actual actions that were performed, and have to reconstruct them or an approx.
    of them i.e. add line/delete line actions -- would need to adapt this to structure editing,
    some papers have started to look at that, but fundamentally we don't want to throw away the
    knowledge we have about the edits!)
  - operational transforms (complexity, you have to patch previous actions based on new actions)
  - CRDT-based collaborative editing (that's all been on text, not PL semantics) -- this is good
    because it is relatively simple: you just send all the edits to all the replicas and they are 
    convergent by design
- we want to have the same convergence for a CRDT-based collaborative structure editor that maintains
  the sensibility invariant of Hazelnut, i.e. every editor state has meaning. mention that maintaining sensibility 
  allows scaling of semantic editor services in the presence of large number of collaborators (in contrast,
  using VS Code or other collaborative text editors with large numbers of collaborators means that almost always
  the semantic editor services will be disabled because the program is going to be broken in multiple places
  transiently)

  this is tricky because:
  - some edits might be conflicting -- solve this with "conflict holes"
  - adding cut/paste or delete/restore allows for degenerate programs (cycles, multiple parents, etc.)
- since we are commutative, we solve both synchronus and async collaborative editing
  - and this resolves issues around merges and conflicts
- contribution of this paper is to solve these problems from type-theoretic first principles:
  - ...
- Hazel

\subsection{Contributions and Paper Organization}
\label{sec:Contributions and Paper Organization}

\section{Grove By Example}
\label{sec:Grove By Example}

This section introduces collaborative structure editing in Grove.
We begin in \autoref{sub:Program Representation} by covering how we represent expressions with holes as graphs,
\autoref{sub:Single User Edits} explores edits by a single user, Alice,
and \autoref{sub:Multi-user Edits} explores edits by multiple users, Alice and Bob,
each of whom is editing their own instance of a program.

do not model cursors
but model later in \autoref{sub:Cursors} 
they are not involved in the communication of graph edits
though their representation is slightly subtly

TODO: group user-level edits (with user visible)

TODO: gray-scale unchanged parts of diagrams; and dashes for removed parts? describe semantic vs presentational in diagrams



\subsection{Program Representation}
\label{sub:Program Representation}

% \begin{figure}
% \centering
% TODO: UI
% \includegraphics[scale=0.75]{graphviz/simple-tree-with-hole/1.dot}
% \caption{A simple tree with a hole}
% \label{fig:A simple tree with a hole}
% \end{figure}

\begin{figure}
\hfill
%%%%%%%%
\begin{subfigure}{0.49\linewidth}
\centering
TODO
\caption{User interface}
\label{fig:A simple tree with a hole-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.49\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{*}_{2}$" [> "Root$_{1}$"] -> {
   "$\texttt{x}_{4}$" [> "L$_{3}$"'],
   {}
  }
 }
};
\end{tikzpicture}
\caption{Graph representation}
\label{fig:A simple tree with a hole-b}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{A simple tree with a hole}
\label{fig:A simple tree with a hole}
\end{figure}

TODO: use mathit instead of var(x)

%We represent expression contain holes as part of the editor state 
The \textit{program state} for each editor instance in Grove consists of a graph that represents the program being edited.
This can be presented to the user as an expression containing holes.
For example, \autoref{fig:A simple tree with a hole-b} shows one such graph,
and \autoref{fig:A simple tree with a hole-a} shows its corresponding expression,~\texttt{x * \hole}, which
has a hole on the right side of the times operator.

%We present this from two perspectives.
%One is the underlying graph model, the other is the interface a user might see, which omits these details unless needed.

%which involves explicit graph edges, positions, and add and delete operations.

Program state is a directed graph with a distinguished root vertex.
%For example, \autoref{fig:A simple tree with a hole-b} shows the graph corresponding to the term in \autoref{fig:A simple tree with a hole-a}.
Each vertex represents a term and is labeled with a globally unique identifier and a term constructor.
In \autoref{fig:A simple tree with a hole-b}, \Vertex{2} and \Vertex{4} have the constructors~\texttt{*} and \texttt{var(x)}, respectively.
The root vertex has the distinguished identifier~0 and the constructor~\textbullet.

Each term constructor has an associated set of child positions.
The~\texttt{*} constructor has positions for~\texttt{left} and~\texttt{right} children
and the~\texttt{var} constructors have no child positions but takes an argument naming the particular
variable referenced~(e.g.,~\texttt{x} in \texttt{var(x)}).\footnote{Note that,
for the purposes of this paper, we represent identifiers and number literals
indivisibly.  See Section~TODO:REF, for how we would allow editing individual characters.}
The root vertex constructor,~\textbullet, has the single child position \texttt{root}.

Each edge is labeled with a globally unique identifier (e.g.,~1 and~3 in \autoref{fig:A simple tree with a hole-b}) and
a child position (e.g., \texttt{left} and \texttt{root} in \autoref{fig:A simple tree with a hole-b}).
An edge indicates that the destination vertex is a child of the origin vertex at the given position.
%Visually, we indicate the position of an edge by the location of its origin.
For the sake of presentation clarity, we reserve odd identifiers for vertexes and even identifiers for edges.

Finally, holes are represented by the absence of a child.
For example, in \autoref{fig:A simple tree with a hole-b} the absence of a \texttt{right} edge coming from \Vertex{2}
corresponds to the hole on the right of the~\texttt{*} in~\texttt{x * \hole}.

% In this paper we represent variables and numeric constants
% as leaves and represent their names or values as
% arguments to those constructors (e.g.,~\texttt{2} in~\texttt{num(2)}).
% (In TODO:REF, we discuss how to allow edits within these.)

\marginpar{START REV HERE}

\subsection{Single User Edits}
\label{sub:Single User Edits}

In the remainder of this section,
we will consider user edits, starting
in this subsection with single-user
edits and continuing in \autoref{sub:Multi-user Edits}
with multi-user edits.

Each user edit that we will consider corresponds to one or more graph edits.
Graph edits can only add fresh edges and vertices or remove existing edges.

User edits act relative to a cursor. 
We do not model cursor sharing and the cursor does not appear in the underlying graph.
We discuss cursor representations and cursor sharing in more detail in \autoref{sub:Cursors}.

\subsubsection{Construction}
\label{sub:Construction}

\begin{figure}
\hfill
%%%%%%%%
\begin{subfigure}{0.49\columnwidth}
\centering
TODO
\caption{User interface}
\label{fig:Construction-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.49\columnwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{*}_{2}$" [> "Root$_{1}$"] -> {
   "$\texttt{x}_{4}$" [> "L$_{3}$"'],
   "$\texttt{y}_{6}$" [> "R$_{5}$"]
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:A simple tree with a hole-b} after adding \Vertex{6} and \Edge{5}}
\label{fig:Construction-b}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Construction}
\label{fig:Construction}
\end{figure}

TODO: "user edits" and "graph edits"

To start our examples, Alice starts with the code in \autoref{fig:A simple tree with a hole}.
She moves her cursor to the hole in~\texttt{x * \hole} and enters the variable~\texttt{y}.
We model edits as sequences of additions and deletions of edges to the graph.
Alice's edit corresponds to creating a vertex for the variable reference~\texttt{y} and adding an edge
to that vertex from \Vertex{2}.
\autoref{fig:Construction-b} shows the result, where the new vertex has identifier~6.
This graph represents the expression \texttt{x * y}.

TODO: (though as we show in \autoref{sec:Formalism} creating a vertex is implicit in edge creation)

TODO: z -> foo (or multi-editor)

% TODO: change num(2) in Fig1 to num(1) so Fig1 matches Fig2 (move parts of Fig 2 into Fig 1?)

% TODO: remove cursor from Fig 1 and Fig 2

\subsubsection{Changes}
\label{sub:Changes}

\begin{figure}
\hfill
%%%%%%%%
\begin{subfigure}{0.49\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{*}_{2}$" [> "Root$_{1}$"] -> {
   "$\texttt{x}_{4}$" [> "L$_{3}$"'],
   {}
  }
 }
};
\path (1cm,-2cm) graph[graph style] {
 y [as={$\texttt{y}_{6}$}]
};
\end{tikzpicture}
\caption{\autoref{fig:Construction-b} after deleting \Edge{5}}
\label{fig:Change-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.49\linewidth}
\centering
\begin{tikzpicture}[framed]
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{*}_{2}$" [> "Root$_{1}$"] -> {
   "$\texttt{x}_{4}$" [> "L$_{3}$"'],
   "$\texttt{z}_{8}$" [> "R$_{7}$"]
  }
 }
};
\path (1cm,-2cm) graph[graph style] {
 "$\texttt{y}_{6}$"
};
\end{tikzpicture}
\caption{\autoref{fig:Change-a} after adding \Vertex{8} and \Edge{7}}
\label{fig:Change-b}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Change}
\label{fig:Change}
\end{figure}

Arrows between figures

% \begin{figure}
% \centering
% \begin{tikzpicture}
% \path (0,0)    node {\includegraphics[scale=0.75]{graphviz/delete-and-add/1.dot}};
% \path (0,-4cm) node {\includegraphics[scale=0.75]{graphviz/delete-and-add/2.dot}};
% \path (0,-8cm) node {\includegraphics[scale=0.75]{graphviz/delete-and-add/3.dot}};
% \end{tikzpicture}
% \caption{Delete and Add}
% \label{fig:Delete and Add}
% \end{figure}

Next Alice wants to replace~\texttt{y} with~\texttt{z} so that the code becomes~\texttt{x * z}.
This is modeled by first deleting \Edge{5}.
This results in \autoref{fig:Change-a}, which represents the expression~\texttt{x * \hole{}}.
After that deletion, we add a new vertex to represent~\texttt{z} and an
edge from \Vertex{2} to that vertex.
This results in the bottom graph in \autoref{fig:Change-b},
which represents the expression~\texttt{x * z}.

Note that this edge has a new identifier distinct from the one before.
In our model, once an edge with a particular identifier is deleted, it cannot be recreated.
Instead a new edge with a new identifier is created.

Note that \Vertex{3} continues to exist, and if it had any children, those children could remain connected to it.
In our system, once a vertex is created it is never deleted.
This allows further manipulations of those vertexes as shown later in this section.

Note that we will omit orphans from diagrams if they are not relevant
(e.g., they are deleted and are not added back later)

Note that we do not explicitly delete or add vertexes.
Our only actions are deleting or adding \textit{edges}.
Vertexes are implicitly created whenever an edge
is created that points to it.
Deleting vertexes is not necessary, as we can simply
remove the edge pointing to it.

TODO: explain that multiple delete or add are idempotent

TODO: explain that delete overrides add

TODO: once deleted an edge can never be recreated (though, a new edge (with a new id) can be created in the same spot as the original)

TODO: Explain orphans

\subsubsection{Wrapping Code}
\label{sub:Wrapping Code}

\begin{figure}
% TODO: naive add that creates a conflict
% \begin{tikzpicture}
% \path (0,0)       node {\includegraphics[scale=0.4]{graphviz/wrapping/1.dot}};
% \path (0cm,-4cm)  node {\includegraphics[scale=0.4]{graphviz/wrapping/2.dot}};
% \path (0cm,-8cm)  node {\includegraphics[scale=0.4]{graphviz/wrapping/3.dot}};
% \path (0cm,-12cm) node {\includegraphics[scale=0.4]{graphviz/wrapping/4.dot}};
% \path (0cm,-16cm) node {\includegraphics[scale=0.4]{graphviz/wrapping/5.dot}};
% \end{tikzpicture}
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style]
};
\path (-0.5,-3cm) graph[graph style] {
 "$\texttt{*}_{2}$" -> {
  "$\texttt{x}_{4}$" [> "L$_{3}$"'],
  "$\texttt{z}_{8}$" [> "R$_{7}$"]
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Change-b} after deleting \Edge{1}}
\label{fig:Wrapping-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"]
 }
};
\path (-0.5cm,-3cm) graph[graph style] {
 "$\texttt{*}_{2}$" -> {
  "$\texttt{x}_{4}$" [> "L$_{5}$"'],
  "$\texttt{z}_{8}$" [> "R$_{7}$"]
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Wrapping-a} after adding \Vertex{8} and \Edge{7}}
\label{fig:Wrapping-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{11}$"'] -> {
    "$\texttt{x}_{4}$" [> "L$_{3}$"'],
    "$\texttt{z}_{8}$" [> "R$_{7}$"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Wrapping-b} after adding \Edge{9}}
\label{fig:Wrapping-c}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Wrapping}
\label{fig:Wrapping}
\end{figure}

Next, Alice types~\texttt{+} when the cursor is on \Vertex{2}.
If this were a hole, this would simply put a vertex with the~\texttt{+} constructor
as a child of \Vertex{0}.
However, this position is already occupied by some code.

A naive editor could add the~\texttt{+} by creating a new
edge from the body index of the lambda to a freshly created \texttt{plus} vertex.
This would result in a conflict between the \texttt{+} and the existing \texttt{var}
as shown in Figure~REF:TODO.

How to handle multiple children in the same position is explored in Sec~REF:TODO,
but for this sort of edit, a better user experience
would be interpret the request for a plus to mean to
take whatever (if anything) is in the cursor
and place it as a child of the plus.
This \emph{wraps} the existing \texttt{var} in the \texttt{plus}
and results in the code~\texttt{(x * z) + \hole}.
(This is similar to the behavior in other structure editors such as in CITE:TODO.)
Translating this into edge deletes and adds results in the sequence of graphs in \autoref{fig:Wrapping}.

TODO: "Note that the logic of to insert or wrap is a layer above graph actions."

TODO: Traditional diff: no relation (and indent might change)

\subsubsection{Move}
\label{sub:Move}

\begin{figure}
% \centering
% \begin{tikzpicture}
% \path (0,0)    node {\includegraphics[scale=0.75]{graphviz/move/1.dot}};
% \path (0,-5cm) node {\includegraphics[scale=0.75]{graphviz/move/2.dot}};
% \path (0,-9cm) node {\includegraphics[scale=0.75]{graphviz/move/3.dot}};
% \end{tikzpicture}
\hfill
%%%%%%%%
\begin{subfigure}{0.49\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"]
 }
};
\path (0cm,-3cm) graph [graph style] {
 "$\texttt{*}_{2}$" -> {
  "$\texttt{x}_{4}$" [> "L$_{3}$"'],
  "$\texttt{z}_{8}$" [> "R$_{7}$"]
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Wrapping-c} after deleting \Edge{9}}
\label{fig:Move-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.45\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   {},
   "$\texttt{*}_{2}$" [> "R$_{13}$"] -> {
    "$\texttt{x}_{4}$" [> "L$_{3}$"'],
    "$\texttt{z}_{6}$" [> "R$_{7}$"]
   }
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Move-a} after adding \Edge{11}}
\label{fig:Move-b}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Moving \Vertex{2} from the left child to the right child of \Vertex{8}}
\label{fig:Move}
\end{figure}

An interesting consequence of our design is that a move operation
does not have to delete code from one position and create a copy
in another position.
Instead, by deleting just the edge to the code to be moved and then
adding a new edge to that code somewhere else, the actual code is
moved, not just a copy.

For example, consider \autoref{fig:Move}, which represents
the movement of~\texttt{1 * 2} from the left child of \texttt{plus}
to its right child.
\autoref{fig:Editing Nested Parts of the Code-c} is the code before the move.
First, \Edge{7} is deleted, which results in \autoref{fig:Move-a}
where the rooted code is now~\texttt{\hole{} + \hole{}},
and \Vertex{2} is orphaned.
Next \Edge{11} is added, which results in the bottom graph
where the rooted code is now~\texttt{\hole{} + 1 * 2},
and \Vertex{2} is no longer orphaned.

This move semantics gives us a richer structure than
when treating code as a list of lines.  We exploit
this in Section~REF:TODO in order merge edits that involve moving code.

Of course, if the user wants a genuine copy
and not just a move, that can be achieved
by creating new vertexes with fresh identifiers.
(TODO: figure for this?)

This is similar to the paste with formatting versus
paste without formatting.

If only one restore, then it does what you expect (basically a cut and paste)

If multiple replicas restore to different places, then you get some complexity:

\subsection{Multi-user Edits}
\label{sub:Multi-user Edits}

TODO: mention that id numbers are global (or maybe use A1 and B1 for different users?)

We assume multiple instances

TODO: Finally, note that through we present several complex scenarios, this is merely for presentation.
In practice, these complex scenarios occur less frequently than portrayed here.

Common scenarios first and then consider more unusual scenarios
that cause cycles or multiple parents

TODO: \autoref{sub:Editing Different Parts of the Code}

\subsubsection{Editing Different Parts of the Code}
\label{sub:Editing Different Parts of the Code}

\begin{figure}
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   {},
   "$\texttt{*}_{2}$" [> "R$_{13}$"] -> {
    "$\texttt{u}_{16}$" [> "L$_{15}$"'],
    "$\texttt{z}_{6}$" [> "R$_{7}$"]
   }
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Move-b} after Alice replaces \Vertex{4} with \Vertex{12}}
\label{fig:Editing Different Parts of the Code-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   {},
   "$\texttt{*}_{2}$" [> "R$_{13}$"] -> {
    "$\texttt{x}_{4}$" [> "L$_{3}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   }
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Move-b} after Bob replaces \Vertex{6} with \Vertex{14}}
\label{fig:Editing Different Parts of the Code-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   {},
   "$\texttt{*}_{2}$" [> "R$_{13}$"] -> {
    "$\texttt{u}_{16}$" [> "L$_{15}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   }
  }
 }
};
\end{tikzpicture}
\caption{The result of merging \autoref{fig:Editing Different Parts of the Code-a} with \autoref{fig:Editing Different Parts of the Code-b}}
\label{fig:Editing Different Parts of the Code-c}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Editing Different Parts of the Code}
\label{fig:Editing Different Parts of the Code}
\end{figure}

% \begin{figure}
% \centering
% TODO: add screenshot of code text to each node
% TODO: remove orphans from diagram
% \begin{tikzpicture}
% \path (0,0)       node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/1.dot}};
% \path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/2A.dot}};
% \path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/2B.dot}};
% \path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/editing-different-parts-of-the-code/3.dot}};
% \end{tikzpicture}
% \caption{Editing Different Parts of the Code}
% \label{fig:Editing Different Parts of the Code}
% \end{figure}

TODO: have star or dot dot arrows for skipping steps

Arrow coming from 5b to 6a and 6b

Diamond diagram referencing diagrams

To start, Alice and Bob are synchronized with each other and
both have the graph in \autoref{fig:Move-b}, which
represents the code~\texttt{\hole{} + (x + z)}.

Alice changes the~\texttt{x} to a~\texttt{u},
and Bob changes the~\texttt{z} to a~\texttt{v}.
Before transmitting their edits to each other,
Alice thus has the graph in \autoref{fig:Editing Different Parts of the Code-a}
and Bob has the graph in \autoref{fig:Editing Different Parts of the Code-b}.
For Alice, this involves deleting \Edge{3} and creating \Edge{13}.
For Bob, this involves deleting \Edge{5} and creating \Edge{15}.

Alice and Bob then transmit their graph actions (i.e., edge additions and deletions) to each other
and applies the other's graph actions to their own copy of the graph.
By design, graph actions commute, so this results in both Alice and Bob having the graph in
\autoref{fig:Editing Different Parts of the Code-c}.

Note that aside from transmitting the edge deletions and additions,
no coordination between Alice and Bob is needed to coordinate the merge.
For example, suppose that Alice and Bob did not transmit their edits to each other
but to a third user, Chris, that has the original graph at the top of \autoref{fig:Move-b}.
Chris can apply the edits from Alice and Bob in any order and will always get
the graph in \autoref{fig:Editing Different Parts of the Code-c}.

Stated more formally, our edit model obeys the commutativity shown in \autoref{fig:Commutativity}.
For any two sequences of edits $\vec{\alpha}$ and $\vec{\alpha}^\prime$,
applying them in either order produces the same results.

\begin{figure}
\centering
TODO: commutativity diagram of screenshots with two cursors
\caption{TODO:Commutativity}
\label{fig:Commutativity}
\end{figure}

\subsubsection{Editing Nested Parts of the Code}
\label{sub:Editing Nested Parts of the Code}

\begin{figure}
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   {},
   "$\texttt{*}_{2}$" [> "R$_{13}$"] -> {
    "$\texttt{w}_{20}$" [> "L$_{19}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   }
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Editing Nested Parts of the Code-c} after Alice replaces \Vertex{14} with \Vertex{16}}
\label{fig:Editing Nested Parts of the Code-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    "$\texttt{u}_{16}$" [> "L$_{15}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Editing Nested Parts of the Code-c} after Bob move \Vertex{2} to the left child of \Vertex{8}}
\label{fig:Editing Nested Parts of the Code-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    "$\texttt{w}_{20}$" [> "L$_{19}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{The result of merging \autoref{fig:Editing Nested Parts of the Code-a} with \autoref{fig:Editing Nested Parts of the Code-b}}
\label{fig:Editing Nested Parts of the Code-c}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Editing Nested Parts of the Code}
\label{fig:Editing Nested Parts of the Code}
\end{figure}

% \begin{figure}
% \centering
% TODO: add screenshot of code text to each node
% TODO: remove orphans from diagram
% TODO: annotate edges with delete and restore
% \begin{tikzpicture}
% \path (0,0)       node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/1.dot}};
% \path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/2A.dot}};
% \path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/2B.dot}};
% \path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/editing-nested-parts-of-the-code/3.dot}};
% \end{tikzpicture}
% \caption{Editing Nested Parts of the Code}
% \label{fig:Editing Nested Parts of the Code}
% \end{figure}

After the edits in the previous subsection synchronize,
Alice changes the~\texttt{v} to a~\texttt{w}, which results in the graph in \autoref{fig:Editing Nested Parts of the Code-a}.
On the other hand, Bob moves the~\texttt{u * v} from the right of the plus to the left of the plus
by deleting \Edge{11} and adding \Edge{19}, which results in the graph in \autoref{fig:Editing Nested Parts of the Code-b}.
Since vertex and edge identifiers are preserved by these,
both Alice's and Bob's edits can be applied to the other's graph,
which results in both Alice and Bob having the graph in \autoref{fig:Editing Nested Parts of the Code-c}.

As with \autoref{sub:Editing Different Parts of the Code}, this merge does not require coordination
between Alice and Bob.  They could independently send their edits
to a third party, Charley, who could replay their edits in any order
and will always get the graph in \autoref{fig:Editing Nested Parts of the Code-c}.

A consequence of this design is that we allow users to edit
parts of the code that have been deleted.  For example,
Alice might receive Bob's deletion of \Edge{11} before making her
edits and before receiving Bob's addition of \Edge{19}.
Her edits would then be within the code deleted by Bob.

TODO:figure

Contrast with a traditional diff

TODO: put this somewhere.
(Similar to how git merged across moves.
A notable difference though is that \texttt{git} detects
file moves by structural similarity rather than
our nominal equality.
(We exploit this in Subsection~REF:TODO).

\subsubsection{Multi-child conflicts}
\label{sub:Multi-child conflicts}

\begin{figure*}
\hfill
%%%%%%%%
\begin{subfigure}{0.24\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    "$\texttt{w}_{20}$" [> "L$_{19}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   },
   {
    "$\texttt{x}_{22}$" [> "R$_{21}$"]
   }
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Editing Nested Parts of the Code-c} after Alice ... TODO}
\label{fig:Multi-child-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    "$\texttt{w}_{20}$" [> "L$_{19}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   },
   "$\texttt{y}_{24}$" [> "R$_{23}$"]
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Editing Nested Parts of the Code-c} after Bob ... TODO}
\label{fig:Multi-child-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    "$\texttt{w}_{20}$" [> "L$_{19}$"'],
    "$\texttt{v}_{18}$" [> "R$_{17}$"]
   },
   {
    "$\texttt{x}_{22}$" [> "R$_{21}$"],
    "$\texttt{y}_{24}$" [> "R$_{23}$"]
   }
  }
 }
};
\end{tikzpicture}
\caption{The result of merging \autoref{fig:Multi-child-a} with \autoref{fig:Multi-child-b}}
\label{fig:Multi-child-c}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\linewidth}
\centering
TODO: show UI
\caption{User interface showing the multi-child conflict in \autoref{fig:Multi-child-d}}
\label{fig:Multi-child-d}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Multi-child conflicts}
\label{fig:Multi-child}
\end{figure*}

% \begin{figure}
% \centering
% \begin{tikzpicture}
% \path (0,0)       node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/1.dot}};
% \path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/2A.dot}};
% \path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/2B.dot}};
% \path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/direct-conflicts/3.dot}};
% \end{tikzpicture}
% \caption{Direct Conflicts}
% \label{fig:Direct Conflicts}
% \end{figure}

Finally, we address our first kind of genuine conflict between edits.
Alice inserts the variable~\texttt{x} to the right side of the~\texttt{+}
while Bob add the variable~\texttt{y} also to the right side of the~\texttt{+}
These results in the graphs in \autoref{fig:Multi-child-a} and \autoref{fig:Multi-child-b}, respectively.
In particular pay attention to the edges going out of the \texttt{right} index of \Vertex{8}.
In \autoref{fig:Multi-child-a} it is \Edge{21}, which points to the variable~\texttt{x},
and in \autoref{fig:Multi-child-b} it is \Edge{23}, which points to the variable~\texttt{y}.

We merge these by including \emph{both} edges as edges going out of the \texttt{right} index
of \Vertex{8}.
This results in \autoref{fig:Multi-child-c}.
The conflict between Alice's and Bob's changes is
represented by the fact that there are multiple edges going out of one index (i.e. the \texttt{right}
index of \Vertex{8}).
In the graph representation, we flag this conflict by highlighting its edges
in red (TODO).
In the textual representation, we flag this conflict with the notation~\texttt{\{ x | y \}}.
This is a conflict that must eventually be resolved by the user by deleting
one of the edges and editing the other to be the merged value.
For example, one could delete \Edge{23} and then edit the~\texttt{x}
to be~\texttt{x * y}.
Note that users can continue to edit the code while in this conflicted state.
It just must be resolved before the the code is run.\footnote{It
may be possible to develop evaluation models that allow these sorts of conflicts,
but that is beyond the scope of this paper.}

Compare this to what happens when there are conflicts in a traditional,
line/diff-based version control system (e.g., \texttt{git}, \texttt{mercurial}, \texttt{svn}, etc.).
Those systems annotate files with difference markers (e.g., sequences of~\texttt{<},~\texttt{>}, or~\texttt{=})
when a merge conflict happens.
These show alternate versions versions of the code, and it is up to the user
to replace those alternates with the desired merged result.

Our tree-based model is similar in that it presents alternate versions
of the code, and it is up to the user to replace those alternates with the desired merged result.
Our model is different, in that merge conflicts in the line-based model
prevent some semantic editor services from running
that could continue to run in the tree-based model because
code inside and outside the conflict is still valid code.
It is just the point where they meet the poses a potential problem for editor services.
Another place our model is different
is that changes are explicit rather than being inferred.
Finally, in our model, since all changes are in terms of
the structure of the code rather than lines,
all changes respect that structure.
This is unlike the line-based model where there is no guarantee
that a merge conflict follows the structure of the code.
Finally, our model differs from the traditional model
in that we have explict add and remove actions
where the traditional model infers these from a differencing algorithm.

Note that as a convenience to the user, certain simple
conflicts might be automatically resolved,
but we consider this a higher-level, user-interface consideration.

TODO: need example of fully-automatic resolution and semi-automatic resolution

Multiple adds cause conflicts
(Not usually presented in the UI)

\subsubsection{Multi-parent conflicts}
\label{sub:Multi-parent conflicts}

\begin{figure*}
\hfill
%%%%%%%%
\begin{subfigure}{0.19\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    "$\texttt{w}_{20}$" [> "L$_{19}$"'],
    {}
   },
   {}
  }
 }
};
\end{tikzpicture}
TODO: UI (at least moc up)
\caption{Initial code}
\label{fig:Multi-parent-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.19\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    {},
    "$\texttt{w}_{20}$" [> "R$_{25}$"']
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Multi-parent-a} after Alice ... TODO}
\label{fig:Multi-parent-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.19\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'],
   "$\texttt{w}_{20}$" [> "R$_{27}$"]
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Multi-child-a} after Bob ... TODO}
\label{fig:Multi-parent-c}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.19\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  a/{$\texttt{+}_{10}$} [> "Root$_{9}$"] -> {
   "$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    {},
    b/"$\texttt{w}_{20}$" [> "R$_{25}$"']
   },
   {}
  }
 },
};
\path [edge style,->] (a) to ["R$_{27}$",out=-60,in=60] (b);
\end{tikzpicture}
\caption{The result of merging \autoref{fig:Multi-parent-b} with \autoref{fig:Multi-parent-c}}
\label{fig:Multi-parent-d}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.19\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  v8/"$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   v2/"$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    {},
    "$\texttt{w}_{20}$" [> "R$_{25}$"']
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{Initial code TODO: move to previous figure}
\label{fig:Multi-parent-e}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Multi-parent conflicts}
\label{fig:Multi-parent}
\end{figure*}

In addition to conflicts due multiple edges coming \emph{out of} an index of a particular vertex,
conflicts can manifest as multiple edges going \emph{into} a particular vertex.
We call these \emph{multi-parent conflicts}.

An example of this is shown in \autoref{fig:Multi-parent}.
\autoref{fig:Multi-parent-a} shows the graph after Alice and Bob have made some more edits,
and Alice and Bob's editors are synchronized with each other.
This graph represents the expression~\texttt{(x + \hole{}) + \hole{})}.
Alice moves the variable~\texttt{x} to the left-most hole,
while Bob moves it to the right-most hole.
This results in the graphs in \autoref{fig:Multi-parent-b} and \autoref{fig:Multi-parent-c},
which represent respectively the expression~\texttt{(\hole{} + \hole{}) + x} for Alice
and the expression~\texttt{(\hole{} + x) + \hole{}} for Bob.
In both cases, these edits are achieved with one edge delete and one edge add.
Alice deletes \Edge{25} and adds \Edge{27}, while Bob deletes \Edge{25} and adds edge \Edge{29}.
As explained in Subsection~TODO:REF, deletes are idempotent so Alice and Bob both deleting \Edge{25} is not a problem.
However, both \Edge{27} (added by Alice) and edge \Edge{29} (added by Bob) point to the same vertex.
This generates the bottom graph, in which \Vertex{26} as two parents pointing to it.
We call this situation a multi-parent conflict.

% \subsubsection{Conflicting wrap operations}

% \begin{figure}
% \centering
% \begin{tikzpicture}
% % TODO: texttt
% % TODO: position the different graphs
% \path (0,0)       node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/1.dot}};
% \path (-3cm,-3cm) node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/2A.dot}};
% \path (3cm,-3cm)  node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/2B.dot}};
% \path (0cm,-6cm)  node {\includegraphics[scale=0.5]{graphviz/conflicting-wraps/3.dot}};
% % \path (0cm,0cm) graph[tree layout] {
% %   lam[as={$\lambda_{\texttt{x}}$}] -> {
% %     x
% %   }
% % };
% % \path (-3cm,-2cm) graph[tree layout] {
% %   lam[as={$\lambda_{\texttt{x}}$}] -> {
% %     + -> {
% %       1,
% %       x
% %     }
% %   }
% % };
% % \path (3cm,-2cm) graph[tree layout] {
% %   lam[as={$\lambda_{\texttt{x}}$}] -> {
% %     * -> {
% %       x,
% %       2
% %     }
% %   }
% % };
% % \path (0cm,-4cm) graph[tree layout] {
% %   lam[as={$\lambda_{\texttt{x}}$}] -> {
% %     + -> {
% %       1,
% %       x
% %     },
% %     * -> {
% %       x,
% %       2
% %     }
% %   }
% % };
% % \path (2cm,-8cm) graph[tree layout] {
% %   lam[as={$\lambda_{\texttt{x}}$}] -> {
% %     + -> {
% %       1,
% %       * -> {
% %         x,
% %         2
% %       }
% %     }
% %   }
% % };
% % \path (-2cm,-8cm) graph[tree layout] {
% %   lam[as={$\lambda_{\texttt{x}}$}] -> {
% %     * -> {
% %       + -> {
% %         1,
% %         x
% %       },
% %       2
% %     }
% %   }
% % };
% \end{tikzpicture}
% \caption{Conflicting wraps}
% \label{fig:Conflicting wraps}
% \end{figure}

% If two different 
% As seen in REF:SEC:TODO, conflicting wraps gener

% Multi-parent


% TODO: SHOW intermediate Steps (maybe no graph)
%   Show user's perspective
%   Accept one side = delete others (select this)
%   Delete x in *
%   Move + to x


% \begin{figure}
% \centering
% \begin{tikzpicture}
% \path (0cm,0cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     + -> {
%       1,
%       x
%     },
%     * -> {
%       x,
%       2
%     }
%   }
% };
% \path (2cm,-4cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     + -> {
%       1,
%       * -> {
%         x,
%         2
%       }
%     }
%   }
% };
% \path (-2cm,-4cm) graph[tree layout] {
%   lam[as={$\lambda_{\texttt{x}}$}] -> {
%     * -> {
%       + -> {
%         1,
%         x
%       },
%       2
%     }
%   }
% };
% \end{tikzpicture}
% \caption{Wrap Resolution}
% \label{fig:Wrap Resolution}
% \end{figure}

% NEEDS UI MOCKUP

% Say: "might not be a popup"

\subsubsection{Single-User Cycles}
\label{sub:Cycles}

\begin{figure}
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  v8/"$\texttt{+}_{10}$" [> "Root$_{9}$"'] -> {
   v2/"$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    {},
    {}
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Single-User Cycles-a} after Alice copy and pastes \Vertex{TODO} by copy as the right child of \Vertex{TODO}}
\label{fig:Single-User Cycles-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  v8/"$\texttt{+}_{10}$" [> "Root$_{9}$"'] -> {
   v2/"$\texttt{*}_{2}$" [> "L$_{21}$"'] -> {
    {},
    "$\texttt{+}_{30}$" [> "R$_{29}$"] -> {
     "$\texttt{*}_{32}$" [> "L$_{31}$"'] -> {
      {},
      {}
     },
     {}
    }
   },
  }
 }
};
\end{tikzpicture}
\caption{\autoref{fig:Single-User Cycles-a} after Alice copy and pastes \Vertex{TODO} by copy as the right child of \Vertex{TODO}}
\label{fig:Single-User Cycles-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.32\linewidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  v8/"$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   v2/"$\texttt{*}_{2}$" [> "L$_{21}$"'],
   {}
  }
 }
};
\path[edge style,->] (v2) to ["R$_{29}$",out=-60,in=-60] (v8);
\end{tikzpicture}
\caption{\autoref{fig:Single-User Cycles-a} after Alice copy and pastes \Vertex{TODO} by reference as the right child of \Vertex{TODO}}
\label{fig:Single-User Cycles-c}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Single-User Cycles}
\label{fig:Single-User Cycles}
\end{figure}

% \begin{figure}
% \centering
% TODO: lam x. app(\#1, \hole)
% \caption{Single-User Cycles}
% \label{fig:Single-User Cycles}
% \end{figure}

Another case we must consider is when cycles appear in the graph.
We categorize these into cycles caused by the action of a single user
and cycles caused by the interaction of the actions of multiple users.

In a single user context,
normal insertion and deletion of code by the user cannot create cycles.
However, it is possible with certain kinds of copy and paste.
For example, suppose Alice is editing the code in \autoref{fig:Single-User Cycles-a}
and uses copy and paste to copy \Vertex{TODO} to the right child of \Vertex{TODO}.
There are two ways to interpret the paste action.
The first interpretation is to create a deep copy of \Vertex{TODO}.
This results in \autoref{fig:Single-User Cycles-b} and
does not cause a cycle.
The second interpretation is to simply add an edge to \Vertex{TODO}.
This results in \autoref{fig:Single-User Cycles-b}
and causes a cycle.

Note that not all pastes should be deep copies.
For example, Alice may have accomplished code move in \autoref{sub:Editing Nested Parts of the Code}
done by a cutting from the old position and pasting to the new position.
Preserving Bob's nested edits requires that the paste be by reference instead of by copy.
Distinguishing when a paste should be by reference versus by copy
is ultimately a user interface question.
Cycles caused by the local user's edits be detected as soon as a user enters them
by noting either that the graph would contain a cycle or the vertex
already has a parent somewhere in the graph.

Thus, as a user interface consideration, it might be best to either
disallow such edits to at least warn users that their
edits would create a cycle.

\subsubsection{Multi-User Cycles}
\label{sub:Multi-User Cycles}


\begin{figure*}
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{10}$" [> "Root$_{9}$"] -> {
   "$\texttt{+}_{2}$" [> "L$_{19}$"'] -> {
    "$\texttt{+}_{4}$" [> "L$_{19}$"'],
    "$\texttt{*}_{6}$" [> "R$_{19}$"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{Initial code}
\label{fig:Multi-User Cycles-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{8}$" [> "Root$_{7}$"] -> {
   "$\texttt{+}_{2}$" [> "L$_{19}$"'] -> {
   },
   {
    "$\texttt{+}_{4}$" [> "R$_{19}$"] -> {
     "$\texttt{*}_{6}$" [> "L$_{19}$"'],
     {}
    }
   }
  }
 }
};
\end{tikzpicture}
\caption{Initial code}
\label{fig:Multi-User Cycles-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{8}$" [> "Root$_{7}$"] -> {
   "$\texttt{+}_{2}$" [> "L$_{19}$"'] -> {
   },
   {
    "$\texttt{*}_{6}$" [> "R$_{19}$"] -> {
     "$\texttt{+}_{4}$" [> "L$_{19}$"'],
     {}
    }
   }
  }
 }
};
\end{tikzpicture}
\caption{Initial code}
\label{fig:Multi-User Cycles-c}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{8}$" [> "Root$_{7}$"] -> {
   "$\texttt{+}_{2}$" [> "L$_{19}$"'] -> {
   },
   {
    v1/"$\texttt{*}_{6}$" [> "R$_{19}$"],
    v2/"$\texttt{+}_{4}$" [> "R$_{19}$"]
   }
  }
 }
};
\path[draw,->] (v1) to [out=-45,in=-135] (v2);
\path[draw,->] (v2) to [out=-90,in=-90] (v1);
\end{tikzpicture}
\caption{Initial code}
\label{fig:Multi-User Cycles-d}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Multi-User Cycles}
\label{fig:Multi-User Cycles}
\end{figure*}

TODO: NEEDS UI MOCKUP

While single-user edits can be checked to see
whether they create a cycle and thus the system
can immediately warn the user,
multi-user edits may not manifest cycles until after
the edits from multiple users are merged.

For example, consider the situation in \autoref{fig:Multi-User Cycles}.
\autoref{fig:Multi-User Cycles-a} shows the graph after Alice and Bob have made some more edits,
and Alice and Bob's editors are synchronized with each other.
This graph represents the expression~\texttt{((\hole+\hole)+(\hole*\hole))+\hole}.
Alice moves the leftmost \texttt{+} into the rightmost hold
and then the \texttt{*} underneath that.
This results in \autoref{fig:Multi-User Cycles-b},
which represents the expression~\texttt{(\hole+\hole)+((\hole*\hole)+\hole)}.
On the other hand, Bob does the same move
but puts the \texttt{+} and under the \texttt{*}.
This results in \autoref{fig:Multi-User Cycles-c},
which represents the expression~\texttt{(\hole+\hole)+((\hole+\hole)*\hole)}.

On their own, neither of these edits creates a cycle.
However, merging the edit actions of both Alice and Bob results in the graph
in \autoref{fig:Multi-User Cycles-d}, which has a cycle
between \Vertex{TODO} and \Vertex{TODO}.
This situation is akin to a merge conflict in traditional version control systems.
Resolving it requires user input, but is as simple as
either deleting \Edge{TODO} and \Edge{TODO} (thus favoring Alice's version)
or deleting \Edge{TODO} and \Edge{TODO} (thus favoring Bob's version).
Since a cycle like this that is connected to the root vertex always
contains vertexes with multiple parents that if removed would break the cycle,
we use the user interface described in \autoref{sub:Multi-parent conflicts}
to display these kinds of programs.
For example, \autoref{fig:Multi-User Cycles-d} would be displayed
as shown in TODO:FIGURE.
We leave the user interface considerations of resolving the conflict such a
cycle represents to future work.


\subsubsection{Disconnection}
\label{sub:Disconnection}

\begin{figure*}
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{8}$" [> "Root$_{7}$"] -> {
   "$\texttt{+}_{2}$" [> "L$_{19}$"'],
   "$\texttt{*}_{6}$" [> "R$_{19}$"]
  }
 }
};
\end{tikzpicture}
\caption{Initial code}
\label{fig:Disconnection-a}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{8}$" [> "Root$_{7}$"] -> {
   "$\texttt{+}_{2}$" [> "L$_{19}$"'] -> {
    {},
    "$\texttt{*}_{6}$" [> "R$_{19}$"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\caption{Initial code}
\label{fig:Disconnection-b}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{8}$" [> "Root$_{7}$"] -> {
   {},
   "$\texttt{*}_{6}$" [> "R$_{19}$"] -> {
    "$\texttt{+}_{2}$" [> "L$_{19}$"'],
    {}
   }
  }
 }
};
\end{tikzpicture}
\caption{Initial code}
\label{fig:Disconnection-c}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}{0.24\textwidth}
\centering
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "$\texttt{+}_{8}$" [> "Root$_{7}$"]
 }
};
\path (-1cm,-3cm) graph[graph style] {
 times/"$\texttt{*}_{6}$" [> "L$_{19}$"']
};
\path (1cm,-3cm) graph[graph style] {
 plus/"$\texttt{+}_{2}$" [> "L$_{19}$"']
};
\path[draw,->] (times) to [out=45,in=135] (plus);
\path[draw,->] (plus) to [out=-135,in=-45] (times);
\end{tikzpicture}
\caption{Initial code}
\label{fig:Disconnection-d}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Disconnection}
\label{fig:Disconnection}
\end{figure*}

Finally, when multi-user edits are merged,
parts of the graph can become disconnected
even though they are connected in each user's
copy of the graph before the merge.

For example, consider the situation in \autoref{fig:Disconnection}.
\autoref{fig:Disconnection-a} shows the graph after Alice and Bob have made some more edits,
and Alice and Bob's editors are synchronized with each other.
This graph represents the expression~\texttt{(\hole+\hole)+(\hole*\hole)}.
Alice moves the \texttt{*} under \texttt{+}$_2$.
This results in \autoref{fig:Disconnection-b},
which represents the expression~\texttt{((\hole*\hole)+\hole)+\hole}.
On the other hand, Bob puts \texttt{+}$_2$ and under the \texttt{*}.
This results in \autoref{fig:Disconnection-c},
which represents the expression~\texttt{\hole+((\hole+\hole)*\hole)}.

When these edits are merged, the result is the graph in \autoref{fig:Disconnection-d}.
Since Alice deleted the edge from \Vertex{TODO} to \Vertex{TODO}
and Bob deleted the edge from \Vertex{TODO} to \Vertex{TODO},
when these are merged \Vertex{TODO} and \Vertex{TODO}
are completely disconnected from the root.

This is similar to the type of merge conflict
that can arise in traditional version control systems
when two users delete different functions that
are duplicates of the other.

Fortunately, we can detect this situation and warn the user
since the disconnection appears after merging two graphs
that did not have disconnected vertexes.

\subsection{Cursors}
\label{sub:Cursors}

Cursor is either on edge or on position

cursors are advisory

Don't model communication but would be separate layer anyway

\section{Formalism}
\label{sec:Formalism}

We will now make the intuitions developed in the previous section precise
by defining a collaborative structure editor calculus called Grove.
We begin in Sec.~\ref{sub:Syntax} with the syntax, then discuss
the internal graph representation in Sec.~\ref{sub:Convergent Graphs},
...


TODO: point of this section is commutativity theorem

The formalism is rather simple, \autoref{sec:Grove By Example} shows
that it is sufficient to handle many common situations,
and this simplicity aids in the predictability.

% $\arraycolsep=2pt\begin{array}{llcl}
% \mathsf{Typ} & \tau & ::= & t ~\vert~ \aparr{\tau}{\tau} ~\vert~ \aall{t}{\tau} ~\vert~ \arec{t}{\tau} ~\vert~ \aprod{\labelset}{\mapschema{\tau}{i}{\labelset}} ~\vert~ \asum{\labelset}{\mapschema{\tau}{i}{\labelset}}\\
% \mathsf{Exp} & e & ::= & x ~\vert~ \aelam{\tau}{x}{e} ~\vert~ \aeap{e}{e} ~\vert~ \aetlam{t}{e} ~\vert~ \aetap{e}{\tau} ~\vert~ \aefold{e} ~\vert~ \aetpl{\labelset}{\mapschema{e}{i}{\labelset}} ~\vert~  \aein{\ell}{e} \\
% & & \vert & \aematchwith{n}{e}{\seqschemaX{r}}\\
% \mathsf{Rule} & r & ::= & \aematchrule{p}{e}\\
% \mathsf{Pat} & p & ::= & x  ~\vert~ \aewildp ~\vert~ \aefoldp{p} ~\vert~ \aetplp{\labelset}{\mapschema{p}{i}{\labelset}} ~\vert~ \aeinjp{\ell}{p}
% \end{array}$

\begin{figure}
\[
\arraycolsep=0pt
\begin{array}{lrlll}
 \textrm{Patterns:}          & p    & {}\in Pat & {}::={} & x \mid \_ \\
 \textrm{Expressions:\qquad} & e    & {}\in Exp & {}::={} & x \mid \lambda p\mathord{:}\tau.e \mid e~e \mid e + e \mid n \mid \_ \\
 \textrm{Types:}             & \tau & {}\in Typ & {}::={} & \tau \rightarrow \tau \mid Num \mid \_ \\
\end{array}
\]
\caption{Syntax as a grammar for the lambda calculus that we are considering.}
\label{fig:Syntax as a grammar}
\end{figure}

\subsection{Syntax}
\label{sub:Syntax}

The language we are modeling is shown in \autoref{fig:Syntax as a grammar}.
Standard for a simply-typed lambda calculus except that
all terms have holes (represented by $\_$)
and the argument to a lambda is its own term.
The latter of which allows us to express lambdas with a hole for the bound variable.

In order to model this we define 


Turn that into a constructor set K + index set I + arity function (has type: K -> $\wp$(I)).


\begin{figure}
\[
\arraycolsep=0pt
\begin{array}{ll}
 \arity : \K \rightarrow & \wp(\I) \\
 \hline
 \arity(\Root)={}     & \left\{ \Root \right\} \\
 \arity(\PatVar)={}   & \left\{ \right\} \\
 \arity(\ExpVar)={}   & \left\{ \right\} \\
 \arity(\ExpLam)={}   & \left\{ \LamParam, \LamType, \LamBody \right\} \\
 \arity(\ExpApp)={}   & \left\{ \AppFun, \AppArg \right\} \\
 \arity(\ExpPlus)={}  & \left\{ \PlusLeft, \PlusRight \right\} \\
 \arity(\TypArrow)={} & \left\{ \ArrowArg, \ArrowResult \right\} \\
 \arity(\TypNum)={}   & \left\{ \right\} \\
\end{array}
\]
\caption{Constructors, Indexes and Arity}
\label{fig:Constructors, Indexes and Arity}
\end{figure}

\subsection{Convergent Graphs}
\label{sub:Convergent Graphs}

\subsubsection{Graphs}
\label{sub:Graphs}

TODO: rename indices to positions
TODO: look into using bold plus and minus (google results)

A graph $\G : \E \rightarrow \Sigma$ is a function from edges to edge states, 
where $\E = \U \times \V \times \P \times \V$,
and   unique IDs are drawn from some suitable set $\U$,
and   vertices are drawn from $\V$, 
and   positions are drawn from $\P$, 
and   edge states are drawn from $\Sigma$, all defined below.

Each edge $\e = (u, v, p, v^\prime)$ has a unique name, $u \in \U$, and connects the child position $p$ of a source vertex $v$ to a target vertex $v^\prime$.
The state of each edge, $\e$, is determined by the corresponding edge state, $\G(\e) \in \Sigma = \{ \bot, \Plus, \Minus \}$.
If $\G(\e) = \bot$, then $\e$ does not yet exist.
If $\G(\e)$ is $\Plus$, the edge has been created.
If $\G(\e)$ is $\Minus$, the edge has been destroyed.
The total ordering $\bot \sqsubset \Plus \sqsubset \Minus$ forms a lattice over $\Sigma$.

A vertex $v = (u, k)$ identifies a distinct instance of the constructor $k$.
Each constructor represents a different type of node in the target language's abstract syntax tree.

A position $p$ identifies a location adjacent to some parent vertex.

Every graph contains a distinguished root vertex, root constructor, and root position, respectively named $v_0$, $k_0$, and $p_0$.



% Define $\sqcup_{edge state}$ (i.e. join)

% lattice ordering $\bot < + < -$ LUB e.g., join A B = C

You can map from syntax to graph by selecting
unique IDs (for both edges and vertexes).
    - holes are not explicit in the graph

\subsubsection{Graph Actions}
\label{sub:Graph Actions}

A graph action is a +E or -E.

Graph action semantics is a transition system
between graphs. (join with whatever it was before)

G --action--> G'

\subsection{Commutativity}

In order to define commutativity, we first define a lattice over $G$.
Then we show that for any graphs $G$ and $G'$ and graph action $\alpha$,
$G \overset{\alpha}\rightarrow G'$
iff $G \sqcup \llbracket\alpha\rrbracket = G'$.
Thus the commutativity of graph actions is established
by the commutativity of the join operations defining those graph actions.


Discuss uniqueness of uuid

\begin{lemma}[Join Commutativity]
\label{lem:Join Commutativity}
\end{lemma}

\begin{lemma}[Joining]
\label{lem:Joining}
For all graphs $G$ and $G'$ and all edit actions $\alpha$,
$G \overset{\alpha}{\longrightarrow} G'$
iff $G \sqcup \llbracket\alpha_1\rrbracket = G'$.
\end{lemma}
\begin{proof}
If $G \overset{\alpha_1\alpha_2}{\longrightarrow} G'$
\end{proof}


\begin{theorem}[Commutativity]
\label{thm:Commutativity}
For all graphs $G$ and $G'$ and all edit actions $\alpha_1$ and $\alpha_2$,
if $G \overset{\alpha_1\alpha_2}{\longrightarrow} G'$,
then $G \overset{\alpha_2\alpha_1}{\longrightarrow} G'$.
\end{theorem}
\begin{proof}
Using \autoref{lem:Joining} to unfold $\rightarrow$ into $\sqcup$,
$G \sqcup \llbracket\alpha_1 \sqcup \llbracket \sqcup \alpha_2 \rrbracket = G'$.
Then by \autoref{lem:Join Commutativity},
$G \sqcup \llbracket\alpha_2 \sqcup \llbracket \sqcup \alpha_1 \rrbracket = G'$.
Finally using \autoref{lem:Joining} to fold $\sqcup$ into $\rightarrow$,
$G \overset{\alpha_2\alpha_1}{\longrightarrow} G'$.
\end{proof}

\subsubsection{Agda Mechanization}
\label{sub:Agda Mechanization}

\subsection{Edit Actions}
\label{sub:Edit Actions}

Mapping to graph actions

Sensibility -- mapping back from graphs
to well-typed states that fixes holes

\section{Type System}
\label{sec:Type System}

TODO: somewhere in here, maybe multiple places, we want to talk about typing the intermediate states that arise (background for structured editing)

editor states:

conflicts (multiple children in the same spot)

multi-parent

cycles

non-empty holes

----------------

User must supply edge selection for multi-parent

\section{TODO}
TODO: leaves

TODO: our model supports treating these as a cons-list of characters

\section{Implementation}
\label{sec:Implementation}
GRV -- how it is implemented, how it connects to the formalism, describe the graph, 

We implemented GRV as a core OCaml library in approximately 1,500 lines of code, and a basic Web interface in approximately 600 lines of OCaml code and 250 lines of HTML+CSS+Javascript.

Compared to the core language, our implementation lacks support for lists and case expressions.

Optimizations: least fixed point 

\section{Related Work}
\label{sec:Related Work}

Hazel
\citep{Omar:2019:10.1145/3290327}

CRDTs

Operational Transforms

Pijul

Etherpad

Live Share

Git

Darcs

Unision?

\section{Discussion and Conclusion}
\label{sec:Discussion and Conclusion}

TODO: memory usage

\subsection{Variable names, strings, and numbers}
\label{sub:Variable names, strings, and numbers}

NOTE: we could implement each digit as a separate characters

GUI for string conflicts: use popups

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

%% Appendix
\appendix

%% Appendixes that will be published  go **BEFORE** the bibliography and count towards the page count

%% Bibliography
\bibliography{grove-paper}

%% Temporary appendixes that will not be published go **AFTER** the bibliography and do not count towards the page count

\clearpage % Put these appendixes on separate pages so we can easily remove them from the document.  Also ensure all figures have been placed.

\section{Supplemental Material: Complete Graph Sequences for All Figures}
\label{apx:Supplemental Material: Complete Graph Sequences for All Figures}

TODO: put all intermediate states for all graphs along with the edge actions

\section{Appendix}
\label{apx:Appendix}

\subsection{Concepts}

\begin{tabular}{cl@{\hspace{1.5cm}}cl@{\hspace{1.5cm}}cl@{\hspace{1.5cm}}cl}
  $\A$ & Actions & $\S$ & Edge States   \\
  $\C$ & Cursors & $\U$ & UUIDs         \\
  $\E$ & Edges   & $\V$ & Vertexes      \\
  $\G$ & Graphs  & $\AA$ & Graph Actions \\
  $\I$ & Indices & $\EE$ & Editors       \\
  $\K$ & Constructors                   \\
\end{tabular}

A \emph{UUID} $u \in \U$ is a universally unique identifier.

\subsubsection{The Target Language}

\paragraph{Constructor} \par

A \emph{constructor} $k \in \K$ represents a node in the target language's abstract syntax tree (AST). Let $k_{root}$ be the root AST node.

\paragraph{Index} \par

An \emph{index} $i \in \I$ identifies a position, relative to some parent constructor, of a potential child node in the target language's AST. Let $i_{root}$ be the hyper-position of all rooted constructors.

\subsubsection{The Graph}

\paragraph{Vertex} \par

A \emph{vertex} $v = (k, u) \in \V = \K \times \U$ is a distinct instance of constructor $k$; that is, one that can be identified by UUID $u$. Let $v_{root} = (k_{root}, u_{root})$ be the root vertex of a graph. The \emph{rooted vertexes} of a graph are the immediate children of its $v_{root}$.

\paragraph{Cursor} \par

A \emph{cursor} $c = (v,i) \in \C = \V \times \I$ is a reference to the (possibly empty) set of all vertexes with parent vertex $v$ and child index $i$. Let $c_{root} = (v_{root}, i_{root})$ be the \emph{root cursor}, a reference to all of the rooted vertexes, of a graph.

\paragraph{Edge} \par

An \emph{edge} $\e = (c, v, u) \in \E = \C \times \V \times \U$ adds vertex $v$ with the set of vertexes referenced by cursor $c$.

\paragraph{Edge State} \par

An \emph{edge state} $s \in \S = \{\bot,+,-\}$ determines whether an edge does not exist ($\bot$), has been created (+), or has been destroyed (-).

\paragraph{Graph Action} \par

A \emph{graph action} $A = (\e,s,u) \in \A = \E \times \S \times \U$ is an instance of a binding from edge $\e$ to edge state $s$ that can be identified by UUID $u$. Denote by $[\e :-> s]_{u}$ a binding from edge $\e$ to edge state $s$ (identified by UUID $u$).

\paragraph{Graph} \par

A \emph{graph} $G = [\e :-> s]_{u}^{*} \in \G = \A^{*}$ is a function from edges to edge states. Denote by $G(\e) = s$ the state $s$ of edge $\e$ in graph $G$, and by $G A$ the extension of graph $G$ by graph action $A$.

\subsubsection{The Editor}

\paragraph{Move Action} \par

A \emph{move action} $a \in \A^{move} = \{ \Left,\Right,\Up,\Down \} \cup \{ \Select \} \times \C$ re-positions the cursor.

\paragraph{Edit Action} \par

An \emph{edit action} $a \in \A^{edit}= \{ \Create \} \times \K \cup \{ \Destroy \} \cup \{ \Restore \} \times \V$ adds or removes an edge at the cursor.

\paragraph{Communication Action} \par

A \emph{communication action} $a = (\Send, A^{*}, u^{*}) \in \A^{comm} = \{ \Send \} \times \A^{*} \times \U^{*}$ applies the graph action sequence $A^{*}$ to the editors identified by UUIDs $u^{*}$.

\paragraph{Action} \par

An \emph{action} $a \in \A = \A^{move} \cup \A^{edit} \cup \A^{comm}$ describes a change to one or more editors.

\paragraph{Editor} \par

An \emph{editor} $E = (G,c,A_{Q}^{*},A_{H}^{*},u) \in \EE = \mathcal{G} \times \C \times \AA^{*} \times \AA^{*} \times \U$ is an instance of graph $G$ with cursor $c$, queued graph actions $A_{Q}^{*}$, and known graph action history $A_{H}^{*}$, that can be identified by UUID $u$.

\subsubsection{The Environment} \par

An \emph{environment} $(E^{*}, A^{*}) \in \EE^{*} \times \AA^{*}$ is a set of communicating editors $E^{*}$ that share a global graph action history $A^{*}$.

\subsection{Sets and Relations}

\paragraph{Edges} \par

\begin{align*}
             \edges(G) &= \dom(G) \\
         \liveEdges(G) &= \{ \e \in \edges(G) | G(\e)=+ \}              \\
  \vertexChildren(G,v) &= \{ ((v',i),v'',u) \in \liveEdges(G) | v'=v \} \\
  \cursorChildren(G,c) &= \{ (c',v,u) \in \liveEdges(G) | c'=c \}       \\
         \parents(G,v) &= \{ (c,v',u) \in \liveEdges(G) | v'=v \}
\end{align*}

\paragraph{Vertexes} \par

\begin{align*}
        \vertexes(G) &= \{ v \in \V | \exists (c,v,u) \in \edges(G) \}               \\
    \liveVertexes(G) &= \{ v \in \V | \exists (c,v,u) \in \liveEdges(G) \}           \\
 \childVertexes(G,v) &= \{ v' \in \V | \exists (c,v',u) \in \vertexChildren(G,v) \}  \\
         \orphans(G) &= \{ v \in \liveVertexes(G) | \abs{\parents(G,v)} = 0 \}       \\
    \multiparents(G) &= \{ v \in \liveVertexes(G) | \abs{\parents(G,v)} > 1 \}       \\
        \vertex(G,u) &= v \in \vertexes(G) \iff (\exists k \in \K)(v = (k,u))
\end{align*}

\paragraph{Graph Actions} \par

$\known(E_1 \cdots E_n) = A_{H1}^{*} \cdots A_{Hn}^{*}
\iff (\forall j=1,\ldots,n)(E_j = (G_j,c_j,A_{Qj}^{*},A_{Hj}^{*},u_j))$

\section{Operational Semantics}

\subsection{Movement}

$\boxed{E,A -->a E,A}$

\begin{mathpar}
  \inferrule{
    \leftIndex(i) = i'
  }{
    (G,(v,i),A_Q^{*},A_H^{*},u),A \xrightarrow{\Left} (G,(v,i'),A_Q^{*},A_H^{*},u),A
  }

  \inferrule{
    \rightIndex(i) = i'
  }{
    (G,(v,i),A_Q^{*},A_H^{*},u),A \xrightarrow{\Right} (G,(v,i'),A_Q^{*},A_H^{*},u),A
  }

  \inferrule{
    \parents(v) = \{(c',v',u')\}
  }{
    (G,(v,i),A_Q^{*},A_H^{*},u),A \xrightarrow{\Up} (G,c',A_Q^{*},A_H^{*},u),A
  }

  \inferrule{
    \cursorChildren(c) = \{(c',(k,u_k),u')\} \\
    \downIndex(k) = i
  }{
    (G,c,A_Q^{*},A_H^{*},u),A \xrightarrow{\Down} (G,((k,u_k),i),A_Q^{*},A_H^{*},u),A
  }

  \inferrule{}{
    (G,c,A_Q^{*},A_H^{*},u),A \xrightarrow{\Select~c'} (G,c',A_Q^{*},A_H^{*},u),A
  }
\end{mathpar}

\subsection{Editing}

\begin{mathpar}
  \inferrule{
    \defaultIndex(c) = TODO(Was None) \\
    u, u_k \in \U \text{ fresh} \\
    A_H' = [(c,(k,u_k),u) :-> +]
  }{
    (G,c,A_Q^{*},A_H^{*},u),A \xrightarrow{\Create~k} (G A_H',c,A_Q^{*},A_H^{*}A_H',u),A
  }

  \inferrule{
    \defaultIndex(c) = i' \\
    c' = ((k,u_k),i') \\
    u, u_k \in \U \text{ fresh} \\
    \\\\
    \cursorChildren(G,c) = \{(c_j,v_j,u_j')\}_{j=1}^n \\
    A_H'^{*} =
    [(c  ,(k,u_k),u  ) :-> +]
    [(c' ,v_j    ,u_j') :-> +]_{j=1}^n
    [(c_j,v_j    ,u_j') :-> -]_{j=1}^n
  }{
    (G,c,A_Q^{*},A_H^{*},u),A \xrightarrow{\Create~k}
    (G A_H'^{*},c',A_Q^{*},A_H^{*}A_H'^{*},u),A
  }

  \inferrule{
    \cursorChildren(G,c) = \{\e_j\}_{j=1}^n \\
    A_H'^{*} = [\e_j :-> -]_{j=1}^n
  }{
    (G,c,A_Q^{*},A_H^{*},u),A \xrightarrow{\Destroy}
    (G A_H'^{*},c,A_Q^{*},A_H^{*}A_H'^{*},u),A
  }

  \inferrule{
    A_H = [(c,v,u') :-> +] \\
    u' \text{ fresh}
  }{
    (G,c,A_Q^{*},A_H^{*},u),A \xrightarrow{\Restore~v} (G A_H,c,A_Q^{*},A_H^{*}A_H,u),A %
  }
\end{mathpar}

\subsection{Communication}

\paragraph{Record} \par
%
\begin{mathpar}
  \inferrule{
    a \in \A^{edit} \\
    (G,c,A_Q^{*},A_H^{*},u),A -->a (G',c',A_Q^{*},A_H'^{*},u),A
  }{
    (G,c,A_Q^{*},A_H^{*},u),A -->a (G',c',A_Q^{*}a,A_H'^{*},u),A
  }
\end{mathpar}

\paragraph{Replay} \par

$\boxed{E,A \xrightarrow{a^{*}} E,A}$
%
\begin{mathpar}
  \inferrule{
    E,A -->a E'',A'' \\
    E'',A'' \xrightarrow{a^{*}} E',A' \\
  }{
    E,A \xrightarrow{aa^{*}} E',A'
  }
\end{mathpar}

\paragraph{Publish} \par

$\boxed{(E,A)^{*} -->a (E,A)^{*}}$
%
\begin{mathpar}
  \inferrule{
    E_j = (G_j,c_j,A_{Qj}^{*},A_{Hj}^{*},u_j) \\
    E_j,A_j \xrightarrow{a'^{*}} (G_j',c_j',A_{Qj}'^{*}, A_{Hj}'^{*},u_j),A_j' \\
    E_j' =
    ( G_j'
    , c_j'
    , A_{Qj}'^{*} \setminus a'^{*}
    , A_{Hj}'^{*} \setminus \known(E_1 \cdots E_n),u_j) \\
    j = 1,\ldots,n
  }{
    (E_1,A_1) \cdots (E_n,A_n) \xrightarrow{\Send~ a'^{*} } (E_1',A_1') \cdots (E_n',A_n')
  }
\end{mathpar}

Missing Action.env members: Record / Report / Stop / Replay, Dump / Load, Clone / Drop

\end{document}
