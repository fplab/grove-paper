%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review,anonymous,nonacm]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\documentclass[acmsmall,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

\bibliographystyle{ACM-Reference-Format}
%\citestyle{acmauthoryear}
\citestyle{acmnumeric}

%%%%%%%%

\renewcommand{\topfraction}{1} % Allow floats to take up the page
\renewcommand{\textfraction}{0}

%%%%%%%%
% \autoref from hyperref
\renewcommand{\AMSautorefname}          {Equation}
\renewcommand{\appendixautorefname}     {Appendix}
\renewcommand{\chapterautorefname}      {Chapter}
\renewcommand{\equationautorefname}     {Equation}
\renewcommand{\FancyVerbLineautorefname}{Line}
\renewcommand{\figureautorefname}       {Figure}
\renewcommand{\footnoteautorefname}     {Footnote}
\renewcommand{\Hfootnoteautorefname}    {Footnote}
\renewcommand{\itemautorefname}         {Item}
\renewcommand{\Itemautorefname}         {Item}
\renewcommand{\pageautorefname}         {Page}
\renewcommand{\paragraphautorefname}    {Section}
\renewcommand{\partautorefname}         {Part}
\renewcommand{\sectionautorefname}      {Section}
\renewcommand{\subparagraphautorefname} {Section}
\renewcommand{\subsectionautorefname}   {Section}
\renewcommand{\subsubsectionautorefname}{Section}
\renewcommand{\tableautorefname}        {Table}
\renewcommand{\theoremautorefname}      {Theorem}

%% Packages
\usepackage{booktabs}
\usepackage[rule=false]{subcaption}
\usepackage{graphicx}
% \usepackage{semantic}
\let\colonapprox\undefined % Avoid redefinition error in `colonequals`
\let\colonsim\undefined % Avoid redefinition error in `colonequals`
\usepackage{colonequals}
% \usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{fontawesome}
\usepackage{array}
\usepackage{todonotes}
% \usepackage[ruled]{algorithm2e}

% Load MnSymbol without clobbering \ast
% See https://tex.stackexchange.com/a/269691
\usepackage{amsmath}% needed before mathabx
\let\amsast=\ast
\usepackage[matha]{mathabx}% needed to prevent \ast getting clobbered
\let\abxast=\ast
\usepackage{MnSymbol}
\let\mnast=\ast
\let\ast=\abxast

% \selectcolormodel{gray}

\def\_{\texttt{\textunderscore}}

\newcommand{\id}[1]{\textcolor{gray}{\ensuremath{#1}}}


%%%%%%%%
% TikZ Stuff
%\usepackage{etex} % Fix "No room for new \dimen" error
\usepackage{shellesc} % Fix bug that breaks the tikz 'external' library
\usepackage{tikz}
\usetikzlibrary{babel} % Ensure compatibility the 'babel' package

\usetikzlibrary{external} % Needs to be separately enabled
%\tikzexternalize % Enable externalization
%\usepackage{lua-visual-debug}

\usetikzlibrary{arrows.meta} % Arrow Tips
\tikzset{>=Stealth}
%\tikzset{<=stealth}
%\tikzset{arrows={-Stealth[scale=50]}}
%\tikzset{edge from parent/.style={draw,->,line width=0.6pt}}
%\tikzset{wideline/.style={line width=0.7pt}}
%\tikzset{boldline/.style={color=black,line width=1.0pt}}

\usetikzlibrary{
  backgrounds,  % Provides "framed" and "gridded"
  bending,      % bending arrow tips
  decorations.pathmorphing,   % Provides wavy edges
  graphs,       % Graph *notation*
  graphdrawing, % Graph *layout*
  quotes,       % Quote syntax (e.g., "foo")
}

\usegdlibrary{
  trees,
}

\tikzset{
  %every picture/.style={framed, background rectangle/.style={draw=gray!50}},
}
\tikzset{edge style/.style={
  draw,
  %color=gray,
  font={\small\ttfamily},
  /tikz/every edge quotes/.style={
    %draw=gray!20,
    anchor=west,
    swap/.append code={
      \ifpgfarrowswap
        \pgfkeysalso{anchor=west}
      \else
        \pgfkeysalso{anchor=east}
      \fi}},
}}
\tikzset{graphs/graph style/.style={
  tree layout,
  level distance=0.5cm,
  level sep=0.5cm,
  sibling distance=0.5cm,
  sibling sep=0.1cm,
  part distance=0.1cm,
  part sep=0.1cm,
  component distance=0.1cm,
  component sep=0.1cm,
  nodes={
    draw,
    %color=gray,
    inner sep=2pt,
    rounded corners=1mm},
  edges={edge style},
}}
\tikzset{graphs/root style/.style={
 %draw=none,
 as={\textbullet$_{\id{0}}$}
}}
\tikzset{alice/.style={
  color=red!80!black,
  font={\bfseries\small},
  thick,
}}
\tikzset{bob/.style={
  color=green!60!black,
  font={\bfseries\small},
  thick,
}}
\tikzset{merge/.style={
  color=blue,
  font={\bfseries\small},
  thick,
}}
\tikzset{alice edge/.style={alice, edge style, font={\bfseries\small}}}
\tikzset{alice node/.style={alice}}
\tikzset{alice step/.style={alice}}
\tikzset{bob edge/.style={bob, edge style}, font={\bfseries\small}}
\tikzset{bob node/.style={bob}}
\tikzset{bob step/.style={bob}}
\tikzset{merge edge/.style={merge, edge style}, font={\bfseries\small}}
\tikzset{merge node/.style={merge}}
\tikzset{merge step/.style={merge,decorate,decoration={coil,amplitude=1.0pt,segment length=7.0pt,aspect=0}}}
\tikzset{star/.style={edge node={node[inner sep=0pt,at end,sloped] {\textbf{\huge${}^{\ast}$}}}}}

%%%%%%%%
% Lang components

% sets
\def\A{\mathcal{A}}
%\def\C{\mathcal{C}}
\def\E{\mathcal{E}}
\def\G{\mathcal{G}}
\def\I{\mathcal{I}}
\def\K{\mathcal{K}}
\def\P{\mathcal{P}}
\def\U{\mathcal{U}}
\def\V{\mathcal{V}}
\def\e{\varepsilon}
\def\AA{\textbf{A}}
\def\EE{\textbf{E}}

\newcommand{\abs}[1]{\left\lvert#1\right\rvert}

% constructors
\def\ExpVar{\mathsf{Exp\_var}}
\def\ExpLam{\mathsf{Exp\_lam}}
\def\ExpApp{\mathsf{Exp\_app}}
\def\ExpNum{\mathsf{Exp\_num}}
\def\ExpPlus{\mathsf{Exp\_plus}}
\def\ExpTimes{\mathsf{Exp\_times}}
\def\PatVar{\mathsf{Pat\_var}}
\def\TypNum{\mathsf{Typ\_num}}
\def\TypArrow{\mathsf{Typ\_arrow}}

% indexes
\def\Root{\mathsf{Root}}
\def\LamParam{\mathsf{Lam\_param}}
\def\LamType{\mathsf{Lam\_type}}
\def\LamBody{\mathsf{Lam\_body}}
\def\AppFun{\mathsf{App\_fun}}
\def\AppArg{\mathsf{App\_arg}}
\def\PlusLeft{\mathsf{Plus\_left}}
\def\PlusRight{\mathsf{Plus\_right}}
\def\TimesLeft{\mathsf{Times\_left}}
\def\TimesRight{\mathsf{Times\_right}}
\def\ArrowArg{\mathsf{Arrow\_arg}}
\def\ArrowResult{\mathsf{Arrow\_result}}

% actions
\def\Create{\text{Create}}
\def\Destroy{\text{Destroy}}
\def\Down{\text{Down}}
\def\Enqueue{\text{Enqueue}}
\def\Left{\text{Left}}
\def\Move{\text{Move}}
\def\Num{\text{Num}}
\def\Restore{\text{Restore}}
\def\Right{\text{Right}}
\def\Select{\text{Select}}
\def\Send{\text{Send}}
\def\Up{\text{Up}}

% relations
\DeclareMathOperator{\s}{\text{S}}
\DeclareMathOperator{\MP}{\text{MP}}
\DeclareMathOperator{\CC}{\text{C}}
\DeclareMathOperator{\D}{\text{D}}

\DeclareMathOperator{\arity}{\text{arity}}
\DeclareMathOperator{\childVertexes}{\text{childVertexes}}
\DeclareMathOperator{\cursorChildren}{\text{cursorChildren}}
\DeclareMathOperator{\vertexChildren}{\text{vertexChildren}}
\DeclareMathOperator{\dom}{\text{dom}}
\DeclareMathOperator{\edges}{\text{edges}}
\DeclareMathOperator{\known}{\text{known}}
\DeclareMathOperator{\liveEdges}{\text{liveEdges}}
\DeclareMathOperator{\liveVertexes}{\text{liveVertexes}}
\DeclareMathOperator{\multiparents}{\text{multiparents}}
\DeclareMathOperator{\orphans}{\text{orphans}}
\DeclareMathOperator{\parentVertexes}{\text{parentVertexes}}
\DeclareMathOperator{\reachable}{\text{reachable}}
\DeclareMathOperator{\seen}{\text{seen}}
\DeclareMathOperator{\unseen}{\text{unseen}}
\DeclareMathOperator{\vertexes}{\text{vertexes}}
\DeclareMathOperator{\vertex}{\text{vertex}}
\DeclareMathOperator{\publish}{\text{publish}}
\DeclareMathOperator{\leftIndex}{\text{leftIndex}}
\DeclareMathOperator{\rightIndex}{\text{rightIndex}}
\DeclareMathOperator{\downIndex}{\text{downIndex}}
\DeclareMathOperator{\defaultIndex}{\text{defaultIndex}}

% graph decomposition operators
\DeclareMathOperator{\expr}{\text{expr}}
\DeclareMathOperator{\patt}{\text{patt}}
\DeclareMathOperator{\type}{\text{type}}
\DeclareMathOperator{\parents}{\text{parents}}
\DeclareMathOperator{\ancestors}{\text{ancestors}}
\DeclareMathOperator{\vertices}{\text{vertices}}
\DeclareMathOperator{\children}{\text{children}}
\DeclareMathOperator{\lfp}{\text{lfp}}

\DeclareMathOperator{\multiParented}{\text{multiParented}}
\DeclareMathOperator{\singleParented}{\text{singleParented}}
\DeclareMathOperator{\deleted}{\text{deleted}}

% Define outline versions of + and -
\def\outlinepad{0.4pt}
\def\outlinestroke{0.4pt}
\newcommand{\Plus}{\mathord{
\begin{tikzpicture}[anchor=base, baseline]
%\node at (0,0) {+};
\path[draw, line width=\outlinestroke]
   ( 0.333em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --( 0.333em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad, -0.084em-\outlinestroke/2-\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad, -0.084em-\outlinestroke/2-\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.333em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.333em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --(-0.020em-\outlinestroke/2-\outlinepad,  0.583em+\outlinestroke/2+\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.583em+\outlinestroke/2+\outlinepad)
 --( 0.021em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --cycle
 ;
\end{tikzpicture}
}}
\newcommand{\Minus}{\mathord{
\begin{tikzpicture}[anchor=base, baseline]
%\node at (0,0) {$-$};
\path[draw, line width=\outlinestroke]
   ( 0.306em+\outlinestroke/2+\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --( 0.306em+\outlinestroke/2+\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.306em-\outlinestroke/2-\outlinepad,  0.229em-\outlinestroke/2-\outlinepad)
 --(-0.306em-\outlinestroke/2-\outlinepad,  0.270em+\outlinestroke/2+\outlinepad)
 --cycle
 ;
\end{tikzpicture}
}}

% custom syntax

\usepackage{xstring}

\newcommand{\hole}{\ensuremath{\square}} %\textcolor{violet}{\llparenthesis}}\textcolor{violet}{\rrparenthesis}}
\newcommand{\conflictHole}[1]{%
{\noexpandarg\StrSubstitute{#1}{,}{\textcolor{red}{\;\textbf{|}\;}}[\myargs]%
{\textcolor{red}{\textbf{\{}}\myargs\textcolor{red}{\textbf{\}}}}}}%

% Calling \newvertex{Foo}{bar} defines
%   \vidFoo to be a new id number, and
%   \vFoo to be \texttt{bar}\ensuremath{_{\vidFoo}}
\newcounter{NodeVertexCounter}
\newcommand{\newvertex}[2]{%
\ifodd\theNodeVertexCounter
  \addtocounter{NodeVertexCounter}{1}%
\else
  \addtocounter{NodeVertexCounter}{2}%
\fi
\expandafter\newcommand\csname vid#1\endcsname{}% This is just to check if this is a redefinition
\expandafter\global\expandafter\edef\csname vid#1\endcsname{\theNodeVertexCounter}%
\expandafter\newcommand\csname v#1\endcsname{}% This is just to check if this is a redefinition
\expandafter\gdef\csname v#1\endcsname{\texttt{#2}\ensuremath{_{\id{\csname vid#1\endcsname}}}}%
}
\newcommand{\newedge}[2]{%
\ifodd\theNodeVertexCounter
  \addtocounter{NodeVertexCounter}{2}%
\else
  \addtocounter{NodeVertexCounter}{1}%
\fi
\expandafter\newcommand\csname eid#1\endcsname{}% This is just to check if this is a redefinition
\expandafter\global\expandafter\edef\csname eid#1\endcsname{\theNodeVertexCounter}%
\expandafter\newcommand\csname e#1\endcsname{}% This is just to check if this is a redefinition
\expandafter\gdef\csname e#1\endcsname{\texttt{#2}\ensuremath{_{\id{\csname eid#1\endcsname}}}}%
}
\setcounter{NodeVertexCounter}{-1}
\newvertex{Root}{Root}

% Support \includegraphics of .dot files
\DeclareGraphicsRule{.dot}{pdf}{.pdf}{`dot -Tpdf #1 -o \noexpand\OutputFile}

\newcommand{\Edge}[1]{Edge~#1}
\newcommand{\Vertex}[1]{Vertex~#1}
\newcommand{\figureCode}[1]{\textbf{\texttt{#1}}\vskip1em}
\newcommand{\multiVertex}[1]{\textcolor{red}{\ensuremath{\curlyveedownarrow_{#1}}}}
\newcommand{\cycleVertex}[1]{\textcolor{red}{\ensuremath{\rcirclearrowleft_{#1}}}}
\newcommand{\orphanVertex}[1]{\textcolor{red}{\ensuremath{\mathbf{\ndownarrow_{#1}}}}}
\newcommand{\parens}[1]{\textcolor{gray}{(}#1\textcolor{gray}{)}}
\newcommand{\otherVertexVskip}{\vskip0.5em}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureSimple
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{SimpleTimes}{Root}%
\newvertex{SimpleTimes}{*}%
\newedge{SimpleX}{L}%
\newvertex{SimpleX}{x}%
\newedge{SimpleY}{R}%
\newvertex{SimpleY}{y}%
\newcommand{\figureSimple}{
\begin{figure}
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.32\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Simple/a) [anchor=base] {\strut};
\end{tikzpicture}
}%
\label{fig:Simple:a}
\figureCode{x * \hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style, color=black] -> {
  "\vSimpleTimes" [> "\eSimpleTimes", >color=black, color=black] -> {
   "\vSimpleX" [> "\eSimpleX"', >color=black, color=black],
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\begin{subfigure}[t]{0.32\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Simple/b) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Simple/a) to (-2em, 0cm |- node/Simple/b);
\end{tikzpicture}
}%
\label{fig:Simple:b}
\figureCode{x * y}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
  root[root style] -> {
  "\vSimpleTimes" [> "\eSimpleTimes"] -> {
    "\vSimpleX" [> "\eSimpleX"'],
    "\vSimpleY" [> "\eSimpleY", >alice edge, alice node]
  }
  }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.32\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Simple/c) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Simple/b) to (-2em, 0cm |- node/Simple/c);
\end{tikzpicture}
}%
\label{fig:Simple:c}
\figureCode{\hole{} * y}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
  root[root style] -> {
  "\vSimpleTimes" [> "\eSimpleTimes"] -> {
    {},
    "\vSimpleY" [> "\eSimpleY"]
  }
  }
};
\path (-0.25cm,-1.7cm) graph[graph style] {
  "\vSimpleX"
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Code that Includes a Hole and Some Simple Edits.}%
\label{fig:Simple}
\end{figure}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureWrap
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{WrapPlus}{Root}
\newvertex{WrapPlus}{+}
\newedge{WrapTimes}{L}
\newcommand{\figureWrapMove}{
\begin{figure}
\centering
\begin{minipage}[t]{.45\linewidth}
\hskip0.12\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.28\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (-7.5em,0cm) node (node/Simple/cx) [gray,anchor=base west] {{\textbf{\small Fig.~\ref*{fig:Simple:c}}}};
%%%%
\path (0cm,0cm) node (node/Wrap/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Simple/cx) to (-2em, 0cm |- node/Wrap/a);
\end{tikzpicture}
}%
\label{fig:Wrap:a}
\figureCode{\hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style]
};
\path (0cm,-1.7cm) graph[graph style] {
 "\vSimpleTimes" -> {
  {},
  "\vSimpleY" [> "\eSimpleY"]
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.28\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Wrap/b) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Wrap/a) to (-2em, 0cm |- node/Wrap/b);
\end{tikzpicture}
}%
\label{fig:Wrap:b}
\figureCode{\hole{} + \hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus", >alice edge, alice node]
 }
};
\path (0cm,-1.7cm) graph[graph style] {
 "\vSimpleTimes" -> {
  {},
  "\vSimpleY" [> "\eSimpleY"]
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.28\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Wrap/c) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Wrap/b) to (-2em, 0cm |- node/Wrap/c);
\end{tikzpicture}
}%
\label{fig:Wrap:c}
\figureCode{\hole{} * y + \hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eWrapTimes"', >alice edge] -> {
    {},
    "\vSimpleY" [> "\eSimpleY"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Example of Wrapping.  (Note that this figure omits the orphaned \vSimpleX{} since it is no longer relevant to the narrative of this paper.)}%
\label{fig:Wrap}
\end{minipage}
% \end{figure}
% }
%
\hfil
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureMove
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{MoveTimes}{R}
% \newcommand{\figureMove}{
% \begin{figure}[H]
\begin{minipage}[t]{.45\linewidth}
\hfill
%\hskip0.12\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.43\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Move/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Wrap/c) to (-2em, 0cm |- node/Move/a);
\end{tikzpicture}
}%
\label{fig:Move:a}
\figureCode{\hole{} + \hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"]
 }
};
\path (0cm,-1.7cm) graph [graph style] {
 "\vSimpleTimes" -> {
  {},
  "\vSimpleY" [> "\eSimpleY"]
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.43\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Move/b) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Move/a) to (-2em, 0cm |- node/Move/b);
\end{tikzpicture}
}%
\label{fig:Move:b}
\figureCode{\hole{} + \hole{} * y}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   {},
   "\vSimpleTimes" [> "\eMoveTimes", >alice edge] -> {
    {},
    "\vSimpleY" [> "\eSimpleY"]
   }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Example of Repositioning Code.}%
\label{fig:Move}
\end{minipage}
\end{figure}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureDifferentParts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{DifferentPartsAlice}{L}
\newvertex{DifferentPartsAlice}{u}
\newedge{DifferentPartsBob}{R}
\newvertex{DifferentPartsBob}{v}
% \newcommand{\figureDifferentParts}{
\newcommand{\figureDifferentPartsNestedParts}{
\begin{figure}
\begin{minipage}[t]{0.45\linewidth}
%\hfill
\hskip0.12\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.28\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (-7.5em,0cm) node (node/Move/bx) [gray,anchor=base west] {{\textbf{\small Fig.~\ref*{fig:Move:b}}}};
\path (0cm,0cm) node (node/DifferentParts/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Move/bx) to (-2em, 0cm |- node/DifferentParts/a);
\end{tikzpicture}
}%
\label{fig:DifferentParts:a}
\figureCode{\hole{} + u * y}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
  {},
  "\vSimpleTimes" [> "\eMoveTimes"] -> {
    "\vDifferentPartsAlice" [> "\eDifferentPartsAlice"', >alice edge, alice node],
    "\vSimpleY" [> "\eSimpleY"]
  }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.28\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/DifferentParts/b) [anchor=base] {\strut};
\path [draw,->,bob step] (node/Move/bx) to [out=15,in=165,star] (-2em, 0cm |- node/DifferentParts/b);
\end{tikzpicture}
}%
\label{fig:DifferentParts:b}
\figureCode{\hole{} + \hole{} * v}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
  {},
  "\vSimpleTimes" [> "\eMoveTimes"] -> {
    {},
    "\vDifferentPartsBob" [> "\eDifferentPartsBob", >bob edge, bob node]
  }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.28\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/DifferentParts/c) [anchor=base] {\strut};
\path [draw,->,merge step] (node/DifferentParts/a) to [out=15,in=165] (-2em, 0cm |- node/DifferentParts/c);
\path [draw,->,merge step] (node/DifferentParts/b) to (-2em, 0cm |- node/DifferentParts/c);
\end{tikzpicture}
}%
\label{fig:DifferentParts:c}
\figureCode{\hole{} + u * v}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
  {},
  "\vSimpleTimes" [> "\eMoveTimes"] -> {
    "\vDifferentPartsAlice" [> "\eDifferentPartsAlice"', >merge edge, merge node],
    "\vDifferentPartsBob" [> "\eDifferentPartsBob", >merge edge, merge node]
  }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Example of Users Editing Different Parts of the Code.}%
\label{fig:DifferentParts}
\end{minipage}
% \end{figure}
% }
%
\hfil
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureCommutativity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \newcommand{\figureCommutativity}{
% \begin{figure}
% \centering
% \begin{figure}
% \centering
% \begin{tikzpicture}
% \path (-3cm, 0cm) node (a) [align=center]       {Original \\ Version};
% \path ( 0cm, 1cm) node (b) [align=center,alice node] {Alice's  \\ Version};
% \path ( 0cm,-1cm) node (c) [align=center,bob node]   {Bob's    \\ Version};
% \path ( 3cm, 0cm) node (d) [align=center]       {Combined \\ Version};
% \path [draw,->,alice step] (a) -- node [pos=0.7,auto] {Alice's Edits} (b);
% \path [draw,->,bob step]   (a) -- node [pos=0.7,auto,swap]      {Bob's Edits}   (c);
% \path [draw,->,merge step] (b) -- node [pos=0.3,auto] {Sync} (d);
% \path [draw,->,merge step] (c) -- node [pos=0.3,auto,swap]      {Sync} (d);
% \end{tikzpicture}
% \caption{TODO:Commutativity}
% \label{fig:Commutativity}
% \end{figure}
% }
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureNestedParts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{NestedPartsAlice}{L}
\newvertex{NestedPartsAlice}{w}
\newedge{NestedPartsBob}{L}
% \newcommand{\figureNestedParts}{
% \begin{figure}
\begin{minipage}[t]{0.45\linewidth}
\hfill
%\hskip0.12\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.25\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/NestedParts/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/DifferentParts/c) to[star] (-2em, 0cm |- node/NestedParts/a);
\end{tikzpicture}
}%
\label{fig:NestedParts:a}
\figureCode{\hole{} + w * v}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   {},
   "\vSimpleTimes" [> "\eMoveTimes"] -> {
    "\vNestedPartsAlice" [> "\eNestedPartsAlice"', >alice edge, alice node],
    "\vDifferentPartsBob" [> "\eDifferentPartsBob"]
   }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.25\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/NestedParts/b) [anchor=base] {\strut};
\path [draw,->,bob step] (node/DifferentParts/c) to [out=15,in=165,star] (-2em, 0cm |- node/NestedParts/b);
\end{tikzpicture}
}%
\label{fig:NestedParts:b}
\figureCode{u * v + \hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"', >bob edge] -> {
    "\vDifferentPartsAlice" [> "\eDifferentPartsAlice"'],
    "\vDifferentPartsBob" [> "\eDifferentPartsBob"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.25\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/NestedParts/c) [anchor=base] {\strut};
\path [draw,->,merge step] (node/NestedParts/a) to [out=15,in=165] (-2em, 0cm |- node/NestedParts/c);
\path [draw,->,merge step] (node/NestedParts/b) to [out=15,in=165] (-2em, 0cm |- node/NestedParts/c);
\end{tikzpicture}
}%
\label{fig:NestedParts:c}
\figureCode{w * v + \hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"', >merge edge] -> {
    "\vNestedPartsAlice" [> "\eNestedPartsAlice"', >merge edge, merge node],
    "\vDifferentPartsBob" [> "\eDifferentPartsBob"]
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Example of Users Editing Nested Parts of the Code.}%
\label{fig:NestedParts}
\end{minipage}
\end{figure}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureMultiChild
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{MultiChildAlice}{R}
\newvertex{MultiChildAlice}{x}
\newedge{MultiChildBob}{R}
\newvertex{MultiChildBob}{y}
\newcommand{\figureMultiChild}{
\begin{figure}
%\hfill
\hskip0.12\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.21\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (-7.5em,0cm) node (node/NestedParts/cx) [gray,anchor=base west] {{\textbf{\small Fig.~\ref*{fig:NestedParts:c}}}};
%%%%
\path (0cm,0cm) node (node/MultiChild/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/NestedParts/cx) to (-2em, 0cm |- node/MultiChild/a);
\end{tikzpicture}
}%
\label{fig:MultiChild:a}
\figureCode{w * v + x}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    "\vNestedPartsAlice" [> "\eNestedPartsAlice"'],
    "\vDifferentPartsBob" [> "\eDifferentPartsBob"]
   },
   {
    "\vMultiChildAlice" [> "\eMultiChildAlice", >alice edge, alice node]
   }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.21\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/MultiChild/b) [anchor=base] {\strut};
\path [draw,->,bob step] (node/NestedParts/cx) to[out=15,in=165] (-2em, 0cm |- node/MultiChild/b);
\end{tikzpicture}
}%
\label{fig:MultiChild:b}
\figureCode{w * v + y}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    "\vNestedPartsAlice" [> "\eNestedPartsAlice"'],
    "\vDifferentPartsBob" [> "\eDifferentPartsBob"]
   },
   "\vMultiChildBob" [> "\eMultiChildBob", >bob edge, bob node]
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.4\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/MultiChild/c) [anchor=base] {\strut};
\path [draw,->,merge step] (node/MultiChild/a) to[out=15,in=165] (-2em, 0cm |- node/MultiChild/c);
\path [draw,->,merge step] (node/MultiChild/b) to (-2em, 0cm |- node/MultiChild/c);
\end{tikzpicture}
}%
\label{fig:MultiChild:c}
\figureCode{w * v + \conflictHole{x,y}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'anchor=-15] -> {
    "\vNestedPartsAlice" [> "\eNestedPartsAlice"'],
    "\vDifferentPartsBob" [> "\eDifferentPartsBob"]
   },
   "\vMultiChildAlice" [> "\eMultiChildAlice"anchor=153, >merge edge, merge node],
   {},
   "\vMultiChildBob" [> "\eMultiChildBob"anchor=195, >merge edge, merge node]
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
%\hfill{}
\caption{Example of Multi-Child Conflicts.}%
\label{fig:MultiChild}
\end{figure}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureMultiParent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{MultiParentAlice}{R}
\newedge{MultiParentBob}{R}
\newcommand{\figureMultiParent}{
\begin{figure*}
%\hfill
\hskip0.12\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.14\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (-7.5em,0cm) node (node/MultiChild/cx) [gray,anchor=base west] {{\textbf{\small Fig.~\ref*{fig:MultiChild:c}}}};
%%%%
\path (0cm,0cm) node (node/MultiParent/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/MultiChild/cx) to[star] (-2em, 0cm |- node/MultiParent/a);
\end{tikzpicture}
}%
\label{fig:MultiParent:a}
\figureCode{w * \hole{} + \hole{}\otherVertexVskip\phantom{\multiVertex{18} = w}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    "\vNestedPartsAlice" [> "\eNestedPartsAlice"'],
    {}
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.14\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/MultiParent/b) [anchor=base] {\strut};
\path [draw,->,alice step] (node/MultiParent/a) to[star] (-2em, 0cm |- node/MultiParent/b);
\end{tikzpicture}
}%
\label{fig:MultiParent:b}
\figureCode{\hole{} * w + \hole{}\otherVertexVskip\phantom{\multiVertex{18} = w}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    {},
    "\vNestedPartsAlice" [> "\eMultiParentAlice"', >alice edge]
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.14\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/MultiParent/c) [anchor=base] {\strut};
\path [draw,->,bob step] (node/MultiParent/a) to[out=15,in=165,star] (-2em, 0cm |- node/MultiParent/c);
\end{tikzpicture}
}%
\label{fig:MultiParent:c}
\figureCode{\hole{} * \hole{} + w\otherVertexVskip\phantom{\multiVertex{18} = w}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'],
   "\vNestedPartsAlice" [> "\eMultiParentBob", >bob edge]
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.14\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/MultiParent/d) [anchor=base] {\strut};
\path [draw,->,merge step] (node/MultiParent/b) to[out=15,in=165] (-2em, 0cm |- node/MultiParent/d);
\path [draw,->,merge step] (node/MultiParent/c) to[out=15,in=165] (-2em, 0cm |- node/MultiParent/d);
\end{tikzpicture}
}%
\label{fig:MultiParent:d}
\figureCode{\hole{} * \multiVertex{18} + \multiVertex{18}\otherVertexVskip\multiVertex{18} = w}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  a/{\vWrapPlus} [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    {},
    b/"\vNestedPartsAlice" [> "\eMultiParentAlice"', >merge edge]
   },
   {}
  }
 },
};
\path [draw,->,merge edge] (a) to ["\eMultiParentBob",out=-60,in=60] (b);
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.14\linewidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/MultiParent/e) [anchor=base] {\strut};
\path [draw,->,alice step] (node/MultiParent/d) to (-2em, 0cm |- node/MultiParent/e);
\end{tikzpicture}
}%
\label{fig:MultiParent:e}
\figureCode{\hole{} * w + \hole{}\otherVertexVskip\phantom{\multiVertex{18} = w}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  v8/"\vWrapPlus" [> "\eWrapPlus"] -> {
   v2/"\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    {},
    "\vNestedPartsAlice" [> "\eMultiParentAlice"']
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Example of Multi-Parent Conflicts.}%
\label{fig:MultiParent}
\end{figure*}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureCycle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{MultiCycleTimes}{L}
\newvertex{MultiCycleTimes}{*}
\newedge{MultiCyclePlus}{R}
\newvertex{MultiCyclePlus}{+}
\newedge{MultiCycleAliceTimes}{R}
\newedge{MultiCycleAlicePlus}{L}
\newedge{MultiCycleBobPlus}{R}
\newedge{MultiCycleBobTimes}{L}
\newcommand{\figureCycle}{
\begin{figure*}
%\hfill
\hskip0.07\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.2\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (-9em,0cm) node (node/MultiParent/ex) [gray,anchor=base west] {{\textbf{\small Fig.~\ref*{fig:MultiParent:e}}}};
%%%%
\path (0cm,0cm) node (node/Cycle/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/MultiParent/ex) to[star] (-2em, 0cm |- node/Cycle/a);
\end{tikzpicture}
}%
\label{fig:Cycle:a}
\figureCode{\parens{\hole{} * \hole{}} * \parens{\hole{} + \hole{}} + \hole{}%
  \otherVertexVskip\phantom{\multiVertex{30} = \multiVertex{32} * \hole{}}%
  \\\phantom{\multiVertex{32} = \multiVertex{30} * \hole{}}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    "\vMultiCycleTimes" [> "\eMultiCycleTimes"', >alice edge, alice node],
    "\vMultiCyclePlus" [> "\eMultiCyclePlus", >alice edge, alice node]
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.2\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Cycle/b) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Cycle/a) to[star] (-2em, 0cm |- node/Cycle/b);
\end{tikzpicture}
}%
\label{fig:Cycle:b}
\figureCode{\hole{} * \hole{} + \parens{\hole{} + \hole{}} * \hole{}%
  \otherVertexVskip\phantom{\multiVertex{30} = \multiVertex{32} * \hole{}}%
  \\\phantom{\multiVertex{32} = \multiVertex{30} * \hole{}}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
   },
   {
    "\vMultiCycleTimes" [> "\eMultiCycleAliceTimes", >alice edge, alice node] -> {
     "\vMultiCyclePlus" [> "\eMultiCycleAlicePlus"', >alice edge, alice node],
     {}
    }
   }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.2\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Cycle/c) [anchor=base] {\strut};
\path [draw,->,bob step] (node/Cycle/a) to[out=15,in=165,star] (-2em, 0cm |- node/Cycle/c);
\end{tikzpicture}
}%
\label{fig:Cycle:c}
\figureCode{\hole{} * \hole{} + \parens{\hole{} * \hole{} + \hole{}}%
  \otherVertexVskip\phantom{\multiVertex{30} = \multiVertex{32} * \hole{}}%
  \\\phantom{\multiVertex{32} = \multiVertex{30} * \hole{}}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
   },
   {
    "\vMultiCyclePlus" [> "\eMultiCycleBobPlus", >bob edge, bob node] -> {
     "\vMultiCycleTimes" [> "\eMultiCycleBobTimes"', >bob edge, bob node],
     {}
    }
   }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.2\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Cycle/d) [anchor=base] {\strut};
\path [draw,->,merge step] (node/Cycle/b) to[out=15,in=165] (-2em, 0cm |- node/Cycle/d);
\path [draw,->,merge step] (node/Cycle/c) to (-2em, 0cm |- node/Cycle/d);
\end{tikzpicture}
}%
\label{fig:Cycle:d}
\figureCode{\parens{\hole{} * \hole{}} + \conflictHole{\multiVertex{30},\multiVertex{32}}%
  \otherVertexVskip\multiVertex{30} = \multiVertex{32} * \hole{}%
  \\\multiVertex{32} = \multiVertex{30} * \hole{}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'anchor=-15] -> {
   },
   v1/"\vMultiCycleTimes" [> "\eMultiCycleAliceTimes"anchor=155, >merge edge, merge node],
   {},
   v2/"\vMultiCyclePlus" [> "\eMultiCycleBobPlus"anchor=-165, >merge edge, merge node]
  }
 }
};
\path[draw,-{>[bend]},merge edge] (v1) to ["\eMultiCycleAlicePlus"anchor=south,out=-60,in=-120] (v2);
\path[draw,-{>[bend]},merge edge] (v2) to ["\eMultiCycleBobTimes"anchor=north,out=-90,in=-90] (v1);
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
%\hfill{}
\caption{Example of Cycles.}
% TODO replace screenshots with text
% TODO make ref code gray
% TODO move whole figure left
% TODO remove cursor from screenshots
% TODO add multiparent box
% TODO only show parens where needed - figure 10, 11 - by associativity
% TODO repplace cycle screenshot with cycles box %
\label{fig:Cycle}
\end{figure*}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \figureDisconnect
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newedge{DisconnectAlice}{R}
\newedge{DisconnectBob}{L}
\newcommand{\figureDisconnect}{
\begin{figure*}
%\hfill
\hskip0.12\columnwidth
%%%%%%%%
\begin{subfigure}[t]{0.21\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (-7.5em,0cm) node (node/Cycle/dx) [gray,anchor=base west] {{\textbf{\small Fig.~\ref*{fig:Cycle:d}}}};
%%%%
\path (0cm,0cm) node (node/Disconnect/a) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Cycle/dx) to[star] (-2em, 0cm |- node/Disconnect/a);
\end{tikzpicture}
}%
\label{fig:Disconnect:a}
\figureCode{\hole{} * \hole{} + \hole{} * \hole{}\otherVertexVskip\strut}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'],
   "\vMultiCycleTimes" [> "\eMultiCycleAliceTimes"]
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.21\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Disconnect/b) [anchor=base] {\strut};
\path [draw,->,alice step] (node/Disconnect/a) to[star] (-2em, 0cm |- node/Disconnect/b);
\end{tikzpicture}
}%
\label{fig:Disconnect:b}
\figureCode{\hole{} * \parens{\hole{} * \hole{}} + \hole{}\otherVertexVskip\strut}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   "\vSimpleTimes" [> "\eNestedPartsBob"'] -> {
    {},
    "\vMultiCycleTimes" [> "\eDisconnectAlice", >alice edge]
   },
   {}
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.21\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Disconnect/c) [anchor=base] {\strut};
\path [draw,->,bob step] (node/Disconnect/a) to[out=15,in=165,star] (-2em, 0cm |- node/Disconnect/c);
\end{tikzpicture}
}%
\label{fig:Disconnect:c}
\figureCode{\hole{} + \parens{\hole{} * \hole{}} * \hole{}\otherVertexVskip\strut}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"] -> {
   {},
   "\vMultiCycleTimes" [> "\eMultiCycleAliceTimes"] -> {
    "\vSimpleTimes" [> "\eDisconnectBob"', >bob edge],
    {}
   }
  }
 }
};
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill
%%%%%%%%
\begin{subfigure}[t]{0.21\textwidth}
\centering
\caption{
\begin{tikzpicture}[remember picture, overlay]
\path (0cm,0cm) node (node/Disconnect/d) [anchor=base] {\strut};
\path [draw,->,merge step] (node/Disconnect/b) to[out=15,in=165] (-2em, 0cm |- node/Disconnect/d);
\path [draw,->,merge step] (node/Disconnect/c) to (-2em, 0cm |- node/Disconnect/d);
\end{tikzpicture}
}%
\label{fig:Disconnect:d}
\figureCode{\hole{} + \hole{}\otherVertexVskip\cycleVertex{2} = \hole{} * \parens{\cycleVertex{2} * \hole{}}}%
\begin{tikzpicture}
\path (0cm,0cm) graph[graph style] {
 root[root style] -> {
  "\vWrapPlus" [> "\eWrapPlus"]
 }
};
\path (-0.5cm,-2cm) graph[graph style] { plus/"\vSimpleTimes" };
\path ( 0.5cm,-2cm) graph[graph style] { times/"\vMultiCycleTimes" };
\path[draw,->,merge edge] (times) to ["\eMultiCycleBobTimes"'anchor=north,out=-135,in=-45] (plus);
\path[draw,->,merge edge] (plus) to ["\eMultiCycleBobPlus"anchor=south,out=45,in=135] (times);
\end{tikzpicture}
\end{subfigure}
%%%%%%%%
\hfill{}
\caption{Example of Disconnection.}%
\label{fig:Disconnection}
\end{figure*}
}

\newvertex{DecompPlusA}{+}
\newedge{DecompTimesA}{L}
\newvertex{DecompTimesA}{*}
\newedge{DecompPlusAX}{R}
\newvertex{DecompX}{x}
\newedge{DecompTimesAX}{R}
%
\newedge{DecompPlusB}{L}
\newvertex{DecompPlusB}{+}
\newedge{DecompTimesB}{R}
\newvertex{DecompTimesB}{*}
\newedge{DecompY}{R}
\newvertex{DecompY}{y}
\newedge{DecompZ}{R}
\newvertex{DecompZ}{z}
%
\newedge{DecompTimes}{L}
%
\newcommand{\figureDecompExample}{
\begin{figure}
  \centering
  \begin{subfigure}{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \path (0cm,0cm) graph[graph style] {
        root[root style] -> {
        a/{\vDecompPlusA} [> "\eSimpleTimes"] -> {
          "\vDecompTimesA" [> "\eDecompTimesA"'] -> {
          {},
          b/"\vDecompX" [> "\eDecompTimesAX"']
          },
          {}
        }
        },
      };
      \path [draw,->] (a) to ["\eDecompPlusAX",out=-60,in=60] (b);
      %
      \path (2cm,-0.85cm) graph[graph style] { plus/"\vDecompPlusB" };
      \path (3cm,-0.85cm) graph[graph style] { times/"\vDecompTimesB" };
      \path (3.25cm,-1.75cm) graph[graph style] { y/"\vDecompY" };
      \path[draw,->] (times) to ["\eDecompPlusB"'anchor=north,out=-135,in=-45] (plus);
      \path[draw,->] (plus) to ["\eDecompTimesB"anchor=south,out=45,in=135] (times);
      \path[draw,->] (times) to ["\eDecompY"anchor=west] (y);
      %
      \path (1.55cm,-2.1cm) graph[graph style] { plus/"\vDecompZ" };
    \end{tikzpicture}
    \caption{subcaption 1 goes here}%
    \label{fig:Decomposition example graph}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \begin{align*}
      e_r &= \hole~\texttt{*}^{\id{40}}~\multiVertex{42}~\texttt{+}^{\id{38}}~\multiVertex{42} \\
      MP &= \{x^{\id{42}}\} \\
      NP &= \{z^{\id{52}}\} \\
      W &= \{\hole~\texttt{+}^{\id{46}}~\cycleVertex{46}~\texttt{*}^{\id{48}}~y^{\id{50}}\} \\
    \end{align*}
    \caption{subcaption 2 goes here}%
    \label{fig:Decomposition example grove}
  \end{subfigure}
  \caption{Main caption goes here}%
  \label{fig:Decomposition example}
\end{figure}
}

\begin{document}

%% Title information
% \title[Grove]{Convergent Collaborative Structure Editing}
\title[Grove]{Grove: A Convergent Collaborative Structure-Editor Calculus}
%\subtitle{Subtitle}

%% Author information
\author{Michael D. Adams}
\orcid{0000-0003-3160-6972}

\author{Eric Griffis}
\orcid{0000-0003-1693-6172}

\author{Cyrus Omar}
\orcid{0000-0003-4502-7971}
\affiliation{
  %\position{Assistant Research Scientist}
  \department[0]{Computer Science and Engineering}
  \department[1]{Electrical Engineering and Computer Science}
  \department[2]{College of Engineering}
  \institution{University of Michigan}
  \streetaddress{Bob and Betty Beyster Building, 2260 Hayward Street}
  \city{Ann Arbor}
  \state{MI}
  \postcode{48109-2121}
  \country{USA}
}


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
  Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10011007.10011006.10011008</concept_id>
%<concept_desc>Software and its engineering~General programming languages</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%<concept>
%<concept_id>10003456.10003457.10003521.10003525</concept_id>
%<concept_desc>Social and professional topics~History of programming languages</concept_desc>
%<concept_significance>300</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}
%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
% \keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}%
\label{sec:Introduction}

TODO: fix the following warning which are reported by LaTeX but not Overleaf: Class acmart Warning: A possible image without description on input line 321.

Motivation:

- collaborative editing (both synchronous ala Google Docs and asynchronous version control)
is good and important as computing grows

- semantic structure editing is good because it solves the gap problem (semantic editor services
are always available) -- cite Hazelnut papers (talk about holes)

- previous approaches to collaborative editing have limitations

- diff/merge based approaches (trying to solve the inverse problem based on final states --
you lose the actual actions that were performed, and have to reconstruct them or an approx.
of them i.e. add line/delete line actions -- would need to adapt this to structure editing,
some papers have started to look at that, but fundamentally we don't want to throw away the
knowledge we have about the edits!)

- operational transforms (complexity, you have to patch previous actions based on new actions)

- CRDT-based collaborative editing (that's all been on text, not PL semantics) -- this is good
because it is relatively simple: you just send all the edits to all the replicas and they are
convergent by design

- we want to have the same convergence for a CRDT-based collaborative structure editor that maintains
the sensibility invariant of Hazelnut, i.e. every editor state has meaning. mention that maintaining sensibility
allows scaling of semantic editor services in the presence of large number of collaborators (in contrast,
using VS Code or other collaborative text editors with large numbers of collaborators means that almost always
the semantic editor services will be disabled because the program is going to be broken in multiple places
transiently)

this is tricky because:

- some edits might be conflicting -- solve this with "conflict holes"

- adding cut/paste or delete/restore allows for degenerate programs (cycles, multiple parents, etc.)

- since we are commutative, we solve both synchronus and async collaborative editing

- and this resolves issues around merges and conflicts

- contribution of this paper is to solve these problems from type-theoretic first principles:

- ...

- Hazel

\subsection{Contributions and Paper Organization}%
\label{sec:Contributions and Paper Organization}

\section{Grove By Example}%
\label{sec:Grove By Example}

This section introduces collaborative structure editing in Grove.
We begin in \autoref{sub:Program Representation} by covering how we use graphs to represent expressions with holes,
\autoref{sub:Single-User Actions} explores actions performed by a single user, Alice,
and \autoref{sub:Multi-user Interactions} explores actions performed by multiple users, Alice and Bob,
each of whom is editing their own instance of a program.

\subsection{Program Representation}%
\label{sub:Program Representation}

\figureSimple{}

The \textit{program state} for each editor instance in Grove consists of a graph that represents the program being edited.
This can be presented to the user as an expression containing holes.
For example, \autoref{fig:Simple:a} shows one such graph and its corresponding expression,~\texttt{x * \hole}, which
has a hole on the right side of the times operator.

Program state is a directed graph with a distinguished root vertex.
Each vertex represents a term and is labeled with both a globally unique identifier and a term constructor.
In \autoref{fig:Simple:a}, \vSimpleTimes{} and \vSimpleX{} have the constructors~\texttt{*} and \texttt{var(x)}, respectively. (For the sake of compactness, in our figures, we abbreviate \texttt{var(x)} as simply \texttt{x}.)
The root vertex has the distinguished identifier~0 and the constructor~\textbullet.

Each term constructor has an associated set of child positions.
The~\texttt{*} constructor has positions for~\texttt{L}~(i.e., left) and~\texttt{R}~(i.e., right) children
and the~\texttt{var} constructors have no child positions but takes an argument naming the particular
variable referenced~(e.g.,~\texttt{x} in \texttt{var(x)}).\footnote{Note that,
  for the purposes of this paper, we represent identifiers and number literals
  indivisibly.  See Section~TODO:REF, for how we would allow editing individual characters.}
The root vertex constructor,~\textbullet, has the single child position \texttt{Root}.

Each edge is labeled with a globally unique identifier~(e.g.,~1 and~3 in \autoref{fig:Simple:a}) and
a child position (e.g., \texttt{L} and \texttt{Root} in \autoref{fig:Simple:b}).
An edge indicates that the destination vertex is a child of the origin vertex at the given position.
%Visually, we indicate the position of an edge by the location of its origin.
For the sake of presentation clarity, we reserve odd identifiers for vertexes and even identifiers for edges.

Finally, holes are represented by the absence of a child.
For example, in \autoref{fig:Simple:a} the absence of an \texttt{R} edge coming from \vSimpleTimes{}
corresponds to the hole on the right of the~\texttt{*} in~\texttt{x * \hole}.

\figureWrapMove{}
% \figureMove{}

\subsection{Single-User Actions}%
\label{sub:Single-User Actions}

In the remainder of this section,
we consider user actions, starting
in this subsection with single-user
actions and continuing in \autoref{sub:Multi-user Interactions}
with multi-user actions.

Each user action corresponds to one or more graph edits.
Graph edits can only add fresh edges and vertices or remove existing edges.

User actions act relative to a cursor.
We do not model cursor sharing and the cursor does not appear in the underlying graph.
We discuss cursor representations and cursor sharing in more detail in \autoref{sub:Cursors}.

\subsubsection{Construction Actions}%
\label{sub:Construction}

To start our examples, Alice moves her cursor to the hole in~\texttt{x * \hole} in \autoref{fig:Simple:a}
and constructs the variable~\texttt{y} as shown in \autoref{fig:Simple:b}.
This action corresponds to creating \eSimpleY{} from \vSimpleTimes{} at the \texttt{R} position to a newly
created vertex, \vSimpleY{}, containing the variable reference~\texttt{y}.
The resulting graph, shown in \autoref{fig:Simple:b}, represents the expression \texttt{x * y}.

\subsubsection{Deletion Actions}%
\label{sub:Deletion}

% \figureMove{}

Next Alice deletes~\texttt{x} so that the code becomes~\texttt{\hole{} * y}.
This is modeled by deleting \eSimpleX{} as shown in \autoref{fig:Simple:c}.
Notice that \vSimpleX{} continues to exist, and if it had any children, those children would remain connected to it.
In our system, once a vertex is created it is never deleted.
This allows further manipulations of those vertices by other users as shown later in this section.
Note that we omit such orphaned vertexes from the remaining diagrams if they are not relevant to the exposition.

Once an edge with a particular identifier is deleted, it cannot be recreated.

Thus if Alice performed an ``undo'' on this deletion, Grove would create a fresh edge between \vSimpleTimes{} and \vSimpleX{}.

\subsubsection{Wrapping Actions}%
\label{sub:Wrapping}

Next, Alice types~\texttt{+} when the cursor is on \vSimpleTimes{}.
If this were a hole, this would cause a construction action to be performed as in \autoref{sub:Construction} above.
However, Alice's editor sees that this position is already occupied by the \texttt{*} expression,
so typing~\texttt{+} is interpreted as a wrapping action instead of a construction action.
This corresponds to the following sequence of graph edits, shown in \autoref{fig:Wrap}:
(a) delete \eSimpleTimes{}, leaving \vSimpleTimes{} temporarily orphaned,
(b) add a fresh~\texttt{+} vertex (\vWrapPlus{}) as a child of the root vertex, and
(c) add an edge to \vSimpleTimes{} in the left child position of this new~\texttt{+} vertex.
(The choice of wrapping with a bias for the left child position is arbitrary.)

\subsubsection{Repositioning Actions}%
\label{sub:Repositioning}

If a user wants to reposition code from one place to another, we have two options.
The first is to delete the code from its old position, and
reconstruct the code in its new position.
However, edges and vertices have unique identifiers in Grove
to support the collaborative editing features we discuss next,
so reconstruction will not preserve identity of vertices and edges.
Consequently, we take the second option: explicit repositioning actions that preserve identity.
These actions would be triggered by, for example, a drag and drop, or a cut and paste
(but not copy and paste, or a second paste after a cut, which do not need to
preserve identity and so would rely on reconstruction as already described in \autoref{sub:Construction}).

In terms of the graph, a repositioning action involves simply deleting the edge
from the original parent then adding an edge from the new parent.
Thus the code is actually \textit{repositioned}, not copied.

For example, in \autoref{fig:Move} Alice continues by
repositioning \texttt{\hole{} * y} from the left child of \texttt{+} to its right child.
This corresponds to the following sequence of graph edits, shown in \autoref{fig:Move}:
(a) delete \eWrapTimes{} leaving \vSimpleTimes{} temporarily orphaned and
(b) add \eMoveTimes{} to \vSimpleTimes{} in the right child position of \vWrapPlus{}.

% \figureDifferentParts{}
\figureDifferentPartsNestedParts{}

%\figureCommutativity{}
\begin{figure}
  \centering
  \begin{tikzpicture}
    \path (-3cm, 0cm) node (a) [align=center]            {Original \\ Version};
    \path ( 0cm, 1cm) node (b) [align=center,alice node] {Alice's  \\ Version};
    \path ( 0cm,-1cm) node (c) [align=center,bob node]   {Bob's    \\ Version};
    \path ( 3cm, 0cm) node (d) [align=center]            {Synchronized \\ Version};
    \path [draw,->,alice step] (a) -- node [pos=0.7,align=center,auto]      {Alice's \\ Edits} (b);
    \path [draw,->,bob step]   (a) -- node [pos=0.7,align=center,auto,swap] {Bob's \\ Edits}   (c);
    \path [draw,->,merge step] (b) -- node [pos=0.3,align=center,auto]      {Share \\ Edits} (d);
    \path [draw,->,merge step] (c) -- node [pos=0.3,align=center,auto,swap] {Share \\ Edits} (d);
  \end{tikzpicture}
  \caption{Commutativity of Edits.}
  \label{fig:Commutativity}
\end{figure}

\subsection{Multi-user Interactions}%
\label{sub:Multi-user Interactions}

Having described single-user actions,
we turn our attention to how Grove handles multiple users.
This section generalizes to any number of users,
but for simplicity we consider only two in our examples: Alice and Bob.
Alice and Bob each maintain their own editor instances and perform
actions relative to its state (using their own cursors, which we discuss in \autoref{sub:Cursors}).

Users coordinate by sharing with one another the graph edits corresponding to each
action~(e.g., via direct network connections or relayed through a server).
TODO: CITE(how to share network data -- DHT? consensus? ).
The granularity of communication may vary.
For real-time collaborative editing, edits may be sent as they occur.
For version control, edits may be batched together in the form of commits.
As we will show, these edits are commutative, so editors converge to the same state
when all edits are shared.
We assume users have some way to create globally unique identifiers for
verticies and edges without coordination~(e.g.,~GUIDs TODO:CITE:GUIDS).

\subsubsection{Editing Different Parts of the Code}%
\label{sub:Editing Different Parts of the Code}

We start each user where we left off in the previous section with the state shown in \autoref{fig:Move:b}.
Alice then adds~\vDifferentPartsAlice{} as the left child of \vSimpleTimes{},
and Bob changes \vSimpleY{} to \vDifferentPartsBob{}.
Before transmitting their edits to each other,
Alice and Bob thus have the graphs in \autoref{fig:DifferentParts:a}
and \autoref{fig:DifferentParts:b}, respectively.
(Note that the transition edge from \autoref{fig:Move:b} to
\autoref{fig:DifferentParts:b} represents
multiple graph-edit steps, i.e., deleting~\eSimpleY{} and adding~\eDifferentPartsBob{} along with its child~\vDifferentPartsBob{}.
We thus mark it with a star.)

Alice and Bob then transmit their graph edits to each other
and apply the other's graph edits to their own copy of the graph.
This results in both Alice and Bob having the graph in
\autoref{fig:DifferentParts:c}.

% \figureNestedParts{}

\subsubsection{Commutativity}%
\label{sub:Commutativity:informal}

\todo{rev}
Note that aside from transmitting edge deletions and additions,
merging requires no coordination between Alice and Bob.
For example, suppose Alice and Bob did not transmit their edits to each other
but instead to a third user, Chris.
Chris can apply the edits from Alice and Bob in any order and will always get
the graph in \autoref{fig:DifferentParts:c}.

In other words, our edit model obeys the commutativity shown in \autoref{fig:Commutativity}.
For any sequences of edits from Alice and Bob,
applying them in any order always produces the same results.
(We show this formally in \autoref{sub:Commutativity:informal}.)


\subsubsection{Editing Nested Parts of the Code}%%
\label{sub:Editing Nested Parts of the Code}

After Alice and Bob share their edits to get the graph in \autoref{fig:DifferentParts:c},
Alice changes~\vDifferentPartsAlice{} to~\vNestedPartsAlice{}, which results in the graph in \autoref{fig:NestedParts:a}.
Meanwhile, Bob moves~\vSimpleTimes{} and its children from the~\texttt{R} child of~\vWrapPlus{} to its~\texttt{L} child
by deleting~\eMoveTimes{} and adding~\eNestedPartsBob{}, which results in the graph in \autoref{fig:NestedParts:b}.
Since edits are based on edge identifiers and not locations in a tree,
both Alice's and Bob's edits can be applied to the other's graph,
which results in Alice and Bob both having the graph in \autoref{fig:NestedParts:c}.

Commutativity has consequences for this scenario.
Commutativity require that edits produce the same result regardless of the order in which they are applied.
So, if Alice receives Bob's deletion of~\eMoveTimes{} then makes her
changes before receiving Bob's addition of~\eNestedPartsBob{},
the result must still be the graph in \autoref{fig:NestedParts:c}.
In that case, her edits would then temporarily be within the code deleted by Bob.
Thus, our semantics must allows users to edit deleted code.
(Whether or how this is presented in the user interface is another question.)

TODO: \todo{TODO}She can restore that code using a restoration action add a fresh edge to it.

\subsection{Merge Conflicts}%
\label{sub:Merge Conflicts}

While the collaborative edits discussed so far merge cleanly,
they can also generate graphs that do not map cleanly to a syntax tree.
We call these conflicts and consider cases for \emph{multi-child},
\emph{multi-parent}, and \emph{cycle} conflicts.

As with conflict in line/diff-based version-control
system~(e.g., \texttt{git}, \texttt{mercurial}, \texttt{svn}, etc.),
these all require user intervention to resolve.

We consider common merge scenarios first, and then consider more unusual scenarios.

\subsubsection{Multi-child conflicts}%
\label{sub:Multi-child conflicts}

\figureMultiChild{}

As an example of a multi-chid conflict, suppose Alice and Bob both have the graph in \autoref{fig:NestedParts:c}.
Alice then adds~\vMultiChildAlice{} as the~\texttt{R} child of~\vWrapPlus{}
while Bob also adds~\vMultiChildBob{} as the~\texttt{R} child of~\vWrapPlus{}.
These result in Alice and Bob having the graphs in \autoref{fig:MultiChild:a} and \autoref{fig:MultiChild:b}, respectively.
Note that these graphs have two different edges, \eMultiChildAlice{} and \eMultiChildBob{}, for the~\texttt{R} position of~\vWrapPlus{}.

We merge these edits by including \emph{both} \eMultiChildAlice{} and \eMultiChildBob{}
as edges going out of the \texttt{R} position of \vWrapPlus{}.
This results in \autoref{fig:MultiChild:c}, where there is a multi-child conflict
in the~\texttt{R} position of~\vWrapPlus~(i.e., there are multiple edges for the same position in a vertex).
In the user interface, we flag this conflict with the notation~\conflictHole{x,y}.

TODO: "delete both"

This conflict can be resolved by the user by deleting
one of the edges in conflict and editing the expression pointed to by the other edge to be the correctly merged value.
For example, one could delete \eMultiChildBob{} and then change~\vMultiChildAlice{} to be~\texttt{x * y}.
(Note that users can continue to edit the code while in this conflicted state.
It just must be resolved before the the code is run.\footnote{It
  may be possible to develop evaluation models that allow these sorts of conflicts,
  but that is beyond the scope of this paper.})

TODO: need example of fully-automatic resolution and semi-automatic resolution.
Note that as a convenience to the user, certain simple
conflicts might be automatically resolved,
but we consider this a higher-level, user-interface consideration.

This handling of conflicts is similar traditional merge conflicts in that
it presents alternate versions of the code that the user replaces with the desired merge result.
Our model is different in that merge conflicts in the line-based model
prevent semantic editor services from running
that could continue to run in the graph-based model because
code inside and outside the conflict is still valid code.
It is just the where the multi-child happens that editor services may break down.
\autoref{sec:Related Work} discusses more differences.

\subsubsection{Multi-parent conflicts}%
\label{sub:Multi-parent conflicts}

\figureMultiParent{}

While multi-child conflicts are when multiple edges are in the same \emph{child} position of a vertex,
multi-parent conflicts are when there are multiple \emph{parents} of a vertex.
An example of this is in \autoref{fig:MultiParent}.
\autoref{fig:MultiParent:a} shows the graph after Alice and Bob have made some edits,
and Alice and Bob shared their edits with each other.
Alice then moves~\vNestedPartsAlice{} to the~\texttt{R} position of~\vSimpleTimes{},
while Bob moves it to the~\texttt{R} position of~\vWrapPlus{}.
This results in the graphs in \autoref{fig:MultiParent:b} and \autoref{fig:MultiParent:c}.
In both cases, these edits are achieved with one edge delete and one edge add.
Alice deletes~\eNestedPartsAlice{} and adds~\eMultiParentAlice{}, while
Bob deletes~\eNestedPartsAlice{} and adds~\eMultiParentBob{}.
As explained in \autoref{sec:Formalism}, deletes are idempotent so Alice and Bob both deleting~\eNestedPartsAlice{} is not a problem.
However, both~\eMultiParentAlice{} (added by Alice) and~\eMultiParentBob{} (added by Bob) point to the same vertex.
When their edits are merged, the result is \autoref{fig:MultiParent:d}, in which~\vNestedPartsAlice{} has two parents pointing to it.

TODO: talk about how to resolve the conflict

% \subsubsection{Single-User Cycles}
% \label{sub:Cycles}

% TODO: cut this section

% \figureSingleUserCycles{}

% Another case we must consider is when cycles appear in the graph.
% We categorize these into cycles caused by the action of a single user
% and cycles caused by the interaction of the actions of multiple users.

% In a single user context,
% normal insertion and deletion of code by the user cannot create cycles.
% However, it is possible with certain kinds of copy and paste.
% For example, suppose Alice is editing the code in \autoref{fig:Single-User Cycles:a}
% and uses copy and paste to copy \Vertex{TODO} to the right child of \Vertex{TODO}.
% There are two ways to interpret the paste action.
% The first interpretation is to create a deep copy of \Vertex{TODO}.
% This results in \autoref{fig:Single-User Cycles:b} and
% does not cause a cycle.
% The second interpretation is to simply add an edge to \Vertex{TODO}.
% This results in \autoref{fig:Single-User Cycles:b}
% and causes a cycle.

% Note that not all pastes should be deep copies.
% For example, Alice may have accomplished code move in \autoref{sub:Editing Nested Parts of the Code}
% by a cutting from the old position and pasting to the new position.
% Preserving Bob's nested edits requires that the paste be by reference instead of by copy.
% Distinguishing when a paste should be by reference versus by copy
% is ultimately a user interface question.
% Cycles caused by the local user's edits can be detected as soon as a user enters them
% by noting either that the graph would contain a cycle or the vertex
% already has a parent somewhere in the graph.

% Thus, as a user interface consideration, it might be best to either
% disallow such edits to at least warn users when their
% edits would create a cycle.

\subsubsection{Cycles}%
\label{sub:Multi-User Cycles}

\figureCycle{}

In addition to multi-child and multi-parent conflicts, merges
can cause cycles in the graph.\footnote{In theory a single user could
generate cycles, but this could be detected immediately and the user action
that caused that cycle rejected.
Thus, we are only concerned with cycles that cannot be immediately detected
and prevented by the editor.}
For example, consider the situation in \autoref{fig:Cycle}.
\autoref{fig:Cycle:a} shows the graph after Alice and Bob have made some edits,
and shared them with each other.
Alice then moves~\vMultiCycleTimes{} to the \texttt{R} child of~\vWrapPlus{}
and then~\vMultiCyclePlus{} underneath that.
Bob does the same but puts~\vMultiCycleTimes{} under~\vMultiCyclePlus{}.
This results in \autoref{fig:Cycle:b} and \autoref{fig:Cycle:c}, respectively.

On their own, neither of these edits creates a cycle.
However, merging the edit actions of both Alice and Bob results in the graph
in \autoref{fig:Cycle:d}, which has a cycle
between~\vMultiCycleTimes{} and~\vMultiCyclePlus{}.
As with the other kinds of conflict, resolving it requires user input.
For example, by either deleting both~\eMultiCycleBobPlus{} and~\eMultiCycleBobTimes{}~(thus favoring Alice's version)
or deleting both~\eMultiCycleAliceTimes{} and~\eMultiCycleAlicePlus{}~(thus favoring Bob's version).

\paragraph{Disconnected Cycles}

\figureDisconnect{}

TODO: technically a cycle

TODO: in general detect when there are or were edits to something now deleted

\todo{UI would show orphans only once edits orphans occur}

Finally, there is a particular type of cycle worth discussing.

Since a cycle like this that is connected to the root vertex always
contains vertexes with multiple parents that if removed would break the cycle,
we use the user interface described in \autoref{sub:Multi-parent conflicts}
to display these kinds of programs.
For example, \autoref{fig:Cycle:d} would be displayed.
We leave the user interface considerations of resolving the conflict such a
cycle represents to future work.

Finally, when multi-user edits are merged,
parts of the graph can become disconnected from the root
even though they are connected to the root in each user's
copy of the graph before the merge.

For example, consider the situation in \autoref{fig:Disconnect:a},
which shows the graph after Alice and Bob have made some edits,
and shared their edits with each other.
Alice then moves~\vMultiCycleTimes{} under~\vSimpleTimes{},
while Bob moves~\vSimpleTimes{} under~\vMultiCycleTimes{}.
This results in \autoref{fig:Disconnect:b} and \autoref{fig:Disconnect:c}, respectively.

When these edits are merged, the result is \autoref{fig:Disconnect:d}.
Since Alice deleted~\eNestedPartsBob{}
and Bob deleted~\eMultiCycleAliceTimes{},
when these are merged~\vMultiCycleTimes{} and~\vSimpleTimes{}
are disconnected from the root.

This is similar to the type of merge conflict
that can arise in traditional version control systems
when two users delete different functions that
are duplicates of the other.

Fortunately, we can detect this situation and warn the user
since the disconnection appears after merging two graphs
in which vertexes were not already disconnected.

\subsection{Cursors}%
\label{sub:Cursors}

\paragraph{Representation}

For most editing a cursor is represented by a position within a vertex.
For example, in TODO, Bob's cursor might be at the TODO position of the TODO:vertex.
Representing it this way means that if Bob or some other user deletes TODO:vertex
and replaces it with a different vertex, Bob's cursor is still valid.
We specify a position within a vertex instead of a vertex because TODO.

However, there is one case where we need a more precise cursor.
That is when a vertex has a multi-child conflict (e.g. TODO in FIG:TODO).
We want users to beable to put their cussor on either the conflict as a whole
(e.g., TODO: \texttt{\{ x | y \}})
or on an individual element (e.g., \texttt{x} or \texttt{y}).
In the former case, a pair of a vertex and a child position suffices.
For the latter case, we represent cursors by an edge identifier (e.g., TODO in TODO:FIG).

\paragraph{Communication}

In our system all edits use edge and vertex identifiers, and user
cursors do not affect the interpretation of graph edits.
Thus, cursors need not be communicated to other users.
However, in a collaborative setting, seeing the cursors of other users
can be useful.
For this purpose, editors can announce their cursor position to other editors.
At any point in time, the announcement
with the most recent timestamp
for a particular user
is used.

Note that this cursor position may refer to edges or verticies that
do not yet exist on the receivers machine.
In these cases, we can either not display the other user's cursor (and perhaps
have a visual display flagging this fact), or we can display the most recent
cursor that represents a valid position in the local graph (perhaps
shown in a fadded color to show that this cursor is known to not be up to date).
(Or perhaps, all cursors always fade/decay over time like on radar blips.)

\section{Formalism}%
\label{sec:Formalism}

We will now make the intuitions developed in the previous section precise
by defining a collaborative structure editor calculus called Grove.
We begin in Sec.~\ref{sub:Syntax} with the syntax, then discuss
the internal graph representation in Sec.~\ref{sub:Convergent Graphs},
...


TODO: point of this section is commutativity theorem

TODO: (though as we show in \autoref{sec:Formalism} creating a vertex is implicit in edge creation)

The formalism is rather simple, \autoref{sec:Grove By Example} shows
that it is sufficient to handle many common situations,
and this simplicity aids in the predictability.

\begin{figure}
  \[
    \arraycolsep=0pt
    \begin{array}{lrlll}
      q    & {}\in Pat & {}::={} & x^{\id{u}} \mid \hole \mid \conflictHole{q,\ldots,q} \mid \multiVertex{u} \mid \cycleVertex{u} \\
      \tau & {}\in Typ & {}::={} & \tau \rightarrow^{\id{u}} \tau \mid Num^{\id{u}} \mid \hole \mid \conflictHole{\tau,\ldots,\tau} \mid \multiVertex{u} \mid \cycleVertex{u} \\
      e    & {}\in Exp & {}::={} & x^{\id{u}} \mid \lambda^{\id{u}} q \mathord{:}\tau.e \mid (e~e)^{\id{u}} \mid n^{\id{u}} \\
           &           &         & ~\mid e~\texttt{+}^{\id{u}}~e \mid e~\texttt{*}^{\id{u}}~e \mid \hole \mid \conflictHole{e,\ldots,e} \mid \multiVertex{u} \mid \cycleVertex{u} \\
    \end{array}
  \]
  \caption{Base syntax, as a grammar, for the lambda calculus that we are considering.}
  \label{fig:Base syntax}
\end{figure}

\subsection{Syntax}%
\label{sub:Syntax}

The language we are modeling is shown in \autoref{fig:Base syntax}, standard for a simply-typed lambda calculus except that all sorts have empty holes (represented by $\hole$) and conflict holes (of the form $\conflictHole{q,\ldots,q}$).
In particular, the argument of a lambda can be either a bound variable or a hole.
Additionally, all non-hole forms have a superscripted identifier $u \in \U$.

% Turn that into a constructor set K + position set P + arity function (has
% type: K -> $\wp$(P)).

% TODO: replace positions with macros

\begin{figure}
  \[
    \arraycolsep=0pt
    \begin{array}{ll}
      \arity : \K \hfil \rightarrow & \wp(\P \times \{Exp, Pat, Typ\}) \\
      \hline
      \arity(\Root)={} & \left\{ \Root \right\} \\
      \arity(\PatVar(x))={} & \left\{ \right\} \\
      \arity(\ExpVar(x))={} & \left\{ \right\} \\
      \arity(\ExpLam)={} & \left\{ (\LamParam, Pat), (\mathtt{Type}, Typ), (\mathtt{Body}, Exp) \right\} \\
      \arity(\ExpApp)={} & \left\{ (\mathtt{Fun}, Exp), (\mathtt{Arg}, Exp) \right\} \\
      \arity(\ExpPlus)={} & \left\{ (\mathtt{L}, Exp), (\mathtt{R}, Exp) \right\} \\
      \arity(\ExpTimes)={} & \left\{ (\mathtt{L}, Exp), (\mathtt{R}, Exp) \right\} \\
      \arity(\ExpNum(n))={} & \left\{ \right\} \\
      \arity(\TypArrow)={} & \left\{ (\mathtt{Arg}, Typ), (\mathtt{Result}, Typ) \right\} \\
      \arity(\TypNum)={} & \left\{ \right\} \\
    \end{array}
  \]
  \caption{Constructors, Indexes and Arity}
  \label{fig:Constructors, Indexes and Arity}
\end{figure}

\subsection{Convergent Graphs}%
\label{sub:Convergent Graphs}

\subsubsection{Graphs}%
\label{sub:Graphs}

A graph $G : \E \rightarrow \Sigma$ is a function from edges to edge states,
where $\E = \U \times \V \times \P \times \V$,
unique IDs are drawn from some suitable set $\U$ equipped with a total ordering $\leq$,
vertices are drawn from $\V$,
positions are drawn from $\P$,
and edge states are drawn from $\Sigma$, all defined below.

Each edge $\e = (u, v, p, v^\prime)$ has a unique name, $u \in \U$, and connects
the child position $p$ of originating vertex $v$ to destination vertex
$v^\prime$. The state of each edge, $\e$, is determined by the corresponding
edge state, $G(\e) \in \Sigma = \{ \bot, \Plus, \Minus \}$. When $G(\e) = \bot$,
$\e$ has not been created or deleted. When $G(\e)$ is $\Plus$, the edge has been
created. When $G(\e)$ is $\Minus$, the edge has been deleted. The total
ordering $\bot \sqsubset \Plus \sqsubset \Minus$ forms a lattice over $\Sigma$.

A vertex $v = (u, k)$ identifies a distinct instance of some constructor $k \in
\K$, corresponding to a non-hole form defined in \autoref{fig:Base syntax}. Each
contructor has an arity, which we define as a set of positions. A position $p
\in \P$ identifies a location at some originating vertex from which edges to
destination vertices may originate. The $\arity$ function in
\autoref{fig:Constructors, Indexes and Arity} gives the complete mapping from
constructors to potential edge positions with their corresponding sorts. Every
graph contains a distinguished root vertex, root constructor, and root position,
respectively named $v_0$, $k_0$, and $p_0$.

% TODO: should graph "recomposition" have an algorithm, too?
A graph can be derived from an expression in the calculus by starting with an
empty graph, selecting unique ids $u, u_k$ and constructor $k$ for the outermost
expression, and creating edge $\e = (u, v_0, p_0, (u_k, k))$. Then, for each
sub-term at some position $p \in \arity(k)$, select unique id $u'$ and
constructor $k'$ and create edge $e' = (u', v, p, v')$ with $v = (u_k, k)$, $v'
= (u', k')$. Continuing in this manner, treat each sub-term as if it were the
outermost, starting with the ones at positions in $\arity(k')$, and create edges
to the vertices representing their immediate sub-terms until only empty holes
remain. Note that empty holes are not modeled explicitly in the graph. Wherever
an empty hole appears in an expression, the corresponding graph position has no
edges originating from it.

% You can map from syntax to graph by selecting
% unique IDs $u$ (for both edges and vertexes).
% - holes are not explicit in the graph

\subsubsection{Graph Edits}%
\label{sub:Graph Edits}

We define a graph edit $\alpha \in \A = \left\{\Plus, \Minus\right\} \times \E$
as a pair of an edge state, excluding $\bot$, and an edge. As a shorthand, we
define $+\e$ to be $(\Plus, \e)$ and $-\e$ to be $(\Minus, \e)$.

We define the join operation $s_1 \sqcup s_2$ to be the least upper bound of
$s_1$ and $s_2$ with respect to the $\sqsubset$ ordering. Accordingly, $\Plus
\sqcup \bot = \Plus$ means that edges can only be created if they do not already
exist, and $\Plus \sqcup \Minus = \Minus = \Minus \sqcup \Minus$ means that once
an edge is deleted it can never be restored.

We define the semantics of graph actions via the following transition relation
between graphs.
\[
  G \overset{(s,\e)}{\longrightarrow} G\left[ \e \mapsto s \sqcup G(\e) \right\}
\]
Applying graph action $\left(s, \e\right)$ to graph $G$ results in the
updated graph $G' = G\left[\e \mapsto s \sqcup G(\e) \right]$, wherein the edge
state associated with edge $\e$ in $G$ becomes the join of $s$ with the state of
$\e$ in $G$, and $G'(\e') = G(\e')$ for all other $\e' \ne \e$ in the domain of
$G$.

% Graph action semantics is a transition system between graphs.
% (join with whatever it was before)

% Intuitively, joining any edge state with $\bot$ is always the non-$\bot$ edge state (once an edge exists, it always exists).
% Joining anything with $\Minus$ is always $\Minus$ (once an edge is marked as deleted, it is permanently deleted).

\subsection{Commutativity}%
\label{sub:Commutativity:formal}

In order to define commutativity, we first define a lattice over $G$.
Then we show that for any graphs $G$ and $G'$ and graph action $\alpha$,
$G \overset{\alpha}\rightarrow G'$
iff $G \sqcup \llbracket\alpha\rrbracket = G'$.
Thus the commutativity of graph actions is established
by the commutativity of the join operations defining those graph actions.

Discuss uniqueness of uuid

\begin{lemma}[Join Commutativity]
  \label{lem:Join Commutativity}
\end{lemma}

\begin{lemma}[Joining]
  \label{lem:Joining}
  For all graphs $G$ and $G'$ and all edit actions $\alpha$,
  $G \overset{\alpha}{\longrightarrow} G'$
  iff $G \sqcup \llbracket\alpha_1\rrbracket = G'$.
\end{lemma}
\begin{proof}
  If $G \overset{\alpha_1\alpha_2}{\longrightarrow} G'$
\end{proof}


\begin{theorem}[Commutativity]
  \label{thm:Commutativity}
  For all graphs $G$ and $G'$ and all edit actions $\alpha_1$ and $\alpha_2$,
  if $G \overset{\alpha_1\alpha_2}{\longrightarrow} G'$,
  then $G \overset{\alpha_2\alpha_1}{\longrightarrow} G'$.
\end{theorem}
\begin{proof}
  Using \autoref{lem:Joining} to unfold $\rightarrow$ into $\sqcup$,
  $G \sqcup \llbracket\alpha_1 \sqcup \llbracket \sqcup \alpha_2 \rrbracket = G'$.
  Then by \autoref{lem:Join Commutativity},
  $G \sqcup \llbracket\alpha_2 \sqcup \llbracket \sqcup \alpha_1 \rrbracket = G'$.
  Finally using \autoref{lem:Joining} to fold $\sqcup$ into $\rightarrow$,
  $G \overset{\alpha_2\alpha_1}{\longrightarrow} G'$.
\end{proof}

\subsubsection{Agda Mechanization}%
\label{sub:Agda Mechanization}

\subsection{Graph Decomposition}%
\label{sub:Graph Decomposition}

% NOTE base grammar has holes. rooted expression grammar has refs, conflicts,
% and multiparents

% NOTE: this whole section is for describing the 4-tuple

Trees are often easier to work with than arbitrary graphs directly, for example to present the graph to users or for type checking.
A graph can be decomposed into a collection of expressions governed by the grammar in \autoref{fig:Base syntax}, which we organize into a structure called a grove.

\figureDecompExample

% TODO: make sure we're not claiming to invent the term "unicycular graph"
% TODO: maybe add a forward reference at end here to Implementation section
% TODO: make ID of y lower than the unicycle root, to show what we're minimizing

A grove is a 4-tuple of the following form:
\[
  (e_r, MP, NP, W)
\]
where
\begin{align*}
  e_r &= \expr(v_0) \\
  MP &= \{\expr(v) : |\parents(v)| > 1\} \\
  NP &= \{\expr(v) : |\parents(v)| = 0 \land v \ne v_0\} \\
  U  &= \{\expr(v) : |\parents(v)| = 1 \wedge v = \min(\ancestors(v))\}
\end{align*}
For example, the grove corresponding to the graph in \autoref{fig:Decomposition example graph} is
given in \autoref{fig:Decomposition example grove}.

Let us now examine each of the four components in more detail.
The first component $e_r$ is the expression derived from the root vertex $v_0$.
\autoref{fig:Decomposition expr} defines $\expr(v)$ wich determines the expression derived from $v$.
There is one rule for each constructor form.
For example, the expression derived from ${+}_{\id{38}} = (38, \ExpPlus)$ is $\expr'({+}_{\id{38}}, \PlusLeft) \text{+}^{\id{38}} \expr'({+}_{\id{38}}, \PlusRight)$.
In each child position, $\expr'(v, p)$ determines the sub-expression derived from the children of $v$ at position $p$.
An empty hole $\hole$ appears if there are no children at the given position.
A conflict hole $\conflictHole{e_1,\ldots,e_n}$ appears if there are multiple children.
If there is one child, the expression is determined recursively unless that child appears in $MP$ or $U$, discussed below, in which case we leave a reference, $\multiVertex{u}$ or $\cycleVertex{u}$ respectively.
For the $\ExpLam$ case, we define $\patt(q)$ and $\type(\tau)$ similarly.

The second component $MP$ is the set of expressions derived from a vertex with multiple parents.
Wherever an edge to such a vertex appears, we place a reference to it $\multiVertex{u}$.
In the example, $x_{\id{42}}$ is referenced twice in $e_r$.

The third component $NP$ is the set of expressions rooted at a vertex with no parents, other than the root vertex.
In the example, $z^{\id{58}}$ has no parents (because it was deleted), so it appears only in $NP$.

The fourth component $U$ is the set of expressions derived from the remaining vertices which necessarily have exactly one parent.
These vertices form structures formally called unicycular graphs~\citep{DBLP:journals/algorithmica/KruskalRS90}, or \emph{unicycles} for short.
Every unicycle consists of a single cycle where each vertex in the cycle may have additional children that are not part of the cycle.
Breaking the cycle turns a unicyclic graph into a tree.
% TODO: try clearing up "the root" as e.g., "the component root" or "the root of this components of the grove"
% TODO: make sure we say "the graph root" when talking about the actual root, and "the component root" everywhere else.
To break the cycle, we arbitrarily choose the vertex on the cycle with the smallest id, $u$, as the root of that tree.
Formally, we choose the vertex $v$ such that $v = \min(\ancestors(v))$ because
only a vertex on the cycle can be its own ancestor.
When an edge to this vertex appears, we place a reference to it $\cycleVertex{u}$.
In our example, ${+}_{\id{46}}$ is referenced by the $LEFT$ edge of ${*}_{\id{48}}$.

\begin{figure}
  \begin{displaymath}
    \begin{array}{l}
      \expr(v=(u, Root)) = expr'(v, Root) \\
      \expr(v=(u, \ExpVar(x))) = x^{\id{u}} \\
      \expr(v=(u, \ExpLam)) = \lambda^{\id{u}} \patt'(v, \LamParam) : \type'(v, \LamType) . \expr'(v, \LamBody) \\
      \expr(v=(u, \ExpApp)) = (\expr'(v, \AppFun)~\expr'(v, \AppArg))^{\id{u}} \\
      \expr(v=(u, \ExpNum(n))) = n^{\id{u}} \\
      \expr(v=(u, \ExpPlus)) = \expr'(v, \PlusLeft)~\texttt{+}^{\id{u}}~\expr'(v, \PlusRight) \\
      \expr(v=(u, \ExpTimes)) = \expr'(v, \TimesLeft)~\texttt{*}^{\id{u}}~\expr'(v, \TimesRight) \\
      \patt(v=(u, \PatVar(x))) = x^{\id{u}} \\
      \type(\tau=(u, \TypArrow)) = \type'(\tau, \ArrowArg) \rightarrow^{\id{u}} \type'(\tau, \ArrowResult) \\
      \type(\tau=(u, \TypNum) = Num^{\id{u}} \\
    \end{array}
  \end{displaymath}

% TODO: comment these out:
%   % | Exp_nil
%   % | Exp_cons
%   % | Exp_case
%   % | Typ_list

  \begin{align*}
    \expr'(v,p) = \begin{cases}
      \hole & \children(v,p) = \varnothing \\
      \conflictHole{\expr(v_1),\ldots,\expr(v_n)} & \children(v,p) = \{v_1, \ldots, v_n\} \\
      \multiVertex{u} & \children(v,p) = \{v'\} \land |\parents(v')| > 1 \\
      \cycleVertex{u} & \children(v,p) = \{v'=(u,k)\} \land |\parents(v')| = 1 \\
          & \phantom{\children(v,p)} \land v' = \min(\ancestors(v')) \\
      \expr(v') & \text{otherwise} \\
    \end{cases}
  \end{align*}

  \begin{align*}
    \patt'(v,p) = \begin{cases}
      \hole & \children(v,p) = \varnothing \\
      \conflictHole{\patt(v_1),\ldots,\patt(v_n)} & \children(v,p) = \{v_1, \ldots, v_n\} \\
      \multiVertex{u} & \children(v,p) = \{v'\} \land |\parents(v')| > 1 \\
      \cycleVertex{u} & \children(v,p) = \{v'=(u,k)\} \land |\parents(v')| = 1 \\
          & \phantom{\children(v,p)} \land v' = \min(\ancestors(v')) \\
      \patt(v') & \text{otherwise} \\
    \end{cases}
  \end{align*}

  \begin{align*}
    \type'(v,p) = \begin{cases}
      \hole & \children(v,p) = \varnothing \\
      \conflictHole{\type(v_1),\ldots,\type(v_n)} & \children(v,p) = \{v_1, \ldots, v_n\} \\
      \multiVertex{u} & \children(v,p) = \{v'\} \land |\parents(v')| > 1 \\
      \cycleVertex{u} & \children(v,p) = \{v'=(u,k)\} \land |\parents(v')| = 1 \\
          & \phantom{\children(v,p)} \land v' = \min(\ancestors(v')) \\
      \type(v') & \text{otherwise} \\
    \end{cases}
  \end{align*}

  \begin{align*}
    \parents(v) &= \{v' : \exists \e = (u, v', p, v), G(\e) = \Plus\} \\
    \ancestors(v) &= \left( \lfp(\ancestors') \right)(v) \\
    \ancestors'(v) &= \parents(v) \cup \ancestors'(\parents(v)) \\
    \children(v, p) &= \{v' : \exists \e (u, v, p, v'), G(\e) = \Plus\} \\
    \min(\{v_1 = (u_1, k_1), \ldots, v_n = (u_n, k_n)\}) &= (u_j, k_j) \text{ s.t. } j \in \{1, \ldots, n\} \land u_j \le u_i \forall i \in \{1, \ldots, n\}
      \end{align*}
  \caption{Caption2 goes here. Note that $\ancestors$ is defined as the least fixed point of $\ancestors'$.}
  \label{fig:Decomposition expr}
\end{figure}

% XXX

decomposition produces sets of trees. As long as everything is well sorted, we
can use them to produce expressions in the main grammar. (alt: define wrt the
graph instead, once we establish the graph can be turned into expressions)

*** well-sortedness judgment on trees: the tree only has valid positions for the
constructors, and the child at each position has the sort corresponding to its
position, and edges in position maps all start at the given constructor.

Theorem: well-sorted graphs produce decompositions of well-sorted trees

``A graph has this property iff these conditions hold''

then we can define a total mapping from well-sorted trees to expressions
(because the tree structure is very generic, so this ties them back to the
earlier grammar.)

forest = 4-tuple

forest validity: each of the trees in the forest are well sorted, and all Refs
point to roots of other trees of the correct sort.

every valid forest corresponds to a well behaved grove (i.e., ``expression
forest'')

soundness: if you start with a valid graph, you get a well behaved grove that
connects every vertex (and only those vertices) in the graph. (i.e., if you turn
it back into a graph, it's the same graph (modulo edge IDs unless we add $\e$ to
Refs??? OR make Ref nullary and pull edge/vertex info from the position map and
add Root sort

OR:

use edge IDs instead of edges and build a mapping from vertices to
sorts---change the $\e$s to $u$s)

% TODO: maybe add a forward reference here to Implementation section

\subsection{User Actions}%
\label{sub:User Actions}

% TODO: define a grammar for user actions --> mapping to sequences of underlying graph edits
% TODO: define well-sorted graph & theorem: graph is well sorted => exists a decomposition

move = delete + add

other composite edits

remember commutativity diagram: we want edits on trees to be equivalent to edits on graphs

given a semantics for user actions, we can show that operating on the grove is equivalent to operating on the graph.
This way is more efficient (less annoying?) because then we don't have to deal with decomposition for every edit.
(we probably want to do it this way in Hazel)

OR

We could go the indirect route and avoid having to prove the theorem.
(this way is easier to start with, and it's how GRV works)

% Mapping to b actions

% \[
%   \begin{array}{l}
%     \textrm{User Actions}: \grave{e} \in Act ::= e \mid \#u \mid \conflict{\grave{e}}{\grave{e}}                                                       \\
%     \s : \G \to Act \times \V^{\ast{}} \times \V^{\ast{}} \times \V^{\ast{}}                                                                                          \\
%     \s(G) = (\grave{e}, \MP(G), \CC(G), \D(G))                                                                                                         \\
%     \MP(G) = \left\{ v \in \vertexes(G) \mid \exists e_1,e_2 \in \liveEdges(G), e_1= \right.                                                           \\
%     \qquad \left. (v,p_1,v_1), e_2=(v,p_2,v_2), e_1 \ne e_2 \right\}                                                                                   \\
%     \CC(G) = \ldots                                                                                                                                    \\
%     \D(G) = \orphans(G) \setminus \left\{ v_0 \right\}                                                                                                 \\
%     \orphans(G) = \left\{ v \in \vertexes(G) \mid \forall e=(v^\prime,p,v^{\prime\prime}) \in \right.                                                  \\
%     \qquad \left. \liveEdges(G), v^{\prime\prime} \ne v \right\}                                                                                       \\
%     \vertexes(G) = \left\{ v \mid \exists e = (v^\prime, p, v^{\prime\prime}) \in \edges(G), v \in \left\{ v^\prime, v^{\prime\prime}\right\} \right\} \\
%     \edges(G) = \left\{ e \mid G(e) \ne \bot \right\}                                                                                                  \\
%     \liveEdges(G) = \left\{ e \mid G(e) = + \right\}                                                                                                   \\
%   \end{array}
% \]

\section{Type System}%
\label{sec:Type System}

Sensibility -- mapping back from graphs
to well-typed states that fixes holes

TODO: somewhere in here, maybe multiple places, we want to talk about typing the intermediate states that arise (background for structured editing)

editor states:

conflicts (multiple children in the same spot)

multi-parent

cycles

non-empty holes

----------------

User must supply edge selection for multi-parent


\section{Implementation}%
\label{sec:Implementation}

% TODO: talk about code generation somewhere in here

% TODO: talk about:
% - decomp vertex set generation and unicycle traversal
% - how to choose which branch of expr' to take
% - lfp(ancestors') and min of it

% TODO: can we save any of this in a README or code comments?

% TODO: talk about performance: O(decomp) given "size of the graph" (probably linear in # edges)

% GRV -- how it is implemented, how it connects to the formalism, describe the graph,

We implemented the core Grove calculus of \autoref{sec:Formalism} as an OCaml library.
Our code is parameterized by a syntax specification for expressions that we generate automatically, which makes the implemented language of expressions easier to modify or replace.
We also built a Web browser-based Grove editor as a proof of concept.

Since we cannot implement an infinite mapping directly, the graph is a data structure, \texttt{Graph.t}, that maps from edges to the edge states $\left\{\Plus, \Minus\right\}$.
We do not represent edges that map to $\bot$.

% TODO: rename Decomposition.ml to Grove.ml

There's a function \verb!decompose! of type \verb!Graph.t) : t * Edge.Set.t Vertex.Map.t! that 

From this graph, we compute the set of all edges and the set of live edges with a linear scan.

% TODO: make this into a listing

\begin{verbatim}
  Graph.edges : Graph.t -> Edge.Set.t
  Graph.live_edges : Graph.t -> Edge.Set.t
\end{verbatim}

% TODO: keep connecting the code to the formalism like this

These vertices are partitioned into three sets: multi-parented, single-parented, or orphaned.
A vertex $v$ is considered a parent of another vertex $v'$ if there is a live edge from $v$ to $v'$.

For each vertex, we take the parent and child edge sets.

% TODO: fix the formalism for parents (to work with edges instead of vertices) and then check that it matches the implementation. Try renaming parents to vparents and adding parents for edges.

% TODO: Talk about how the graph is implemented (not as an actual function, but as a map from edges to edge states) so that we can denote the set of created + deleted edges clearly, as well as all of the vertices that have ever been created.

For a graph $G : \E \to \Sigma$ where $\E = \U \times \V \times \P \times \V$, our graph decomposition algorithm runs in $O(\abs{\V} \log \abs{\V} + \abs{\E} \log \abs{\V})$.
It begins with a scan of all edges that have been created or deleted $O(\abs{\E})$.
Their vertices at both ends are partitioned into three sets: multi-parented, single-parented, or orphaned.
Their relationships are recorded in maps for $O(\log \abs{\V})$ lookups of parent and child edge sets.
After the vertices have been partitioned, we traverse the various single-parented components and produce equivalent expressions $O(\abs{\V})$.
For unicycles, we traverse backwards until a vertex is seen twice $O(\abs{\V})$, then proceed forward to find the least vertex on the cycle $O(\abs{\V})$.

% TODO: is this still a thing?
% Compared to the core language, our implementation lacks support for lists and case expressions.

Optimizations: least fixed point


We determine $e$ by starting at the root of the graph and including every connected
vertex that has a single parent. In positions where there are no children, we
leave an empty hole $\hole$. In positions where there are multiple children, we
leave a conflict hole of the form $\conflictHole{e_1,\ldots,e_n}$. Whenever we
encounter a vertex with multiple parents, we add its corresponding expression to
the second component $MP$ and leave an indirect reference $\multiVertex{u}$, where $u$ is
the unique identifier of the referenced vertex

% here are some properties that show how to get one from the other, and to/from
% graph

algorithmic section: if we want to implement these conversions, here are the
steps (without introducing new concepts):

- linear scan
- breaking out roots
- ...

Graph decomposition occurs in three steps.



% TODO: use code generation instead: have Lang.ml generate expr / expr' / ... for us; then we don't need this figure.
% TODO: maybe show this figure and say that it's possible to handle generically without code generation

% \begin{figure}
%   \[
%     \arraycolsep=0pt
%     \begin{array}{lrlll}
%       \textrm{Trees:\qquad}  & t & {}\in Tree & {}::={} & \textrm{Vertex}(v, m) \mid \textrm{Ref}(v) \\
%       \textrm{Maps:}         & m & {}\in Map & {}::={} & \varnothing \mid p \mapsto [(\e, t), \ldots, (\e, t)]; m \\
%     \end{array}
%   \]
%   \caption{Syntax of graph decomposition trees as a grammar.}
%   \label{fig:Syntax of graph decomposition trees}
% \end{figure}


lemma: a unicycle is a cycle with trees hanging off of it

lemma: unicycle traversal always produces a valid tree

Unicycular graph traversal occurs in two directions. A vertex is chosen as an arbitrary
starting point and its parents are traversed and marked as seen. Any vertex that
has been seen twice must be on the cycle. We take the first one as the root of
the unicycle and traverse its children to produce a tree that covers the unicycular graph.
Any remaining single-parented vertices must be parts of other unicycular graphs and are
unicycle-traversed until there are no more single-parented vertices left.

\section{Related Work}%
\label{sec:Related Work}

Contrast with a traditional diff

Similar to how git merged across moves.
A notable difference though is that \texttt{git} detects
file moves by structural similarity rather than
our nominal equality.
(We exploit this in Subsection~REF:TODO).

Compare this to what happens when there are conflicts in a traditional,
line/diff-based version control system (e.g., \texttt{git}, \texttt{mercurial}, \texttt{svn}, etc.).
Those systems annotate files with difference markers (e.g., sequences of~\texttt{<},~\texttt{>}, or~\texttt{=})
when a merge conflict happens.
These show alternate versions of the code, and it is up to the user
to replace those alternates with the desired merged result.

Another place our model is different
is that changes are explicit rather than being inferred by a \texttt{diff} algorithm.
Finally, in our model, since all changes are in terms of
the structure of the code rather than lines,
all changes respect that structure.
This is unlike the line-based model where there is no guarantee
that a merge conflict follows the grammatical structure of the code.

\subsection{Trees}

\subsubsection{Structure editors}

Hazel~\citep{Omar:2019:10.1145/3290327}

\subsubsection{Tree diff}

We are using action based instead of tree diff

We have to deal with merge

We have to deal with edits from multiple people

J. W. Hunt and M. D. McIlroy. 1976. An Algorithm for Differential File Comparison. Technical Report CSTR 41. Bell Laboratories, Murray Hill, NJ.

Type-directed diffing of structured data \url{https://dl.acm.org/doi/10.1145/3122975.3122976}

  Approximating Tree Edit Distance through String Edit Distance \url{https://dl.acm.org/doi/10.5555/3118232.3118518}

  Meaningful change detection in structured data \url{https://dl.acm.org/doi/10.1145/253260.253266}

  An optimal decomposition algorithm for tree edit distance \url{https://dl.acm.org/doi/10.5555/2394539.2394560}

  Diff/TS: A Tool for Fine-Grained Structural Change Analysis \url{https://dl.acm.org/doi/10.1109/WCRE.2008.44}

An efficient algorithm for type-safe structural diffing \url{https://dl.acm.org/doi/10.1145/3341717}

  Precise Version Control of Trees with Line-Based Version Control Systems \url{https://dl.acm.org/doi/10.1007/978-3-662-54494-5_9}

  A survey on tree edit distance and related problems \url{https://dl.acm.org/doi/10.1016/j.tcs.2004.12.030}

  Cycle-aware minimization of acyclic deterministic finite-state automata \url{https://dl.acm.org/doi/10.1016/j.dam.2013.08.003}

  Computing the Edit-Distance between Unrooted Ordered Trees \url{https://dl.acm.org/doi/10.5555/647908.740125}

  Type-safe diff for families of datatypes \url{https://dl.acm.org/doi/10.1145/1596614.1596624}

  A Categorical Theory of Patches \url{https://dl.acm.org/doi/10.1016/j.entcs.2013.09.018}

  Type-directed diffing of structured data \url{https://dl.acm.org/doi/10.1145/3122975.3122976}

  The Semantics of Version Control \url{https://dl.acm.org/doi/10.1145/2661136.2661137}

  The Tree-to-Tree Correction Problem \url{https://dl.acm.org/doi/10.1145/322139.322143}

  Generic Diff3 for algebraic datatypes \url{https://dl.acm.org/doi/10.1145/2976022.2976026}

\subsection{Version Control}

Git \url{https://git-scm.com/}

Darcs \url{https://darcs.net/}

  Darcs: distributed version management in haskell \url{https://dl.acm.org/doi/10.1145/1088348.1088349}

Hg? \url{https://www.mercurial-scm.org/}

SVN \url{https://subversion.apache.org/}

Pijul and (Anu is a rewrite of Pijul and seems to have been subsumed into Pijul)

  \url{https://pijul.org/}
  \url{https://pijul.org/manual/theory.html}

  \url{https://tahoe-lafs.org/~zooko/badmerge/simple.html}

\subsection{Collaborative Editing}

Collaborative Structure Editing

SmallTalk collaboration with images

TouchDevelop papers

Lots of list-of-chars or list-of-list-of-chars (we ignore these except to discuss them here)

\subsection{CRDTs}
(Are we a known CRDT?)

List of CRTD papers: \url{https://crdt.tech/papers.html}

Bottom = Tombstone

https://www.waitingforcode.com/big-data-algorithms/conflict-free-replicated-data-types-flags-graphs-maps/read
 - Add-Remove Partial Order data type
 - 2P2P-Sets
 - Replicated Growable Array

\url{https://github.com/PsychoLlama/graph-crdt}
 - Graph CRDT
 - Uses a LWW-E-Set

\url{https://martin.kleppmann.com/2020/07/06/crdt-hard-parts-hydra.html} (overview talk)
 We don't have interleaving problems because
   - everything is relative to a specific ID not a position
   - we don't try to auto resolve
   - we are tree not list
   Part three: moving sub tree
   - Last parent writter wins (prevents cycles)
     Equivalent to us if we filter multiparent edges, different for cycles, no way to delete?

A commutative replicated data type for cooperative editing
  \url{https://hal.inria.fr/inria-00445975/document}
  Describes TreeDoc but this uses a document model that is a list (tree is just how it is implemented)

Logoot : a Scalable Optimistic Replication Algorithm for Collaborative Editing on P2P Networks
  \url{http://pagesperso.lina.univ-nantes.fr/~molli-p/pmwiki/uploads/Main/weiss09.pdf}

Specification and Complexity of Collaborative Text Editing
  \url{https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/podc16-complete.pdf}

LSEQ: an Adaptive Structure for Sequences in Distributed Collaborative Editing,
  \url{https://hal.archives-ouvertes.fr/file/index/docid/921633/filename/fp025-nedelec.pdf}

Data consistency for P2P collaborative editing
  \url{https://hal.archives-ouvertes.fr/file/index/docid/108523/filename/OsterCSCW06.pdf}

Interleaving anomalies in collaborative text editors
  \url{https://martin.kleppmann.com/papers/interleaving-papoc19.pdf}

Moving Elements in List CRDTs
  \url{https://martin.kleppmann.com/papers/list-move-papoc20.pdf}

A highly-available move operation for replicated trees and distributed filesystems
  \url{https://martin.kleppmann.com/papers/move-op.pdf}

...
 commutative replicated data types CmRDT
 convergent replicated data types, or CvRDTs
 Delta state CRDTs[12][13] (or simply Delta CRDTs

The Causal Graph CRDT for Complex Document Structure
  \url{https://dl.acm.org/doi/10.1145/3209280.3229110}

\url{https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type}

G-Set
PN-Set
2P-Set
LWW-element-Set (Last-Write-Wins)
OR-Set
MV-Register: Multi-Value Register
U-Set (this is what we are for edges, not OR-set due to duplicates)
Add-Remove Partial Order data type
  2P-Set for vertices, and a G-Set for edges.

A comprehensive study of Convergent and Commutative Replicated Data Types (2011)
  \url{https://hal.inria.fr/inria-00555588/document}

CRDTs: Consistency without concurrency control
  \url{https://arxiv.org/abs/0907.0929}

https://medium.com/@amberovsky/crdt-conflict-free-replicated-data-types-b4bfc8459d26
 removeVertex() has priority, all incident edges are removed
 addEdge() has priority, all removed vertices are re-added
 Delay removeVertex() execution till all concurrent removeVertex() are executed.
First one is 2P2P-Set

https://crdt.tech/papers.html

Mahsa Najafzadeh, Marc Shapiro, and Patrick Eugster. Co-design and verification of an available file system. In 19th International Conference on Verification, Model Checking, and Abstract Interpretation, VMCAI 2018, pages 358--381. Springer LNCS volume 10747, January 2018. [ bib | DOI | .pdf ]
  \url{http://dx.doi.org/10.1007/978-3-319-73721-8_17}
  https://pages.lip6.fr/Marc.Shapiro/papers/VMCAI-2018-filesys.pdf

Martin Kleppmann and Alastair R Beresford. A conflict-free replicated JSON datatype. IEEE Transactions on Parallel and Distributed Systems, 28(10):2733--2746, April 2017. [ bib | DOI | arXiv ]
  http://dx.doi.org/10.1109/TPDS.2017.2697382
  http://arxiv.org/abs/1608.03960

Vinh Tao, Marc Shapiro, and Vianney Rancurel. Merging semantics for conflict updates in geo-distributed file systems. In 8th ACM International Systems and Storage Conference, SYSTOR 2015. ACM, May 2015. [ bib | DOI | .pdf ]
  http://dx.doi.org/10.1145/2757667.2757683
  https://pages.lip6.fr/Marc.Shapiro/papers/geodistr-FS-Systor-2015.pdf

Mehdi Ahmed-Nacer, Stphane Martin, and Pascal Urso. File system on CRDT. Research Report RR-8027, INRIA, July 2012. [ bib | arXiv | http ]
  http://arxiv.org/abs/1207.5990
  https://hal.inria.fr/hal-00720681/

Stphane Martin, Pascal Urso, and Stphane Weiss. Scalable XML collaborative editing with undo. In On the Move to Meaningful Internet Systems (OTM), pages 507--514. Springer LNCS volume 6426, October 2010. [ bib | DOI | arXiv ]
  \url{http://dx.doi.org/10.1007/978-3-642-16934-2_37}
  http://arxiv.org/abs/1010.3615



2P-Sets
Anomaly: Creating a lone deleted vertex requires create and delete of otherwise unneeded edge

Operational Transforms

Etherpad

Live Share

\subsection{Synchronization}

Unision
\url{https://www.cis.upenn.edu/~bcpierce/unison/}
\url{https://www.cis.upenn.edu/%7Ebcpierce/papers/index.shtml#File%20Synchronization}

\subsection{TODO}

Homotopical Patch Theorey: \url{https://www.cambridge.org/core/journals/journal-of-functional-programming/article/homotopical-patch-theory/42AD8BB8A91688BCAC16FD4D6A2C3FE7}
Homotopical patch theory: \url{https://dl.acm.org/doi/10.1145/2628136.2628158}

\section{Discussion and Conclusion}%
\label{sec:Discussion and Conclusion}

TODO: leaves

TODO: our model supports treating these as a cons-list of characters

TODO: (Place somewhere) This move semantics gives us a richer structure than
when treating code as a list of lines.  We exploit
this in Section~REF:TODO in order merge edits that involve moving code.

TODO: Traditional diff: no relation (and indent might change)

TODO: memory usage

TODO: cache eviction algorithm

TODO: Finally, note that through we present several complex scenarios, this is merely for presentation.
In practice, these complex scenarios occur less frequently than portrayed here.

\subsection{Variable names, strings, and numbers}%
\label{sub:Variable names, strings, and numbers}

NOTE: we could implement each digit as a separate characters

GUI for string conflicts: use popups

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
  %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

%% Appendix
\appendix

%% Appendixes that will be published  go **BEFORE** the bibliography and count towards the page count

%% Bibliography
\bibliography{grove-paper}

%% Temporary appendixes that will not be published go **AFTER** the bibliography and do not count towards the page count

\clearpage % Put these appendixes on separate pages so we can easily remove them from the document.  Also ensure all figures have been placed.

\section{Supplemental Material: Complete Graph Sequences for All Figures}%
\label{apx:Supplemental Material: Complete Graph Sequences for All Figures}

TODO: put all intermediate states for all graphs along with the edge actions

\end{document}
