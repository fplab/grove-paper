
\section{Introduction}%
\label{sec:Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Programming is an increasingly collaborative activity.
Today, collaborative editing services are either provided directly by an asynchronous,
diff-and-merge-based version control system like git, darcs, or pijul,
or they are integrated into a real-time editor built on top of a distributed consistency protocol such as OT or CRDT.
Whereas algorithms for collaborative text editing have been well developed,
we know far less about collaborative editing of more structured documents---specifically, of program source files---%
hence we are motivated to ask the following questions:
\begin{itemize}
\item Is there a more natural model for collaborative editing of tree structures?
\item How do we preserve user intent in the presence of concurrent, non-linear edits?
\end{itemize}

Diff-and-merge is clearly not an ideal solution.
Since diffs do not provide information on the original scope or ordering of edits,
the merging process must reconstruct an approximation, e.g., as a sequence of line additions and deletions.
In a tree-native setting,
line-based merging is not only less likely to succeed than one which retains finer grained information,
it is also less able to provide useful information about conflicting edit states as they arise.
Moreover, because diffs cannot guarantee preservation of user intent,
critical features such as identity-preserving repositioning are impossible to implement on top of them.

Operational Transformation (OT), on the other hand, goes perhaps too far in the opposite direction.
It is a distributed system architecture that coordinates the proliferation and maintainance of edits and edit states.
Industrial-scale collaborative editors, such as Google Docs,
employ OT for real-time applications requiring strong eventual consistency of causally ordered events.
It does so by maintaining an event log it transforms upon each new entry in order to preserve the causal ordering.

The Convergent Replicated Data Type (CRDT) was proposed as a simpler alternative to the OT architecture.
CRDTs do not require causal ordering maintenance because the language of edits must form a join semilattice,
thereby ensuring the edit state update function increases monotoncally.
(Foreshadow solution by warning about a shortcoming of CRDT.)

(Propose Grove as a solution)

% OT is a natural fit for character-based editing, but the architecture is hard to extend, so it is rarely used for more structured documents.
% CRDT imposes less restrictions on the structure of the underlying document,
% providing a more natural substrate for collaborative structure editing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% tease out some common problems (tree-native, collaborative)

% propose a solution







% algorithms for collaborative text editing are well developed
% natural fit for text
% not a natural fit for trees
% so if you want to build a grove, a more natural approach is needed


% a lot of collaborative editing of other sorts (not necessarily programming) requires a tree model,
% but that problem doesn't seem to have been study directly (maybe except JSON CRDT).

% A \emph{collaborative structure editor} is an editor that
% (1) allows multiple concurrent users to work on a shared document, while also
% (2) providing structure-aware editor services such as projectional editing, syntax highlighting, or automatic code folding.
% %
% Collaborative editing research focuses on the design and implementation of real-time, multi-user, character-based communication systems,
% whereas structure editors typically presume a more complex document schema and then focus on some other aspect of the user experience.
% In both settings, preservation of user intent is a core technical challenge.
% %
% Although collaborative editors and structure editors have overlapping goals (optimal user experience)
% and complementary design challenges (subject-subject versus subject-object harmony),
% to our knowledge, there is no comprehensive, principled account of their combined use.

% Since collaborative editors are essentially distributed systems, existing work tends to focus on extensions to distribution protocols.
% Lots of examples using OT. (Google Docs)
% OT is complex and largely textual.
% OT can make sense for real time systems: users typically change one character at a time, and instant feedback can help to prevent conflicts.
% On the other hand, OT system designs can be difficult to extend.

% Alternatively, there's CRDT. (Peritext?)
% CRDT is easier to implement, but harder to design for.
% There's an All-CRDT editor---it turned out to be not so realistic. (what's it called again?)

% Structure editing has been a recurring theme in the computer science literature since at least Engelbart's ``Mother of All Demos.''
% Provides automation for domain experts and reduces the barrier to entry for everyone else.
% Popular for editing programs, i.e., for programming language-specific editors.

% However, modern program editors typically disable editor services (like what?) when the document is not in a consistent state,
% a phenomenon called the ``gap problem.''
% Of course, in the presence of multiple concurrent users, the problem gets worse.

% In a collaborative setting,
% Hazel is a structure editor with support for advanced editing services, (e.g., semantic actions?).

\newpage




Motivation:

- collaborative editing (both synchronous ala Google Docs and asynchronous version control)
is good and important as computing grows

- semantic structure editing is good because it solves the gap problem (semantic editor services
are always available) -- cite Hazelnut papers (talk about holes)

- previous approaches to collaborative editing have limitations

- diff/merge based approaches (trying to solve the inverse problem based on final states --
you lose the actual actions that were performed, and have to reconstruct them or an approx.
of them i.e. add line/delete line actions -- would need to adapt this to structure editing,
some papers have started to look at that, but fundamentally we don't want to throw away the
knowledge we have about the edits!)

- operational transforms (complexity, you have to patch previous actions based on new actions)

- CRDT-based collaborative editing (that's all been on text, not PL semantics) -- this is good
because it is relatively simple: you just send all the edits to all the replicas and they are
convergent by design

- we want to have the same convergence for a CRDT-based collaborative structure editor that maintains
the sensibility invariant of Hazelnut, i.e. every editor state has meaning. mention that maintaining sensibility
allows scaling of semantic editor services in the presence of large number of collaborators (in contrast,
using VS Code or other collaborative text editors with large numbers of collaborators means that almost always
the semantic editor services will be disabled because the program is going to be broken in multiple places
transiently)

this is tricky because:

- some edits might be conflicting -- solve this with "conflict holes"

- adding cut/paste or delete/restore allows for degenerate programs (cycles, multiple parents, etc.)

- since we are commutative, we solve both synchronus and async collaborative editing

- and this resolves issues around merges and conflicts

- contribution of this paper is to solve these problems from type-theoretic first principles:

- ...

- Hazel

\subsection{Contributions and Paper Organization}%
\label{sec:Contributions and Paper Organization}
