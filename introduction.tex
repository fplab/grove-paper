
\section{Introduction}%
\label{sec:Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Programming is an increasingly collaborative activity.
Today, most programming editors are not explicitly designed with collaboration in mind,
so programmers rely on ad hoc integrations of asynchronous diff-based version control systems like Git, Darcs, or Pijul.

Asynchronous diffing is not an ideal solution to collaboration because
the merging process must solve the \textbf{inverse problem}---inference of compatible edits in a simplistic edit action language.
For example, suppose Alice and Bob are collaboratively editing a file comprised of a single line \verb|A B|.
Alice changes the file to \verb|A B C| and communicates the change to Bob as a diff (Figure \ref{fig:inverse-problem:alice}).
At the same time, Bob changes the file to \verb|A D B| and sends Alice a diff (Figure \ref{fig:inverse-problem:bob}).
Both parties changed the same line, but in a different way,
so when Bob applies Alice's diff, a merge conflict arises and the contents of Bob's editor is mangled as in Figure \ref{fig:inferse-problem:diff}.

\begin{figure}[H]
  \begin{subfigure}{.45\linewidth}
\begin{verbatim}
1c1
< A B
---
> A B C
\end{verbatim}
    \label{fig:inverse-problem:alice}
    \subcaption{From Alice to Bob}
  \end{subfigure}
  \hfil
  \begin{subfigure}{.45\linewidth}
\begin{verbatim}
1c1
< A B
---
> A D B
\end{verbatim}
    \label{fig:inverse-problem:bob}
    \subcaption{From Bob to Alice}
  \end{subfigure}

  \begin{subfigure}{.45\linewidth}
\begin{verbatim}
<<<<<<< Alice
A B C
||||||| base
A B
=======
A D B
>>>>>>> Bob
\end{verbatim}
    \label{fig:inverse-problem:diff}
    \subcaption{Bob's editor (diff)}
  \end{subfigure}
  \hfil
  \begin{subfigure}{.45\linewidth}
\begin{verbatim}
A { B | D} { C | B}
\end{verbatim}
    \label{fig:inverse-problem:grove}
    \subcaption{Bob's editor (Grove)}
  \end{subfigure}
  \label{fig:inverse-problem}
  \caption{The effects of diff-and-merge on conflicting edit states}
\end{figure}

An alternative to solving the inverse problem is to build the editor on top of a distributed collaboration protocol such as OT or,
more recently, to model the shared edit state as a CRDT---a data structure implemented behind a fixed set of commutative update operations.
Commutativity is desirable because it reduces collaboration to a simple matter of record and replay.
Since CRDT imposes no other design constraints, it is potentially better suited for collaborative program editing than diff-and-merge.
For instance, the \textbf{conflict problem}---how to meaningfully represent conflicts without mangling edit state---%
becomes easier to solve as the language of edits becomes more precise (Figure \ref{fig:inverse-problem:grove}).

Although CRDT may offer a more natural medium for collaborative programming than diffs,
care must be taken to ensure the preservation of user intent.
Suppose Alice and Bob are collaboratively editing the line \verb|A B| with Alice's cursor on \verb|A| and Bob's on \verb|B|.
If Alice moves \verb|A| to the other side of \verb|B|, it isn't obvious where Bob's cursor should go.
Naively, since the cursor was originally on the second element (\verb|B|), it could simply stay there,
which in this case means it winds up on \verb|A|.
Realistically, \verb|A| and \verb|B| could be very long functions, in which case Bob's cursor would suddenly appear to move a great distance.
If Bob's cursor does not need to react to other users' activity, there is no risk of a disorienting jump.
One way to solve this \textbf{repositioning problem} and affect confusion-free movement is to uniquely identify every piece of editable content.

To address these problems we propose \emph{Grove}, a CRDT-backed collaborative structure editor.
Grove represents the edit state as a labeled, directed multigraph with vertex insertion and deletion operations such that deletion always wins.
In the graph, conflicts have a natural representation as edges with common origin or destination vertices.
Each label includes a unique identifier which enables not only a solution to the repositioning problem
but also a means to construct symbolic references into the edit state.
By leveraging an isomorphism between the graph and its corresponding \emph{grove}---%
a collection of disjoint forests connected via symbolic reference---%
views of the graph may be projected into a tree-native setting, for instance as terms in the Hazel editor,
without adding compexity to the underlying collaboration model.

% We are further motivated by the pursiut of a collaborative extension for Hazel, an integrated programming language and structure editor
% that provides semantic editor services by enforcing a sensibility invariant, i.e., every edit state is semantically valid,
% an interesting avenue of future work with potential implications for the scalability of collaborative programming editors.

% do this instead:
%   the standard method is diff-based version control.
%   diff is bad, evene for what it's indended for.
%   here's why: solving inverse problem ==> have to infer edits
%   alternative approach is to record the edits directly and then form a CRDT s.t. collaboration can be accomplished by sending your edits to your collaborators
%   primarily been explored in the setting of real time text editing
%   there are some aspects of this approach that don't make it suitable for programming:
%   1. the repositioning problem
%   2. the conflict problem (even json crdt does ad hoc conflict resolution)

% Note: you'd still want to solve these problems for text as well, but we're interested in making this work for Hazel
% Hazel is good for this because it already has a rich calculus of edit actions -- motivates the tree focus
% Even when it comes to rich text editing, we really wanna be working with trees: due to markup

% move to related work

% Operational Transformation (OT), on the other hand, goes perhaps too far in the opposite direction.
% OT is a distributed system architecture that coordinates the proliferation and maintainance of edits and edit states.
% Industrial-scale collaborative editors, such as Google Docs,
% employ OT for real-time applications requiring strong eventual consistency of causally ordered events.
% It does so by maintaining an event log it transforms upon each new entry in order to preserve the causal ordering.

% The Convergent Replicated Data Type (CRDT) was proposed as a simpler alternative to the OT architecture.
% CRDTs do not require causal ordering maintenance because the language of edits must form a join semilattice,
% thereby ensuring the edit state update function increases monotonically.
% CRDT places fewer constraints than OT on the language of edits,
% so calculi for editing tree-native documents can be simpler to model for CRDT than OT.
% Similarly, by eliminating all but one design constraint, edit calculi for CRDT can be easier to implement and extend.

% Unfortunately, monotonicity merely changes the nature of the complexity rather than eliminating it entirely.
% Although tree-native document editing calculi may ultimately admit simpler designs under CRDT than OT,
% there are no generic recipes for transforming a sequential tree editing calculus into one suitable for CRDT.
% Consequently, progress of CRDT-backed tree editors has slowed as the research community debates whether CRDT is living up to its promise.
% Thus, we are motivated to ask:
% Is there a more natural model for collaborative editing of trees?
% And how do we preserve user intent in the presence of concurrent edits in a tree-native editor?



% algorithms for collaborative text editing are well developed
% natural fit for text
% not a natural fit for trees
% so if you want to build a grove, a more natural approach is needed


% a lot of collaborative editing of other sorts (not necessarily programming) requires a tree model,
% but that problem doesn't seem to have been study directly (maybe except JSON CRDT).

% A \emph{collaborative structure editor} is an editor that
% (1) allows multiple concurrent users to work on a shared document, while also
% (2) providing structure-aware editor services such as projectional editing, syntax highlighting, or automatic code folding.
% %
% Collaborative editing research focuses on the design and implementation of real-time, multi-user, character-based communication systems,
% whereas structure editors typically presume a more complex document schema and then focus on some other aspect of the user experience.
% In both settings, preservation of user intent is a core technical challenge.
% %
% Although collaborative editors and structure editors have overlapping goals (optimal user experience)
% and complementary design challenges (subject-subject versus subject-object harmony),
% to our knowledge, there is no comprehensive, principled account of their combined use.

% Since collaborative editors are essentially distributed systems, existing work tends to focus on extensions to distribution protocols.
% Lots of examples using OT. (Google Docs)
% OT is complex and largely textual.
% OT can make sense for real time systems: users typically change one character at a time, and instant feedback can help to prevent conflicts.
% On the other hand, OT system designs can be difficult to extend.

% Alternatively, there's CRDT. (Peritext?)
% CRDT is easier to implement, but harder to design for.
% There's an All-CRDT editor---it turned out to be not so realistic. (what's it called again?)

% Structure editing has been a recurring theme in the computer science literature since at least Engelbart's ``Mother of All Demos.''
% Provides automation for domain experts and reduces the barrier to entry for everyone else.
% Popular for editing programs, i.e., for programming language-specific editors.

% However, modern program editors typically disable editor services (like what?) when the document is not in a consistent state,
% a phenomenon called the ``gap problem.''
% Of course, in the presence of multiple concurrent users, the problem gets worse.

% In a collaborative setting,
% Hazel is a structure editor with support for advanced editing services, (e.g., semantic actions?).

\newpage




% Motivation:

% - collaborative editing (both synchronous ala Google Docs and asynchronous version control)
% is good and important as computing grows

% - semantic structure editing is good because it solves the gap problem (semantic editor services
% are always available) -- cite Hazelnut papers (talk about holes)

% - previous approaches to collaborative editing have limitations

% - diff/merge based approaches (trying to solve the inverse problem based on final states --
% you lose the actual actions that were performed, and have to reconstruct them or an approx.
% of them i.e. add line/delete line actions -- would need to adapt this to structure editing,
% some papers have started to look at that, but fundamentally we don't want to throw away the
% knowledge we have about the edits!)

% - operational transforms (complexity, you have to patch previous actions based on new actions)

% - CRDT-based collaborative editing (that's all been on text, not PL semantics) -- this is good
% because it is relatively simple: you just send all the edits to all the replicas and they are
% convergent by design

% - we want to have the same convergence for a CRDT-based collaborative structure editor that maintains
% the sensibility invariant of Hazelnut, i.e. every editor state has meaning. mention that maintaining sensibility
% allows scaling of semantic editor services in the presence of large number of collaborators (in contrast,
% using VS Code or other collaborative text editors with large numbers of collaborators means that almost always
% the semantic editor services will be disabled because the program is going to be broken in multiple places
% transiently)

% this is tricky because:

% - some edits might be conflicting -- solve this with "conflict holes"

% - adding cut/paste or delete/restore allows for degenerate programs (cycles, multiple parents, etc.)

% - since we are commutative, we solve both synchronus and async collaborative editing

% - and this resolves issues around merges and conflicts

% - contribution of this paper is to solve these problems from type-theoretic first principles:

% - ...

% - Hazel

\subsection{Contributions and Paper Organization}%
\label{sec:Contributions and Paper Organization}
